<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rails on {code that works}</title>
    <link>http://localhost:1313/categories/rails/</link>
    <description>Recent content in Rails on {code that works}</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 13 Oct 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/rails/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Implementing Rate Limiting in Rails - Part 2</title>
      <link>http://localhost:1313/blog/2013/10/13/implementing-rate-limiting-in-rails-part-2/</link>
      <pubDate>Sun, 13 Oct 2013 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2013/10/13/implementing-rate-limiting-in-rails-part-2/</guid>
      <description>The first part of this series can be found here.&#xA;The first part of this series looked at how to implement basic rate limiting in a Rails application. However, as pointed out in the improvements section, the implementation was not complete - it did not provide clients enough information about the rate limiting that is in place and how long they should wait before making further requests once they hit the limit.</description>
    </item>
    <item>
      <title>Implementing Rate Limiting in Rails - Part 1</title>
      <link>http://localhost:1313/blog/2013/10/12/implementing-rate-limiting-in-rails-part-1/</link>
      <pubDate>Sat, 12 Oct 2013 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2013/10/12/implementing-rate-limiting-in-rails-part-1/</guid>
      <description>The second part of this series can be found here.&#xA;Rate limiting or throttling is the practice of limiting how frequently legitimate users of a web service can access the service. Rate limiting is often put in place to prevent the hogging of resources by a sub set of the users of the system. Rate limiting works by responding with error messages when a client exceeds their allocated share of requests within a predefined time window.</description>
    </item>
    <item>
      <title>Why your project should have a Getting Started guide.</title>
      <link>http://localhost:1313/blog/2012/01/17/why-your-project-should-have-a-getting-started-guide./</link>
      <pubDate>Tue, 17 Jan 2012 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2012/01/17/why-your-project-should-have-a-getting-started-guide./</guid>
      <description>My new team at work is writing a bunch of Rails applications. This is one of those codebases that one would call &amp;ldquo;legacy&amp;rdquo; without much argument. Most of these apps have their own patched, vendorized Rails versions.&#xA;Getting up and running was an absolute pain. This project existed before Bundler and the list of gem dependencies are not checked in. I got the output of running gem list on a colleague&amp;rsquo;s box, wrote a Ruby script to generate a shell script that installs all the gems.</description>
    </item>
    <item>
      <title>Debugging: C Sharp&#39;s HttpWebRequest, 100-Continue and nginx</title>
      <link>http://localhost:1313/blog/2012/01/16/debugging-c-sharps-httpwebrequest-100-continue-and-nginx/</link>
      <pubDate>Mon, 16 Jan 2012 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2012/01/16/debugging-c-sharps-httpwebrequest-100-continue-and-nginx/</guid>
      <description>Recently I spent some time debugging an issue our team was facing around some C# code making a request on one of our servers. The request was throwing a The server committed a protocol violation. Section=ResponseStatusLine error.&#xA;Initial investigation suggested that this could happen if we are making HTTP/1.1 requests to a server configured for HTTP/1.0. Our Rails application runs on Mongrel fronted with nginx 0.6.5. We modified the C# code to use HTTP/1.</description>
    </item>
  </channel>
</rss>

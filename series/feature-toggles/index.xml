<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Feature-Toggles on {code that works}</title>
    <link>https://sadique.io/series/feature-toggles/?utm_source=site&amp;utm_medium=feed</link>
    <description>Recent content in Feature-Toggles on {code that works}</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 30 Nov 2016 05:50:42 +0000</lastBuildDate>
    <atom:link href="https://sadique.io/series/feature-toggles/?utm_source=site&amp;utm_medium=feed" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Implementing feature toggles for a Spring Boot application - Part 4</title>
      <link>https://sadique.io/blog/2016/11/30/implementing-feature-toggles-for-a-spring-boot-application-part-4/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Wed, 30 Nov 2016 05:50:42 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/30/implementing-feature-toggles-for-a-spring-boot-application-part-4/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In the fourth part of this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt; about implementing &lt;a href=&#34;https://sadique.io/blog/2016/11/21/implementing-feature-toggles-for-a-spring-boot-application-part-1/&#34;&gt;feature toggles&lt;/a&gt; for a Spring Boot application, we will take a look at how our implementation so far introduced a dependency on the application being restarted for changes to take place.&lt;/p&gt;
&lt;p&gt;In &lt;a href=&#34;https://sadique.io/blog/2016/11/21/implementing-feature-toggles-for-a-spring-boot-application-part-1/&#34;&gt;part 1&lt;/a&gt;, we modified the &lt;code&gt;FeatureToggle&lt;/code&gt; annotation to support toggling beans and decided to use that for toggling features at the controller level. If we had a system capable of providing the feature toggle information to the application without restarts, the change in the state of the controller level toggles will have no effect because the controller is not going to be re-wired for request mapping, unless the application is restarted.&lt;/p&gt;
&lt;p&gt;This raises the interesting question - Are bean level switches really feature toggles, considering that they can never be altered without application restarts? A better approach would be to consider bean switches as purely configurations and use facades that route commands to either of the beans based on a feature flag. In the example configuration provided, is treating the choice between storing sessions in-memory / Redis an actual feature, considering it does not provide any value to the end-user?&lt;/p&gt;
&lt;p&gt;To ensure that we are not tying feature toggling to restarts, we will remove the meta-annotation we introduced to &lt;code&gt;FeatureToggle&lt;/code&gt; in &lt;a href=&#34;https://sadique.io/blog/2016/11/21/implementing-feature-toggles-for-a-spring-boot-application-part-1/&#34;&gt;part 1&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FeatureToggle {
  String feature();

  boolean expectedToBeOn() default true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this change, we no longer have the ability to toggle off an entire controller. Having to annotate all handler methods in a controller is going to be a painful, error-prone approach. In order to provide the ability to toggle entire controllers, we can modify the &lt;code&gt;FeatureInterceptor&lt;/code&gt; to look for annotations present on the controller class in addition to annotations present on the handler methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureInterceptor implements HandlerInterceptor {
  private final FeatureRepository featureRepository;

  public FeatureInterceptor(FeatureRepository featureRepository) {
    this.featureRepository = featureRepository;
  }

  @Override
  public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {
    HandlerMethod handlerMethod = (HandlerMethod) handler;
    if (handleMethodAnnotation(handlerMethod) &amp;amp;&amp;amp;
        handleTypeAnnotation(handlerMethod.getBeanType()))  {
      return true;
    }
    httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);
    return false;
  }

  private boolean handleTypeAnnotation(Class&amp;lt;?&amp;gt; controllerType) {
    FeatureToggle controllerTypeAnnotation = controllerType.getAnnotation(FeatureToggle.class);
    return checkFeatureState(controllerTypeAnnotation);
  }

  private boolean handleMethodAnnotation(HandlerMethod handlerMethod) {
    FeatureToggle methodAnnotation = handlerMethod.getMethodAnnotation(FeatureToggle.class);
    return checkFeatureState(methodAnnotation);
  }

  private boolean checkFeatureState(FeatureToggle methodAnnotation) {
    if (methodAnnotation == null) {
      return true;
    }

    if(featureRepository.isOn(methodAnnotation.feature()) == null) {
      return true;
    }

    if(methodAnnotation.expectedToBeOn() == featureRepository.isOn(methodAnnotation.feature())) {
      return true;
    }
    return false;
  }

  @Override
  public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {

  }

  @Override
  public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {

  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will correctly intercept requests routed to handler methods even if the annotation is at the controller level instead of the method level.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/foo&amp;quot;)
@FeatureToggle(feature = &amp;quot;feature.foo&amp;quot;)
public class FooController {
  @RequestMapping(&amp;quot;&amp;quot;)
  public Map hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello foo!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a feature toggling mechanism in place that no longer depends on application restarts, in the next part, we will look at providing this information to the application from a source that does not require restarts.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementing feature toggles for a Spring Boot application - Part 3</title>
      <link>https://sadique.io/blog/2016/11/29/implementing-feature-toggles-for-a-spring-boot-application-part-3/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Tue, 29 Nov 2016 05:50:39 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/29/implementing-feature-toggles-for-a-spring-boot-application-part-3/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In the third part of this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt; about implementing feature toggles for a Spring Boot application, we will take a look at exposing the state of feature flags as a Spring Boot management end point for monitoring and testing purposes.&lt;/p&gt;
&lt;p&gt;Spring Boot Actuator exposes a number of &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html&#34;&gt;end points&lt;/a&gt; to monitor and administer the application. The most commonly used of these in my experience are the &lt;code&gt;info&lt;/code&gt; and &lt;code&gt;health&lt;/code&gt; end points. These end points are used to communicate to load balancers that a particular instance is ready to accept traffic and to monitor the state of the application.&lt;/p&gt;
&lt;h2 id=&#34;features-management-end-point&#34;&gt;Features management end point&lt;/h2&gt;
&lt;p&gt;In our case, this end point will be used by administrators, QA engineers and sometimes business stake holders to see what features are available in a particular environment running the application. Of course, we could have re-used the end point we built in the &lt;a href=&#34;&#34;&gt;last blog post&lt;/a&gt; for this purpose, but creating an management end point allows us to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Control the HTTP end point together with other end points by using the &lt;code&gt;management.context-path&lt;/code&gt; property. This will allow us to provide certain nodes in our network access to only the management end points without having to expose application behavior to them.&lt;/li&gt;
&lt;li&gt;Make this information available in a more human readable form for it’s consumers. Even though the information exposed in the &lt;code&gt;/features&lt;/code&gt; end point is detailed, the format was designed for consumption by code.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Because this is for human consumption, the end point will display the feature state in the following format:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;available&amp;quot;: [
    &amp;quot;feature.hello&amp;quot;,
    &amp;quot;feature.bar&amp;quot;
    ...
  ],
  &amp;quot;enabled&amp;quot;: [
    &amp;quot;feature.hello&amp;quot;
    ...
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Management end points in Spring Boot are created by implementing the &lt;code&gt;EndPoint&lt;/code&gt; interface. In our case, the end point will depend on &lt;code&gt;FeatureRepository&lt;/code&gt; to do the heavy lifting.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureEndpoint implements Endpoint&amp;lt;HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt;&amp;gt; {

  public static final String ID = &amp;quot;features&amp;quot;;
  private final FeatureRepository featureRepository;

  public FeatureEndpoint(FeatureRepository featureRepository) {
    this.featureRepository = featureRepository;
  }

  @Override
  public String getId() {
    return ID;
  }

  @Override
  public boolean isEnabled() {
    return true;
  }

  @Override
  public boolean isSensitive() {
    return false;
  }

  @Override
  public HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; invoke() {
    HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    map.put(&amp;quot;enabled&amp;quot;, featureRepository.enabledKeys());
    map.put(&amp;quot;available&amp;quot;, featureRepository.featureKeys());
    return map;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to retrieve the keys for features that are toggled on, we will create an &lt;code&gt;enabledKeys&lt;/code&gt; method in the repository.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureRepository {
  // ...
  public Set&amp;lt;String&amp;gt; enabledKeys() {
    return featureKeys().stream()
        .filter(f -&amp;gt; isOn(f))
        .collect(Collectors.toSet());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this end point in place and the &lt;code&gt;management.context-path&lt;/code&gt; set to &lt;code&gt;management&lt;/code&gt; in our properties, this end point will produce the following output.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;gt; curl -s &amp;quot;http://localhost:8080/management/features&amp;quot; | jq .
{
  &amp;quot;available&amp;quot;: [
    &amp;quot;feature.foo&amp;quot;,
    &amp;quot;feature.hello&amp;quot;
  ],
  &amp;quot;enabled&amp;quot;: [
    &amp;quot;feature.hello&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to note that our end point has it’s sensitivity flag set to false by default. You should consider the &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#_security_with_healthindicators&#34;&gt;security implications&lt;/a&gt; of that before choosing to leave it false.&lt;/p&gt;
&lt;p&gt;In the next blog post in this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt;, we will explore how our feature toggle mechanism so far have introduced a dependency on the application being restarted and how to eliminate this dependency.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementing feature toggles for a Spring Boot application - Part 2</title>
      <link>https://sadique.io/blog/2016/11/27/implementing-feature-toggles-for-a-spring-boot-application-part-2/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sun, 27 Nov 2016 05:48:48 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/27/implementing-feature-toggles-for-a-spring-boot-application-part-2/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In the second part of this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt; about implementing feature toggles for a Spring Boot application, we will look at exposing the features to the Angular front-end so that features can be toggled in UI components.&lt;/p&gt;
&lt;h2 id=&#34;toggling-at-the-front-end&#34;&gt;Toggling at the front end&lt;/h2&gt;
&lt;p&gt;We decided to use the &lt;a href=&#34;https://github.com/mjt01/angular-feature-flags&#34;&gt;angular-feature-flags&lt;/a&gt; library to toggle features at the front end because it provided us the three features that we were looking for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The ability to load the state of feature flags &lt;a href=&#34;https://github.com/mjt01/angular-feature-flags#setting-flag-data&#34;&gt;from an HTTP end point&lt;/a&gt; instead of having to generate JS code through templates.&lt;/li&gt;
&lt;li&gt;The ability to toggle entire html components through the &lt;code&gt;feature-flag&lt;/code&gt; attribute directive.&lt;/li&gt;
&lt;li&gt;The ability to expose these features to services and components to make if-else decisions through &lt;code&gt;featureFlagsProvider&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;features-end-point&#34;&gt;Features end point&lt;/h2&gt;
&lt;p&gt;The library expects feature flags to be provided to &lt;code&gt;featureFlagsProvider&lt;/code&gt; in the following format:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    { &amp;quot;key&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;active&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;description&amp;quot;: &amp;quot;...&amp;quot; },
    ...
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;FeatureController&lt;/code&gt; will use the &lt;code&gt;FeatureRepository&lt;/code&gt; to expose this will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/features&amp;quot;)
public class FeatureController {
  @Autowired
  FeatureRepository featureRepository;

  @RequestMapping(&amp;quot;&amp;quot;)
  public List&amp;lt;Map&amp;gt; features() {
    return featureRepository.allFeatures()
        .entrySet()
        .stream()
        .map(entry -&amp;gt; new HashMap&amp;lt;String, Object&amp;gt;() {
          {
            put(&amp;quot;key&amp;quot;, entry.getKey());
            put(&amp;quot;active&amp;quot;, entry.getValue());
            put(&amp;quot;name&amp;quot;, entry.getKey());
            put(&amp;quot;description&amp;quot;, entry.getKey());
          }
        })
        .collect(Collectors.toList());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are using the double brace initialization technique to construct the map representing each feature. Initializing a map given a set of keys and values is still an exercise that requires a bunch of &lt;a href=&#34;https://minborgsjavapot.blogspot.com/2014/12/java-8-initializing-maps-in-smartest-way.html&#34;&gt;boiler plate&lt;/a&gt; code in Java. You can get around this by using the convenient ImmutableMap.of() provided by &lt;a href=&#34;https://mvnrepository.com/artifact/com.google.collections/google-collections/1.0&#34;&gt;Google Collections&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It is also important to change our &lt;code&gt;AppConfig&lt;/code&gt; to initialize the instance of &lt;code&gt;Featurerepository&lt;/code&gt; as a bean.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class AppConfig extends WebMvcConfigurerAdapter {
  @Autowired
  Environment env;

  // ...

  @Bean
  public FeatureRepository featureRepository() {
    return new FeatureRepository(env);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this configuration, we can get the feature state from the end point:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; curl -s &amp;quot;http://localhost:8080/features&amp;quot; | jq .
[
  {
    &amp;quot;name&amp;quot;: &amp;quot;feature.foo&amp;quot;,
    &amp;quot;active&amp;quot;: false,
    &amp;quot;description&amp;quot;: &amp;quot;feature.foo&amp;quot;,
    &amp;quot;key&amp;quot;: &amp;quot;feature.foo&amp;quot;
  },
  {
    &amp;quot;name&amp;quot;: &amp;quot;feature.hello&amp;quot;,
    &amp;quot;active&amp;quot;: true,
    &amp;quot;description&amp;quot;: &amp;quot;feature.hello&amp;quot;,
    &amp;quot;key&amp;quot;: &amp;quot;feature.hello&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For our use case, we were comfortable re-using the feature key as the name and description of the feature. You may want to capture these meta data in your application configuration and expose this using Spring Boot’s &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/1.1.7.RELEASE/api/org/springframework/boot/context/properties/ConfigurationProperties.html&#34;&gt;ConfigurationProperties&lt;/a&gt;. You can find an example of how use structured configurations in &lt;a href=&#34;https://github.com/sdqali/config-properties&#34;&gt;my example project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the next part of this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt;, we will take a look at how to expose the feature information as an &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html&#34;&gt;admin end point&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementing feature toggles for a Spring Boot application - Part 1</title>
      <link>https://sadique.io/blog/2016/11/22/implementing-feature-toggles-for-a-spring-boot-application-part-1/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Tue, 22 Nov 2016 01:03:03 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/22/implementing-feature-toggles-for-a-spring-boot-application-part-1/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In one of our recent projects at work, we implemented feature toggles for a Spring MVC / Angular JS code base and this &lt;a href=&#34;https://sadique.io/series/feature-toggles&#34;&gt;series of blog posts&lt;/a&gt; discusses our motivations and requirements, the approach we took and what we learned from it.&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Feature Toggles are a mechanism to change the behavior of software without having to re-deploy code. Pete Hogdson has a comprehensive &lt;a href=&#34;http://martinfowler.com/articles/feature-toggles.html&#34;&gt;blog post&lt;/a&gt; explaining the complexities of feature toggles.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sadique.io/images/feature-toggles.svg&#34; alt=&#34;Feature toggles&#34; title=&#34;Feature toggles&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;requirements&#34;&gt;Requirements&lt;/h2&gt;
&lt;p&gt;Our application is a Spring Boot web application that gets deployed in a Tomcat instance. The application is deployed via Chef and chef sets up the appropriate configuration parameters for the application as Tomcat &lt;a href=&#34;https://tomcat.apache.org/tomcat-8.0-doc/config/context.html#Environment_Entries&#34;&gt;Environment&lt;/a&gt; entries. Since feature toggles are ultimately application parameters &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, we started by setting them as Tomcat environment variables. Having considered this, we identified the following requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The ability to toggle dependency injection. For example, in some environments, we wanted to use Redis to store our sessions, while in some test environments, they were to be stored in memory.&lt;/li&gt;
&lt;li&gt;Ability to toggle entire Spring Controllers or individual controller methods.&lt;/li&gt;
&lt;li&gt;The ability to expose the state of feature toggles to our front end so that Angular JS components can use the feature toggles.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;our-initial-approach&#34;&gt;Our initial approach&lt;/h2&gt;
&lt;h3 id=&#34;toggling-dependency-injection&#34;&gt;Toggling dependency injection.&lt;/h3&gt;
&lt;p&gt;We started by using configuration parameters with the &lt;code&gt;feature&lt;/code&gt; prefix to toggle features. With this convention in place, we started using the &lt;code&gt;@ConditionalOnProperty&lt;/code&gt; annotation in our configuration classes to toggle the beans that got wired up. For example, to toggle between Redis and in-memory store for sessions, we ended up with the following configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class AppConfig {
  @Bean
  @ConditionalOnProperty(value = &amp;quot;feature.redis.session.store&amp;quot;, havingValue = &amp;quot;false&amp;quot;)
  public SessionRepository mapSessionRepository() {
    return new MapSessionRepository();
  }

  @Bean
  @ConditionalOnProperty(value = &amp;quot;feature.redis.session.store&amp;quot;, havingValue = &amp;quot;true&amp;quot;)
  public SessionRepository redisSessionRepository(RedisConnectionFactory factory) {
    return new RedisOperationsSessionRepository(factory);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;toggling-individual-controller-methods&#34;&gt;Toggling individual controller methods&lt;/h3&gt;
&lt;p&gt;In order to prevent end points defined by controllers and controller methods that are toggled off from being accessed, we decided to configure a &lt;code&gt;HandlerInterceptor&lt;/code&gt; &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; to intercept requests to these end points.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureInterceptor implements HandlerInterceptor {
  private final FeatureRepository featureRepository;

  public FeatureInterceptor(FeatureRepository featureRepository) {
    this.featureRepository = featureRepository;
  }

  @Override
  public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {
    HandlerMethod handlerMethod = (HandlerMethod) handler;
    FeatureToggle methodAnnotation = handlerMethod.getMethodAnnotation(FeatureToggle.class);
    if (methodAnnotation == null) {
      return true;
    }

    if(featureRepository.isOn(methodAnnotation.feature()) == null) {
      return true;
    }

    if(methodAnnotation.expectedToBeOn() == featureRepository.isOn(methodAnnotation.feature())) {
      return true;
    }

    httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);
    return false;
  }

  @Override
  public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {

  }

  @Override
  public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {

  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This feature interceptor uses the &lt;code&gt;FeatureToggle&lt;/code&gt; looks for the annotation, and the looks at a feature repository to see if the state of the feature flag is set to what the annotation expects and if it does not, returns a 404. The annotation has two attributes - &lt;code&gt;isOn&lt;/code&gt; and &lt;code&gt;feature&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FeatureToggle {
  String feature();

  boolean expectedToBeOn() default true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This annotation can be used on a controller method as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/hello&amp;quot;)
public class MessageController {
  @RequestMapping(&amp;quot;&amp;quot;)
  @FeatureToggle(feature = &amp;quot;feature.hello&amp;quot;)
  public Map hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello world!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;FeatureRepository&lt;/code&gt; has to look at all the properties that are available in the applications environment and filter out the ones that start with &lt;code&gt;feature.&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Collecting all the properties available in an environment is &lt;a href=&#34;https://stackoverflow.com/questions/23506471/spring-access-all-environment-properties-as-a-map-or-properties-object&#34;&gt;surprisingly complex&lt;/a&gt;, owing to the number of ways properties can be injected. Based on the approach discussed in that question, we can create a &lt;code&gt;FeatureRepository&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureRepository {
  private static final String FEATURE_PREFIX = &amp;quot;feature.&amp;quot;;
  private final Environment env;

  public FeatureRepository(Environment env) {
    this.env = env;
  }

  public Set&amp;lt;String&amp;gt; featureKeys() {
    Map&amp;lt;String, Object&amp;gt; map = new HashMap();
    for(Iterator it = ((AbstractEnvironment) env).getPropertySources().iterator(); it.hasNext(); ) {
      PropertySource propertySource = (PropertySource) it.next();
      if (propertySource instanceof MapPropertySource) {
        map.putAll(((MapPropertySource) propertySource).getSource());
      }
    }
    return map.keySet().stream()
        .filter(k -&amp;gt; k.startsWith(FEATURE_PREFIX))
        .collect(Collectors.toSet());
  }

  public Boolean isOn(String key) {
    return allFeatures().get(key);
  }

  public Map&amp;lt;String, Boolean&amp;gt; allFeatures() {
    return featureKeys().stream().collect(Collectors.toMap(k -&amp;gt; k, k -&amp;gt; Boolean.parseBoolean(env.getProperty(k))));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;toggling-entire-controllers&#34;&gt;Toggling entire controllers&lt;/h3&gt;
&lt;p&gt;Since Spring controllers are wired up as beans, the &lt;code&gt;ConditionalOnProperty&lt;/code&gt; annotation can be used to toggle on entire controllers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/foo&amp;quot;)
@ConditionalOnProperty(value = &amp;quot;feature.foo&amp;quot;, havingValue = &amp;quot;true&amp;quot;)
public class FooController {
  @RequestMapping(&amp;quot;&amp;quot;)
  public Map hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello foo!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, now we have two different mechanisms to toggle methods and controllers. It will be nice to consolidate them and doing so will allow us to use the same mechanism for toggling beans. This can be done by annotating &lt;code&gt;FeatureToggle&lt;/code&gt; with the &lt;a href=&#34;https://sadique.io/blog/2015/12/06/implementing-custom-annotations-for-spring-mvc/&#34;&gt;meta annotation&lt;/a&gt; &lt;code&gt;Conditional&lt;/code&gt; that looks up the state of feature toggles using the custom condition &lt;code&gt;FeatureCondition&lt;/code&gt;. This will change &lt;code&gt;FeatureToggle&lt;/code&gt; to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(FeatureCondition.class)
public @interface FeatureToggle {
  String feature();

  boolean expectedToBeOn() default true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;FeatureCondition&lt;/code&gt; uses the meta annotation attributes provided to it and the environment to decide the state to be returned:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureCondition implements Condition {
  @Override
  public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
    if(annotatedTypeMetadata.isAnnotated(FeatureToggle.class.getCanonicalName())) {
      Map&amp;lt;String, Object&amp;gt; annotationAttributes = annotatedTypeMetadata
          .getAnnotationAttributes(FeatureToggle.class.getCanonicalName());
      String feature = (String) annotationAttributes.get(&amp;quot;feature&amp;quot;);
      boolean expectedToBeOn = Boolean.parseBoolean(String.valueOf(annotationAttributes.get(&amp;quot;expectedToBeOn&amp;quot;)));
      boolean isOn = Boolean.parseBoolean(conditionContext.getEnvironment().getProperty(feature));
      return expectedToBeOn == isOn;
    }
    return true;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a unified mechanism to toggle controllers, beans and controller methods, we can use this annotation. The &lt;code&gt;FooController&lt;/code&gt; would now look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/foo&amp;quot;)
@FeatureToggle(feature = &amp;quot;feature.foo&amp;quot;)
public class FooController {
  @RequestMapping(&amp;quot;&amp;quot;)
  public Map hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello foo!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And our &lt;code&gt;AppConfig&lt;/code&gt; will be like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class AppConfig extends WebMvcConfigurerAdapter {
  @Autowired
  Environment env;

  @Bean
  @FeatureToggle(feature = &amp;quot;feature.redis.session.store&amp;quot;, expectedToBeOn = false)
  public SessionRepository mapSessionRepository() {
    return new MapSessionRepository();
  }

  @Bean
  @FeatureToggle(feature = &amp;quot;feature.redis.session.store&amp;quot;)
  public SessionRepository redisSessionRepository(RedisConnectionFactory factory) {
    return new RedisOperationsSessionRepository(factory);
  }

  @Override
  public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new FeatureInterceptor(new FeatureRepository(env)));
    super.addInterceptors(registry);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the second part of &lt;a href=&#34;https://sadique.io/series/feature-toggles&#34;&gt;this series&lt;/a&gt;, we will explore how the feature toggle can be exposed to the front end and how to consume this and use it for toggling features in the Angular components.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;While feature toggles are just like any other application parameter, treating them as such in our stack resulted in errors, which we address later in this series.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;HandlerInterceptor&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on {code that works}</title>
    <link>https://sadique.io/tags/development/?utm_source=site&amp;utm_medium=feed</link>
    <description>Recent content in Development on {code that works}</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 23 Mar 2019 19:46:08 +0000</lastBuildDate>
    <atom:link href="https://sadique.io/tags/development/?utm_source=site&amp;utm_medium=feed" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Understanding trailing @ processing in SAS input</title>
      <link>https://sadique.io/blog/2019/03/23/understanding-trailing-@-processing-in-sas-input/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sat, 23 Mar 2019 19:46:08 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2019/03/23/understanding-trailing-@-processing-in-sas-input/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;One of the first things I noticed when I started poking around in SAS code is that the &lt;code&gt;input&lt;/code&gt; statement is very powerful, flexible and hence sometimes hard to understand. It can read pretty much anything in to a dataset as long as you tell it what to do.&lt;/p&gt;
&lt;p&gt;The use of trailing &lt;code&gt;@&lt;/code&gt;s to take control of how SAS advances the input pointer is a powerful technique to read from input files where the data is laid out in non-standard formats. In this blog post, we will try to understand how trailing &lt;code&gt;@&lt;/code&gt; processing works with the help of some &lt;code&gt;infile&lt;/code&gt; statement options and the &lt;code&gt;putlog&lt;/code&gt; statement to write to the SAS log.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take this example from the excellent paper &lt;em&gt;The Input Statement: Where It&amp;rsquo;s @&lt;/em&gt; &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; - given an put file where the first variable has to be read beginning from a particular column in the input line based on the value of the second variable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt;Age  Type
23   1
  44 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A first pass at trying to do this will result in code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt;data ages;
  input @6 type $1.;

  if type=&#39;1&#39; then
    input @1 age 2.;
  else if type=&#39;2&#39; then
    input @3 age 2.;
  drop type;
  datalines;
23   1
  44 2
;
run;

proc print data=ages;
  title &amp;quot;Age read without trailing @&amp;quot;;
run;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result we get is not what we expect.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt;| Obs | Age |
|-----|-----|
| 1   | .   |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can understand how SAS read this input using the &lt;code&gt;line=&lt;/code&gt; and &lt;code&gt;column=&lt;/code&gt; options of the &lt;code&gt;infile&lt;/code&gt; statement. While the code in the above listing does not explicitly use &lt;code&gt;infile&lt;/code&gt; to point at the &lt;code&gt;datalines&lt;/code&gt;, this can be done when we want to use &lt;code&gt;infile&lt;/code&gt;&amp;rsquo;s options with &lt;code&gt;datalines&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is a good time to remind us what the &lt;code&gt;line=&lt;/code&gt; and &lt;code&gt;column=&lt;/code&gt; options of &lt;code&gt;infile&lt;/code&gt; does. From the &lt;a href=&#34;https://documentation.sas.com/?docsetId=lestmtsref&amp;amp;docsetTarget=n1rill4udj0tfun1fvce3j401plo.htm&amp;amp;docsetVersion=9.4&amp;amp;locale=en&#34;&gt;documentation&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LINE=variable&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;specifies a variable that SAS sets to the line location of the input pointer in the input buffer. As with automatic variables, the LINE= variable is not written to the data set.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;COLUMN=variable&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;names a variable that SAS uses to assign the current column location of the input pointer. As with automatic variables, the COLUMN= variable is not written to the data set.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We can modify our code to set these options and then print the value of all variables including these options using the &lt;code&gt;_all_&lt;/code&gt; variable that prints the &lt;em&gt;Program Data Vector (PDV)&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt;data ages;
  infile datalines line=line column=col;

  input @6 type $1.;
  putlog &amp;quot;After reading type, before reading age: &amp;quot; _all_ ;

  if type=&#39;1&#39; then
    input @1 age 2.;
  else if type=&#39;2&#39; then
    input @3 age 2.;
  putlog &amp;quot;After reading age: &amp;quot; _all_ ;
  putlog &amp;quot;&amp;quot;;

  drop type;
  datalines;
23   1
  44 2
;
run;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the code runs, the following can be seen in the SAS logs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt; After reading type, before reading age: line=1 col=7 type=1 age=. _ERROR_=0 _N_=1
 After reading age: line=2 col=3 type=1 age=. _ERROR_=0 _N_=1
 &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After &lt;code&gt;type&lt;/code&gt; is read, we can see that the pointer is at line &lt;code&gt;1&lt;/code&gt; and column &lt;code&gt;7&lt;/code&gt;, which makes sense considering that the code instructs SAS to go to column &lt;code&gt;6&lt;/code&gt; and read &lt;code&gt;1&lt;/code&gt; character. But then we notice that when &lt;code&gt;age&lt;/code&gt; is read, the pointer has moved to &lt;code&gt;2&lt;/code&gt; and column &lt;code&gt;3&lt;/code&gt; as instructed in the first branch of the &lt;code&gt;if else&lt;/code&gt; condition. Since there is nothing at column &lt;code&gt;1-2&lt;/code&gt; of line &lt;code&gt;2&lt;/code&gt; in the input, a missing value is stored in &lt;code&gt;age&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What we want is some way to tell &lt;code&gt;input&lt;/code&gt; to ot move the pointer after the first input statement. This is where the single trailing &lt;code&gt;@&lt;/code&gt; comes in. It intructs &lt;code&gt;input&lt;/code&gt; to stay on the same line for the next &lt;code&gt;input&lt;/code&gt; statement in the &lt;code&gt;data&lt;/code&gt; step. The above listing modified to use trailing &lt;code&gt;@&lt;/code&gt; is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt;data trailing;
  infile datalines line=line column=col;

  input @6 type $1. @;
  putlog &amp;quot;After reading type, before reading age: &amp;quot; _all_ ;

  if type=&#39;1&#39; then
    input @1 age 2.;
  else if type=&#39;2&#39; then
    input @3 age 2.;
  putlog &amp;quot;After reading age: &amp;quot; _all_ ;
  putlog &amp;quot;&amp;quot;;

  drop type;
  datalines;
23   1
  44 2
;
run;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following log lines are written:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt; After reading type, before reading age: line=1 col=7 type=1 age=. _ERROR_=0 _N_=1
 After reading age: line=1 col=3 type=1 age=23 _ERROR_=0 _N_=1
 &amp;quot;
 After reading type, before reading age: line=1 col=7 type=2 age=. _ERROR_=0 _N_=2
 After reading age: line=1 col=5 type=2 age=44 _ERROR_=0 _N_=2
 &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The log shows that &lt;code&gt;input&lt;/code&gt; stayed on line &lt;code&gt;1&lt;/code&gt; even after reading the &lt;code&gt;type&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;The new dataset has the expected values:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt;| Obs | Age |
|-----|-----|
| 1   | 23  |
| 2   | 44  |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is another example that you often run in to on the internet when discussing trailing &lt;code&gt;@&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt;data  colors;
  infile datalines line=linenum column=col;
  input @1 Var1 $ @8 Var2 $ @;
  putlog &amp;quot;After reading Var1 and Var2: &amp;quot; _all_;

  input @1 Var3 $ @8 Var4 $ ;
  putlog &amp;quot;After reading Var3 and Var4: &amp;quot; _all_;
  putlog &amp;quot;&amp;quot;;

  datalines;
RED    ORANGE  YELLOW  GREEN
BLUE   INDIGO  PURPLE  VIOLET
CYAN   WHITE   FUCSIA  BLACK
GRAY   BROWN   PINK    MAGENTA
;
run;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This results in the following dataset:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt;|Obs  | Var1 | Var2   | Var3 | Var4   |
|-----|------|--------|------|--------|
| 1   | RED  | ORANGE | RED  | ORANGE |
| 2   | BLUE | INDIGO | BLUE | INDIGO |
| 3   | CYAN | WHITE  | CYAN | WHITE  |
| 4   | GRAY | BROWN  | GRAY | BROWN  |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because of the trailing &lt;code&gt;@&lt;/code&gt; in the first &lt;code&gt;input&lt;/code&gt; statement, the values of &lt;code&gt;Var1&lt;/code&gt; and &lt;code&gt;Var3&lt;/code&gt; for all the observations are the same, as both are read from column &lt;code&gt;1&lt;/code&gt;. Similarly &lt;code&gt;Var2&lt;/code&gt; and &lt;code&gt;Var4&lt;/code&gt; are the same as they are read from column &lt;code&gt;8&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;The Input Statement: Where It&amp;rsquo;s @. Paper 253-29, SUGI 29 Proceedings.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Importing the SASUSER datasets in SAS Studio</title>
      <link>https://sadique.io/blog/2019/03/23/importing-the-sasuser-datasets-in-sas-studio/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sat, 23 Mar 2019 18:14:06 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2019/03/23/importing-the-sasuser-datasets-in-sas-studio/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;I have been playing around with SAS for the last two weeks. I started with a SAS University Edition running on a VirtualBox instance on my MacBook, but soon realized that it was way more convenient to use a SAS OnDemand account. Having made the switch, I realized that all learning materials made references to and used examples with datsets from a library named &lt;code&gt;SASUSER&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It was not clear how to get these datasets and use them in SAS Studio. After a bunch of searches, I found &lt;a href=&#34;https://communities.sas.com/t5/SAS-Certification/How-to-get-SASUSER-library-s-data-sets/m-p/306631/highlight/true#M124&#34;&gt;this page&lt;/a&gt; that pointed at data set up scripts for these datasets. The URL it pointed to had of course been repurposed and now redirected to a marketing page. After going back through multiple versions of the page on Internet Archive, I finally managed to find a &lt;a href=&#34;https://web.archive.org/web/20151005165134/http://support.sas.com:80/publishing/cert/basecertguide3.html&#34;&gt;snapshot&lt;/a&gt; that linked to a set up file that worked.&lt;/p&gt;
&lt;p&gt;Here are the steps to use the setup script:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Download the &lt;a href=&#34;https://support.sas.com/content/dam/SAS/support/en/books/data/sampledata.txt&#34;&gt;script&lt;/a&gt;. Depending on the version of the material you are using, you may want to grab an &lt;a href=&#34;https://web.archive.org/web/20150921023746/http://support.sas.com/publishing/cert/sampdata.txt&#34;&gt;older snapshot&lt;/a&gt; from the Internet Archive.&lt;/li&gt;
&lt;li&gt;Rename the file so that it&amp;rsquo;s extension is changed to &lt;code&gt;.sas&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Create a directory under your home directory in SAS Studio, for example &lt;code&gt;sasuser&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Upload the sample data script from step 1 to this folder, using the web interface.&lt;/li&gt;
&lt;li&gt;Create a new SAS source file named &lt;code&gt;libname.sas&lt;/code&gt; with the following content:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt;libname sasuser &amp;quot;~/sasuser&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Execute this script.&lt;/li&gt;
&lt;li&gt;Now execute the sample data script.&lt;/li&gt;
&lt;li&gt;It should create all the datsets you need in the library named &lt;code&gt;sasuser&lt;/code&gt;. You can verify this using the following script:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt;proc contents data=sasuser._all_ nods;
run;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Implementing feature toggles for a Spring Boot application - Part 4</title>
      <link>https://sadique.io/blog/2016/11/30/implementing-feature-toggles-for-a-spring-boot-application-part-4/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Wed, 30 Nov 2016 05:50:42 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/30/implementing-feature-toggles-for-a-spring-boot-application-part-4/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In the fourth part of this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt; about implementing &lt;a href=&#34;https://sadique.io/blog/2016/11/21/implementing-feature-toggles-for-a-spring-boot-application-part-1/&#34;&gt;feature toggles&lt;/a&gt; for a Spring Boot application, we will take a look at how our implementation so far introduced a dependency on the application being restarted for changes to take place.&lt;/p&gt;
&lt;p&gt;In &lt;a href=&#34;https://sadique.io/blog/2016/11/21/implementing-feature-toggles-for-a-spring-boot-application-part-1/&#34;&gt;part 1&lt;/a&gt;, we modified the &lt;code&gt;FeatureToggle&lt;/code&gt; annotation to support toggling beans and decided to use that for toggling features at the controller level. If we had a system capable of providing the feature toggle information to the application without restarts, the change in the state of the controller level toggles will have no effect because the controller is not going to be re-wired for request mapping, unless the application is restarted.&lt;/p&gt;
&lt;p&gt;This raises the interesting question - Are bean level switches really feature toggles, considering that they can never be altered without application restarts? A better approach would be to consider bean switches as purely configurations and use facades that route commands to either of the beans based on a feature flag. In the example configuration provided, is treating the choice between storing sessions in-memory / Redis an actual feature, considering it does not provide any value to the end-user?&lt;/p&gt;
&lt;p&gt;To ensure that we are not tying feature toggling to restarts, we will remove the meta-annotation we introduced to &lt;code&gt;FeatureToggle&lt;/code&gt; in &lt;a href=&#34;https://sadique.io/blog/2016/11/21/implementing-feature-toggles-for-a-spring-boot-application-part-1/&#34;&gt;part 1&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FeatureToggle {
  String feature();

  boolean expectedToBeOn() default true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this change, we no longer have the ability to toggle off an entire controller. Having to annotate all handler methods in a controller is going to be a painful, error-prone approach. In order to provide the ability to toggle entire controllers, we can modify the &lt;code&gt;FeatureInterceptor&lt;/code&gt; to look for annotations present on the controller class in addition to annotations present on the handler methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureInterceptor implements HandlerInterceptor {
  private final FeatureRepository featureRepository;

  public FeatureInterceptor(FeatureRepository featureRepository) {
    this.featureRepository = featureRepository;
  }

  @Override
  public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {
    HandlerMethod handlerMethod = (HandlerMethod) handler;
    if (handleMethodAnnotation(handlerMethod) &amp;amp;&amp;amp;
        handleTypeAnnotation(handlerMethod.getBeanType()))  {
      return true;
    }
    httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);
    return false;
  }

  private boolean handleTypeAnnotation(Class&amp;lt;?&amp;gt; controllerType) {
    FeatureToggle controllerTypeAnnotation = controllerType.getAnnotation(FeatureToggle.class);
    return checkFeatureState(controllerTypeAnnotation);
  }

  private boolean handleMethodAnnotation(HandlerMethod handlerMethod) {
    FeatureToggle methodAnnotation = handlerMethod.getMethodAnnotation(FeatureToggle.class);
    return checkFeatureState(methodAnnotation);
  }

  private boolean checkFeatureState(FeatureToggle methodAnnotation) {
    if (methodAnnotation == null) {
      return true;
    }

    if(featureRepository.isOn(methodAnnotation.feature()) == null) {
      return true;
    }

    if(methodAnnotation.expectedToBeOn() == featureRepository.isOn(methodAnnotation.feature())) {
      return true;
    }
    return false;
  }

  @Override
  public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {

  }

  @Override
  public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {

  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will correctly intercept requests routed to handler methods even if the annotation is at the controller level instead of the method level.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/foo&amp;quot;)
@FeatureToggle(feature = &amp;quot;feature.foo&amp;quot;)
public class FooController {
  @RequestMapping(&amp;quot;&amp;quot;)
  public Map hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello foo!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a feature toggling mechanism in place that no longer depends on application restarts, in the next part, we will look at providing this information to the application from a source that does not require restarts.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementing feature toggles for a Spring Boot application - Part 3</title>
      <link>https://sadique.io/blog/2016/11/29/implementing-feature-toggles-for-a-spring-boot-application-part-3/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Tue, 29 Nov 2016 05:50:39 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/29/implementing-feature-toggles-for-a-spring-boot-application-part-3/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In the third part of this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt; about implementing feature toggles for a Spring Boot application, we will take a look at exposing the state of feature flags as a Spring Boot management end point for monitoring and testing purposes.&lt;/p&gt;
&lt;p&gt;Spring Boot Actuator exposes a number of &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html&#34;&gt;end points&lt;/a&gt; to monitor and administer the application. The most commonly used of these in my experience are the &lt;code&gt;info&lt;/code&gt; and &lt;code&gt;health&lt;/code&gt; end points. These end points are used to communicate to load balancers that a particular instance is ready to accept traffic and to monitor the state of the application.&lt;/p&gt;
&lt;h2 id=&#34;features-management-end-point&#34;&gt;Features management end point&lt;/h2&gt;
&lt;p&gt;In our case, this end point will be used by administrators, QA engineers and sometimes business stake holders to see what features are available in a particular environment running the application. Of course, we could have re-used the end point we built in the &lt;a href=&#34;&#34;&gt;last blog post&lt;/a&gt; for this purpose, but creating an management end point allows us to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Control the HTTP end point together with other end points by using the &lt;code&gt;management.context-path&lt;/code&gt; property. This will allow us to provide certain nodes in our network access to only the management end points without having to expose application behavior to them.&lt;/li&gt;
&lt;li&gt;Make this information available in a more human readable form for it’s consumers. Even though the information exposed in the &lt;code&gt;/features&lt;/code&gt; end point is detailed, the format was designed for consumption by code.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Because this is for human consumption, the end point will display the feature state in the following format:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;available&amp;quot;: [
    &amp;quot;feature.hello&amp;quot;,
    &amp;quot;feature.bar&amp;quot;
    ...
  ],
  &amp;quot;enabled&amp;quot;: [
    &amp;quot;feature.hello&amp;quot;
    ...
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Management end points in Spring Boot are created by implementing the &lt;code&gt;EndPoint&lt;/code&gt; interface. In our case, the end point will depend on &lt;code&gt;FeatureRepository&lt;/code&gt; to do the heavy lifting.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureEndpoint implements Endpoint&amp;lt;HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt;&amp;gt; {

  public static final String ID = &amp;quot;features&amp;quot;;
  private final FeatureRepository featureRepository;

  public FeatureEndpoint(FeatureRepository featureRepository) {
    this.featureRepository = featureRepository;
  }

  @Override
  public String getId() {
    return ID;
  }

  @Override
  public boolean isEnabled() {
    return true;
  }

  @Override
  public boolean isSensitive() {
    return false;
  }

  @Override
  public HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; invoke() {
    HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    map.put(&amp;quot;enabled&amp;quot;, featureRepository.enabledKeys());
    map.put(&amp;quot;available&amp;quot;, featureRepository.featureKeys());
    return map;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to retrieve the keys for features that are toggled on, we will create an &lt;code&gt;enabledKeys&lt;/code&gt; method in the repository.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureRepository {
  // ...
  public Set&amp;lt;String&amp;gt; enabledKeys() {
    return featureKeys().stream()
        .filter(f -&amp;gt; isOn(f))
        .collect(Collectors.toSet());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this end point in place and the &lt;code&gt;management.context-path&lt;/code&gt; set to &lt;code&gt;management&lt;/code&gt; in our properties, this end point will produce the following output.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;gt; curl -s &amp;quot;http://localhost:8080/management/features&amp;quot; | jq .
{
  &amp;quot;available&amp;quot;: [
    &amp;quot;feature.foo&amp;quot;,
    &amp;quot;feature.hello&amp;quot;
  ],
  &amp;quot;enabled&amp;quot;: [
    &amp;quot;feature.hello&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to note that our end point has it’s sensitivity flag set to false by default. You should consider the &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#_security_with_healthindicators&#34;&gt;security implications&lt;/a&gt; of that before choosing to leave it false.&lt;/p&gt;
&lt;p&gt;In the next blog post in this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt;, we will explore how our feature toggle mechanism so far have introduced a dependency on the application being restarted and how to eliminate this dependency.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementing feature toggles for a Spring Boot application - Part 2</title>
      <link>https://sadique.io/blog/2016/11/27/implementing-feature-toggles-for-a-spring-boot-application-part-2/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sun, 27 Nov 2016 05:48:48 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/27/implementing-feature-toggles-for-a-spring-boot-application-part-2/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In the second part of this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt; about implementing feature toggles for a Spring Boot application, we will look at exposing the features to the Angular front-end so that features can be toggled in UI components.&lt;/p&gt;
&lt;h2 id=&#34;toggling-at-the-front-end&#34;&gt;Toggling at the front end&lt;/h2&gt;
&lt;p&gt;We decided to use the &lt;a href=&#34;https://github.com/mjt01/angular-feature-flags&#34;&gt;angular-feature-flags&lt;/a&gt; library to toggle features at the front end because it provided us the three features that we were looking for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The ability to load the state of feature flags &lt;a href=&#34;https://github.com/mjt01/angular-feature-flags#setting-flag-data&#34;&gt;from an HTTP end point&lt;/a&gt; instead of having to generate JS code through templates.&lt;/li&gt;
&lt;li&gt;The ability to toggle entire html components through the &lt;code&gt;feature-flag&lt;/code&gt; attribute directive.&lt;/li&gt;
&lt;li&gt;The ability to expose these features to services and components to make if-else decisions through &lt;code&gt;featureFlagsProvider&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;features-end-point&#34;&gt;Features end point&lt;/h2&gt;
&lt;p&gt;The library expects feature flags to be provided to &lt;code&gt;featureFlagsProvider&lt;/code&gt; in the following format:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    { &amp;quot;key&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;active&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;description&amp;quot;: &amp;quot;...&amp;quot; },
    ...
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;FeatureController&lt;/code&gt; will use the &lt;code&gt;FeatureRepository&lt;/code&gt; to expose this will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/features&amp;quot;)
public class FeatureController {
  @Autowired
  FeatureRepository featureRepository;

  @RequestMapping(&amp;quot;&amp;quot;)
  public List&amp;lt;Map&amp;gt; features() {
    return featureRepository.allFeatures()
        .entrySet()
        .stream()
        .map(entry -&amp;gt; new HashMap&amp;lt;String, Object&amp;gt;() {
          {
            put(&amp;quot;key&amp;quot;, entry.getKey());
            put(&amp;quot;active&amp;quot;, entry.getValue());
            put(&amp;quot;name&amp;quot;, entry.getKey());
            put(&amp;quot;description&amp;quot;, entry.getKey());
          }
        })
        .collect(Collectors.toList());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are using the double brace initialization technique to construct the map representing each feature. Initializing a map given a set of keys and values is still an exercise that requires a bunch of &lt;a href=&#34;https://minborgsjavapot.blogspot.com/2014/12/java-8-initializing-maps-in-smartest-way.html&#34;&gt;boiler plate&lt;/a&gt; code in Java. You can get around this by using the convenient ImmutableMap.of() provided by &lt;a href=&#34;https://mvnrepository.com/artifact/com.google.collections/google-collections/1.0&#34;&gt;Google Collections&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It is also important to change our &lt;code&gt;AppConfig&lt;/code&gt; to initialize the instance of &lt;code&gt;Featurerepository&lt;/code&gt; as a bean.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class AppConfig extends WebMvcConfigurerAdapter {
  @Autowired
  Environment env;

  // ...

  @Bean
  public FeatureRepository featureRepository() {
    return new FeatureRepository(env);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this configuration, we can get the feature state from the end point:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; curl -s &amp;quot;http://localhost:8080/features&amp;quot; | jq .
[
  {
    &amp;quot;name&amp;quot;: &amp;quot;feature.foo&amp;quot;,
    &amp;quot;active&amp;quot;: false,
    &amp;quot;description&amp;quot;: &amp;quot;feature.foo&amp;quot;,
    &amp;quot;key&amp;quot;: &amp;quot;feature.foo&amp;quot;
  },
  {
    &amp;quot;name&amp;quot;: &amp;quot;feature.hello&amp;quot;,
    &amp;quot;active&amp;quot;: true,
    &amp;quot;description&amp;quot;: &amp;quot;feature.hello&amp;quot;,
    &amp;quot;key&amp;quot;: &amp;quot;feature.hello&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For our use case, we were comfortable re-using the feature key as the name and description of the feature. You may want to capture these meta data in your application configuration and expose this using Spring Boot’s &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/1.1.7.RELEASE/api/org/springframework/boot/context/properties/ConfigurationProperties.html&#34;&gt;ConfigurationProperties&lt;/a&gt;. You can find an example of how use structured configurations in &lt;a href=&#34;https://github.com/sdqali/config-properties&#34;&gt;my example project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the next part of this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt;, we will take a look at how to expose the feature information as an &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html&#34;&gt;admin end point&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementing feature toggles for a Spring Boot application - Part 1</title>
      <link>https://sadique.io/blog/2016/11/22/implementing-feature-toggles-for-a-spring-boot-application-part-1/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Tue, 22 Nov 2016 01:03:03 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/22/implementing-feature-toggles-for-a-spring-boot-application-part-1/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In one of our recent projects at work, we implemented feature toggles for a Spring MVC / Angular JS code base and this &lt;a href=&#34;https://sadique.io/series/feature-toggles&#34;&gt;series of blog posts&lt;/a&gt; discusses our motivations and requirements, the approach we took and what we learned from it.&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Feature Toggles are a mechanism to change the behavior of software without having to re-deploy code. Pete Hogdson has a comprehensive &lt;a href=&#34;http://martinfowler.com/articles/feature-toggles.html&#34;&gt;blog post&lt;/a&gt; explaining the complexities of feature toggles.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sadique.io/images/feature-toggles.svg&#34; alt=&#34;Feature toggles&#34; title=&#34;Feature toggles&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;requirements&#34;&gt;Requirements&lt;/h2&gt;
&lt;p&gt;Our application is a Spring Boot web application that gets deployed in a Tomcat instance. The application is deployed via Chef and chef sets up the appropriate configuration parameters for the application as Tomcat &lt;a href=&#34;https://tomcat.apache.org/tomcat-8.0-doc/config/context.html#Environment_Entries&#34;&gt;Environment&lt;/a&gt; entries. Since feature toggles are ultimately application parameters &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, we started by setting them as Tomcat environment variables. Having considered this, we identified the following requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The ability to toggle dependency injection. For example, in some environments, we wanted to use Redis to store our sessions, while in some test environments, they were to be stored in memory.&lt;/li&gt;
&lt;li&gt;Ability to toggle entire Spring Controllers or individual controller methods.&lt;/li&gt;
&lt;li&gt;The ability to expose the state of feature toggles to our front end so that Angular JS components can use the feature toggles.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;our-initial-approach&#34;&gt;Our initial approach&lt;/h2&gt;
&lt;h3 id=&#34;toggling-dependency-injection&#34;&gt;Toggling dependency injection.&lt;/h3&gt;
&lt;p&gt;We started by using configuration parameters with the &lt;code&gt;feature&lt;/code&gt; prefix to toggle features. With this convention in place, we started using the &lt;code&gt;@ConditionalOnProperty&lt;/code&gt; annotation in our configuration classes to toggle the beans that got wired up. For example, to toggle between Redis and in-memory store for sessions, we ended up with the following configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class AppConfig {
  @Bean
  @ConditionalOnProperty(value = &amp;quot;feature.redis.session.store&amp;quot;, havingValue = &amp;quot;false&amp;quot;)
  public SessionRepository mapSessionRepository() {
    return new MapSessionRepository();
  }

  @Bean
  @ConditionalOnProperty(value = &amp;quot;feature.redis.session.store&amp;quot;, havingValue = &amp;quot;true&amp;quot;)
  public SessionRepository redisSessionRepository(RedisConnectionFactory factory) {
    return new RedisOperationsSessionRepository(factory);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;toggling-individual-controller-methods&#34;&gt;Toggling individual controller methods&lt;/h3&gt;
&lt;p&gt;In order to prevent end points defined by controllers and controller methods that are toggled off from being accessed, we decided to configure a &lt;code&gt;HandlerInterceptor&lt;/code&gt; &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; to intercept requests to these end points.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureInterceptor implements HandlerInterceptor {
  private final FeatureRepository featureRepository;

  public FeatureInterceptor(FeatureRepository featureRepository) {
    this.featureRepository = featureRepository;
  }

  @Override
  public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {
    HandlerMethod handlerMethod = (HandlerMethod) handler;
    FeatureToggle methodAnnotation = handlerMethod.getMethodAnnotation(FeatureToggle.class);
    if (methodAnnotation == null) {
      return true;
    }

    if(featureRepository.isOn(methodAnnotation.feature()) == null) {
      return true;
    }

    if(methodAnnotation.expectedToBeOn() == featureRepository.isOn(methodAnnotation.feature())) {
      return true;
    }

    httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);
    return false;
  }

  @Override
  public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {

  }

  @Override
  public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {

  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This feature interceptor uses the &lt;code&gt;FeatureToggle&lt;/code&gt; looks for the annotation, and the looks at a feature repository to see if the state of the feature flag is set to what the annotation expects and if it does not, returns a 404. The annotation has two attributes - &lt;code&gt;isOn&lt;/code&gt; and &lt;code&gt;feature&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FeatureToggle {
  String feature();

  boolean expectedToBeOn() default true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This annotation can be used on a controller method as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/hello&amp;quot;)
public class MessageController {
  @RequestMapping(&amp;quot;&amp;quot;)
  @FeatureToggle(feature = &amp;quot;feature.hello&amp;quot;)
  public Map hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello world!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;FeatureRepository&lt;/code&gt; has to look at all the properties that are available in the applications environment and filter out the ones that start with &lt;code&gt;feature.&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Collecting all the properties available in an environment is &lt;a href=&#34;https://stackoverflow.com/questions/23506471/spring-access-all-environment-properties-as-a-map-or-properties-object&#34;&gt;surprisingly complex&lt;/a&gt;, owing to the number of ways properties can be injected. Based on the approach discussed in that question, we can create a &lt;code&gt;FeatureRepository&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureRepository {
  private static final String FEATURE_PREFIX = &amp;quot;feature.&amp;quot;;
  private final Environment env;

  public FeatureRepository(Environment env) {
    this.env = env;
  }

  public Set&amp;lt;String&amp;gt; featureKeys() {
    Map&amp;lt;String, Object&amp;gt; map = new HashMap();
    for(Iterator it = ((AbstractEnvironment) env).getPropertySources().iterator(); it.hasNext(); ) {
      PropertySource propertySource = (PropertySource) it.next();
      if (propertySource instanceof MapPropertySource) {
        map.putAll(((MapPropertySource) propertySource).getSource());
      }
    }
    return map.keySet().stream()
        .filter(k -&amp;gt; k.startsWith(FEATURE_PREFIX))
        .collect(Collectors.toSet());
  }

  public Boolean isOn(String key) {
    return allFeatures().get(key);
  }

  public Map&amp;lt;String, Boolean&amp;gt; allFeatures() {
    return featureKeys().stream().collect(Collectors.toMap(k -&amp;gt; k, k -&amp;gt; Boolean.parseBoolean(env.getProperty(k))));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;toggling-entire-controllers&#34;&gt;Toggling entire controllers&lt;/h3&gt;
&lt;p&gt;Since Spring controllers are wired up as beans, the &lt;code&gt;ConditionalOnProperty&lt;/code&gt; annotation can be used to toggle on entire controllers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/foo&amp;quot;)
@ConditionalOnProperty(value = &amp;quot;feature.foo&amp;quot;, havingValue = &amp;quot;true&amp;quot;)
public class FooController {
  @RequestMapping(&amp;quot;&amp;quot;)
  public Map hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello foo!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, now we have two different mechanisms to toggle methods and controllers. It will be nice to consolidate them and doing so will allow us to use the same mechanism for toggling beans. This can be done by annotating &lt;code&gt;FeatureToggle&lt;/code&gt; with the &lt;a href=&#34;https://sadique.io/blog/2015/12/06/implementing-custom-annotations-for-spring-mvc/&#34;&gt;meta annotation&lt;/a&gt; &lt;code&gt;Conditional&lt;/code&gt; that looks up the state of feature toggles using the custom condition &lt;code&gt;FeatureCondition&lt;/code&gt;. This will change &lt;code&gt;FeatureToggle&lt;/code&gt; to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(FeatureCondition.class)
public @interface FeatureToggle {
  String feature();

  boolean expectedToBeOn() default true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;FeatureCondition&lt;/code&gt; uses the meta annotation attributes provided to it and the environment to decide the state to be returned:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureCondition implements Condition {
  @Override
  public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
    if(annotatedTypeMetadata.isAnnotated(FeatureToggle.class.getCanonicalName())) {
      Map&amp;lt;String, Object&amp;gt; annotationAttributes = annotatedTypeMetadata
          .getAnnotationAttributes(FeatureToggle.class.getCanonicalName());
      String feature = (String) annotationAttributes.get(&amp;quot;feature&amp;quot;);
      boolean expectedToBeOn = Boolean.parseBoolean(String.valueOf(annotationAttributes.get(&amp;quot;expectedToBeOn&amp;quot;)));
      boolean isOn = Boolean.parseBoolean(conditionContext.getEnvironment().getProperty(feature));
      return expectedToBeOn == isOn;
    }
    return true;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a unified mechanism to toggle controllers, beans and controller methods, we can use this annotation. The &lt;code&gt;FooController&lt;/code&gt; would now look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/foo&amp;quot;)
@FeatureToggle(feature = &amp;quot;feature.foo&amp;quot;)
public class FooController {
  @RequestMapping(&amp;quot;&amp;quot;)
  public Map hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello foo!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And our &lt;code&gt;AppConfig&lt;/code&gt; will be like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class AppConfig extends WebMvcConfigurerAdapter {
  @Autowired
  Environment env;

  @Bean
  @FeatureToggle(feature = &amp;quot;feature.redis.session.store&amp;quot;, expectedToBeOn = false)
  public SessionRepository mapSessionRepository() {
    return new MapSessionRepository();
  }

  @Bean
  @FeatureToggle(feature = &amp;quot;feature.redis.session.store&amp;quot;)
  public SessionRepository redisSessionRepository(RedisConnectionFactory factory) {
    return new RedisOperationsSessionRepository(factory);
  }

  @Override
  public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new FeatureInterceptor(new FeatureRepository(env)));
    super.addInterceptors(registry);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the second part of &lt;a href=&#34;https://sadique.io/series/feature-toggles&#34;&gt;this series&lt;/a&gt;, we will explore how the feature toggle can be exposed to the front end and how to consume this and use it for toggling features in the Angular components.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;While feature toggles are just like any other application parameter, treating them as such in our stack resulted in errors, which we address later in this series.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;HandlerInterceptor&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Setting up a secure etcd cluster behind a proxy</title>
      <link>https://sadique.io/blog/2016/11/11/setting-up-a-secure-etcd-cluster-behind-a-proxy/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Fri, 11 Nov 2016 21:07:32 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/11/setting-up-a-secure-etcd-cluster-behind-a-proxy/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;This is a blog post that explains how to set up a highly available etcd cluster behind a proxy and securing the communication between a client and the proxy, between the proxy and the individual member in the cluster and between members in the cluster.&lt;/p&gt;
&lt;p&gt;CoreOS&amp;rsquo;s etcd is&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;hellip; a distributed key value store that provides a reliable way to store data across a cluster of machines. It’s open-source and available on GitHub. etcd gracefully handles leader elections during network partitions and will tolerate machine failure, including the leader.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It&amp;rsquo;s highly available distributed nature makes it a great choice for storing application configuration. Kubernetes, for example uses etcd to store all it&amp;rsquo;s API objects.&lt;/p&gt;
&lt;p&gt;The proxy mode in etcd allows etcd to run as a transparent proxy for a cluster. This makes it possible to expose only the proxy to the clients and abstract away discovery and leader election away from the client. The client needs to know only about the proxy.&lt;/p&gt;
&lt;p&gt;Communications to an etcd cluster and between members in a cluster can be secured through a PKI setup. Since an etcd proxy is in effect an etcd node that does not participate in leader election, communication between a client and a proxy can also be secured with similar infrastructure.&lt;/p&gt;
&lt;p&gt;In this example, we will set up a cluster of 3 etcd nodes. We will use a key pair for the nodes and proxy to communicate between each other and another key pair for clients to communicate with the proxy.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sadique.io/images/etcd-secure-cluster-proxy.svg&#34; alt=&#34;Diagram of a Secure Etcd Cluster with Proxy&#34; title=&#34;Secure Etcd Cluster with Proxy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;generating-keys&#34;&gt;Generating Keys&lt;/h2&gt;
&lt;p&gt;This section borrows heavily from Kelsey Hightower&amp;rsquo;s &lt;a href=&#34;https://github.com/kelseyhightower/kubernetes-the-hard-way&#34;&gt;Kubernetes the Hard Way tutorial&lt;/a&gt;. For the purposes of this blog post, we are going to assume that we will be running the three nodes and the proxy on a local machine. There will be changes that need to be made to the key configurations if these are deployed elsewhere. The instructions also assume that you are on OS X. Please make the necessary adjustments if you are on Linux.&lt;/p&gt;
&lt;h3 id=&#34;install-cloudflare-pki-toolkit&#34;&gt;Install CloudFlare PKI toolkit&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install the csffl utility
wget https://pkg.cfssl.org/R1.2/cfssl_darwin-amd64
chmod +x cfssl_darwin-amd64
sudo mv cfssl_darwin-amd64 /usr/local/bin/cfssl

# Install cfssljson utility
wget https://pkg.cfssl.org/R1.2/cfssljson_darwin-amd64
chmod +x cfssljson_darwin-amd64
sudo mv cfssljson_darwin-amd64 /usr/local/bin/cfssljson
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;create-ca-key-and-certificate&#34;&gt;Create CA key and certificate&lt;/h3&gt;
&lt;p&gt;The first step will be to create a Certificate Authority configuration.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#39;{
  &amp;quot;signing&amp;quot;: {
    &amp;quot;default&amp;quot;: {
      &amp;quot;expiry&amp;quot;: &amp;quot;8760h&amp;quot;
    },
    &amp;quot;profiles&amp;quot;: {
      &amp;quot;etcd-node&amp;quot;: {
        &amp;quot;usages&amp;quot;: [&amp;quot;signing&amp;quot;, &amp;quot;key encipherment&amp;quot;, &amp;quot;server auth&amp;quot;, &amp;quot;client auth&amp;quot;],
        &amp;quot;expiry&amp;quot;: &amp;quot;8760h&amp;quot;
      },
      &amp;quot;etcd-proxy&amp;quot;: {
        &amp;quot;usages&amp;quot;: [&amp;quot;signing&amp;quot;, &amp;quot;key encipherment&amp;quot;, &amp;quot;server auth&amp;quot;, &amp;quot;client auth&amp;quot;],
        &amp;quot;expiry&amp;quot;: &amp;quot;8760h&amp;quot;
      }
    }
  }
}&#39; &amp;gt; ca-config.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we are specifying two different profiles - one for the node key and one for the proxy key. We will then create a configuration for certificate signing request (CSR) for the CA key and certificate.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#39;{
  &amp;quot;CN&amp;quot;: &amp;quot;Etcd&amp;quot;,
  &amp;quot;key&amp;quot;: {
    &amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
    &amp;quot;size&amp;quot;: 2048
  },
  &amp;quot;names&amp;quot;: [
    {
      &amp;quot;C&amp;quot;: &amp;quot;US&amp;quot;,
      &amp;quot;L&amp;quot;: &amp;quot;San Francisco&amp;quot;,
      &amp;quot;O&amp;quot;: &amp;quot;Infra&amp;quot;,
      &amp;quot;OU&amp;quot;: &amp;quot;CA&amp;quot;,
      &amp;quot;ST&amp;quot;: &amp;quot;California&amp;quot;
    }
  ]
}&#39; &amp;gt; ca-csr.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we will generate the certificate and key.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cfssl gencert -initca ca-csr.json | cfssljson -bare ca
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will generate the three files: &lt;code&gt;ca-key.pem&lt;/code&gt; - private key for the CA, &lt;code&gt;ca.pem&lt;/code&gt; - certificate for the CA and &lt;code&gt;ca.csr&lt;/code&gt; - certificate signing request for the CA.&lt;/p&gt;
&lt;h3 id=&#34;create-node-certificate-and-key&#34;&gt;Create Node certificate and key&lt;/h3&gt;
&lt;p&gt;Once we have the CA certificate and key in place, we can generate the TLS key for securing the communications between nodes and proxy. We will start by creating a configuration for this certificate. Since we are running everything locally, the hosts allowed to authenticate with this certificate include only &lt;code&gt;localhost&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#39;{
  &amp;quot;CN&amp;quot;: &amp;quot;etcd-node&amp;quot;,
  &amp;quot;hosts&amp;quot;: [
    &amp;quot;localhost&amp;quot;,
    &amp;quot;0.0.0.0&amp;quot;,
    &amp;quot;127.0.0.1&amp;quot;
  ],
  &amp;quot;key&amp;quot;: {
    &amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
    &amp;quot;size&amp;quot;: 2048
  },
  &amp;quot;names&amp;quot;: [
    {
      &amp;quot;C&amp;quot;: &amp;quot;US&amp;quot;,
      &amp;quot;L&amp;quot;: &amp;quot;San Francisco&amp;quot;,
      &amp;quot;O&amp;quot;: &amp;quot;Infra&amp;quot;,
      &amp;quot;OU&amp;quot;: &amp;quot;Cluster&amp;quot;,
      &amp;quot;ST&amp;quot;: &amp;quot;California&amp;quot;
    }
  ]
}&#39; &amp;gt; etcd-node-csr.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can generate the node certificate and key&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -profile=etcd-node \
  etcd-node-csr.json | cfssljson -bare etcd-node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will create three files: &lt;code&gt;etcd-node.pem&lt;/code&gt;- the node certificate, &lt;code&gt;etcd-node-key.pem&lt;/code&gt; the key for this certificate and &lt;code&gt;etcd-node.csr&lt;/code&gt; - the certificate signing request.&lt;/p&gt;
&lt;h3 id=&#34;create-proxy-certificate-and-key&#34;&gt;Create Proxy certificate and key&lt;/h3&gt;
&lt;p&gt;We can now generate the TLS key for securing the communications between the client and the proxy. We will start by creating a configuration for this certificate. Since our client and proxy are running locally, the hosts allowed to authenticate with this certificate include only &lt;code&gt;localhost&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#39;{
  &amp;quot;CN&amp;quot;: &amp;quot;etcd-proxy&amp;quot;,
  &amp;quot;hosts&amp;quot;: [
    &amp;quot;localhost&amp;quot;,
    &amp;quot;0.0.0.0&amp;quot;,
    &amp;quot;127.0.0.1&amp;quot;
  ],
  &amp;quot;key&amp;quot;: {
    &amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
    &amp;quot;size&amp;quot;: 2048
  },
  &amp;quot;names&amp;quot;: [
    {
      &amp;quot;C&amp;quot;: &amp;quot;US&amp;quot;,
      &amp;quot;L&amp;quot;: &amp;quot;San Francisco&amp;quot;,
      &amp;quot;O&amp;quot;: &amp;quot;Infra&amp;quot;,
      &amp;quot;OU&amp;quot;: &amp;quot;Cluster&amp;quot;,
      &amp;quot;ST&amp;quot;: &amp;quot;California&amp;quot;
    }
  ]
}&#39; &amp;gt; etcd-proxy-csr.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can generate the proxy certificate and key&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -profile=etcd-proxy \
  etcd-proxy-csr.json | cfssljson -bare etcd-proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will create three files: &lt;code&gt;etcd-proxy.pem&lt;/code&gt;- the proxy certificate, &lt;code&gt;etcd-proxy-key.pem&lt;/code&gt; the key for this certificate and &lt;code&gt;etcd-proxy.csr&lt;/code&gt; - the certificate signing request.&lt;/p&gt;
&lt;h2 id=&#34;running-the-nodes-securely&#34;&gt;Running the nodes securely&lt;/h2&gt;
&lt;p&gt;Now that we have the certificates and keys, we will start the three nodes that form our etcd cluster. We will create three shell scripts that does this for us. In each of these, we will pass the appropriate parameters to etcd so that it uses the node certificate and key.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#script for node1
echo &#39;#!/usr/bin/env sh

etcd \
--name=&#39;node1&#39; \
--listen-client-urls=&#39;https://localhost:1179&#39; \
--advertise-client-urls=&#39;https://localhost:1179&#39; \
--listen-peer-urls=&#39;https://localhost:1180&#39; \
--initial-advertise-peer-urls=&#39;https://localhost:1180&#39; \
--initial-cluster=&#39;node1=https://localhost:1180,node2=https://localhost:1280,node3=https://localhost:1380&#39; \
--initial-cluster-token=&#39;etcd-cluster-token&#39; \
--initial-cluster-state=&#39;new&#39; \
--cert-file=./etcd-node.pem \
--key-file=./etcd-node-key.pem \
--peer-cert-file=./etcd-node.pem \
--peer-key-file=./etcd-node-key.pem \
--trusted-ca-file=./ca.pem \
--peer-trusted-ca-file=./ca.pem \
--data-dir=./nodes/node1 \
--peer-client-cert-auth=&#39;true&#39;
&#39; &amp;gt; start-node1.sh

# script for node2
echo &#39;#!/usr/bin/env sh

etcd \
--name=&#39;node2&#39; \
--listen-client-urls=&#39;https://localhost:1279&#39; \
--advertise-client-urls=&#39;https://localhost:1279&#39; \
--listen-peer-urls=&#39;https://localhost:1280&#39; \
--initial-advertise-peer-urls=&#39;https://localhost:1280&#39; \
--initial-cluster=&#39;node1=https://localhost:1180,node2=https://localhost:1280,node3=https://localhost:1380&#39; \
--initial-cluster-token=&#39;etcd-cluster-token&#39; \
--initial-cluster-state=&#39;new&#39; \
--cert-file=./etcd-node.pem \
--key-file=./etcd-node-key.pem \
--peer-cert-file=./etcd-node.pem \
--peer-key-file=./etcd-node-key.pem \
--trusted-ca-file=./ca.pem \
--peer-trusted-ca-file=./ca.pem \
--data-dir=./nodes/node2 \
--peer-client-cert-auth=&#39;true&#39;
&#39; &amp;gt; start-node2.sh

#script for node3
echo &#39;#!/usr/bin/env sh

etcd \
--name=&#39;node3&#39; \
--listen-client-urls=&#39;https://localhost:1379&#39; \
--advertise-client-urls=&#39;https://localhost:1379&#39; \
--listen-peer-urls=&#39;https://localhost:1380&#39; \
--initial-advertise-peer-urls=&#39;https://localhost:1380&#39; \
--initial-cluster=&#39;node1=https://localhost:1180,node2=https://localhost:1280,node3=https://localhost:1380&#39; \
--initial-cluster-token=&#39;etcd-cluster-token&#39; \
--initial-cluster-state=&#39;new&#39; \
--cert-file=./etcd-node.pem \
--key-file=./etcd-node-key.pem \
--peer-cert-file=./etcd-node.pem \
--peer-key-file=./etcd-node-key.pem \
--trusted-ca-file=./ca.pem \
--peer-trusted-ca-file=./ca.pem \
--data-dir=./nodes/node3 \
--peer-client-cert-auth=&#39;true&#39;
&#39; &amp;gt; start-node3.sh

chmod +x ./start-node1.sh ./start-node2.sh ./start-node3.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once these scripts are executed, we have an etcd cluster of three nodes. We can test that this cluster is started correctly with the right security using &lt;code&gt;etcdctl&lt;/code&gt; client. For this purpose, we will be using the node certificate and key temporarily. We will also be assuming that we know what the individual nodes are. It is important to note that in our final configuration, the client will not have access to this certificate and key. It will have access only to the proxy key and there is no guarantee that the client knows what the individual nodes are.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ etcdctl --cert-file=./etcd-node.pem  --key-file=./etcd-node-key.pem --ca-file=./ca.pem --endpoints=https://0.0.0.0:1179,https://0.0.0.0:1279,https://0.0.0.0:1379 cluster-health
member 5a68dbeefb870ed1 is healthy: got healthy result from https://localhost:1179
member 772c76fe731a3914 is healthy: got healthy result from https://localhost:1379
member aa3bff8d4d84db66 is healthy: got healthy result from https://localhost:1279
cluster is healthy
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;configuring-the-secure-proxy&#34;&gt;Configuring the secure proxy&lt;/h2&gt;
&lt;p&gt;Once we have the cluster running, we can run the proxy. To secure it, we will tell etcd to use the etcd-node key for communicating with the nodes and to use the etcd-proxy certificate to accept connection from clients.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#39;#!/usr/bin/env sh

etcd \
    --name=&#39;proxy&#39; \
     --proxy=on \
     --listen-client-urls https://localhost:2379 \
     --initial-cluster &#39;node1=https://localhost:1180,node2=https://localhost:1280,node3=https://localhost:1380&#39; \
     --peer-cert-file=./etcd-node.pem \
     --peer-key-file=./etcd-node-key.pem \
     --peer-trusted-ca-file=./ca.pem \
     --peer-client-cert-auth=&#39;true&#39; \
     --ca-file=./ca.pem \
     --cert-file=./etcd-proxy.pem \
     --key-file=./etcd-proxy-key.pem \
     --data-dir=./nodes/proxy
&#39; &amp;gt; start-proxy.sh

chmod +x start-proxy.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once we have the proxy running with these parameters, we can test that the cluster and the proxy is configured correctly. This time, we will be using only the proxy certificate and the proxy end point.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ etcdctl --cert-file=./etcd-proxy.pem  --key-file=./etcd-proxy-key.pem --ca-file=./ca.pem --endpoints=https://0.0.0.0:2379 cluster-health
member 5a68dbeefb870ed1 is healthy: got healthy result from https://localhost:1179
member 772c76fe731a3914 is healthy: got healthy result from https://localhost:1379
member aa3bff8d4d84db66 is healthy: got healthy result from https://localhost:1279
cluster is healthy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This set up gives us a secure etcd cluster with a secure proxy in front of it. Communications between client and proxy, proxy and nodes and among nodes are all secured.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handling Deserialization errors in Spring Redis Sessions</title>
      <link>https://sadique.io/blog/2016/11/02/handling-deserialization-errors-in-spring-redis-sessions/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Wed, 02 Nov 2016 20:10:33 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/02/handling-deserialization-errors-in-spring-redis-sessions/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;One of the challenges of using storing spring sessions in Redis is that the objects that gets stored as part of a session often undergoes changes as the application evolves and these changes cause de-serialization exceptions to be thrown after a deployment when a session created before the deployment is presented to the application. This blog post discusses a method to work around this issue.&lt;/p&gt;
&lt;h2 id=&#34;the-issue&#34;&gt;The issue&lt;/h2&gt;
&lt;p&gt;Consider an application that uses a custom authentication service to validate credentials presented by a client. To achieve this, we will wire up a custom authentication provider which creates an object &lt;code&gt;Customer&lt;/code&gt; as the authenticated user in session.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Customer extends User {
  public Customer(String name) {
    super(name, &amp;quot;&amp;quot;, Collections.singletonList(new SimpleGrantedAuthority(&amp;quot;USER&amp;quot;)));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Things work great, but after a while the team decides to store the logged in user&amp;rsquo;s email address in the session. To achieve this, we change the &lt;code&gt;Customer&lt;/code&gt; type to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Customer extends User {
  private String email;

  public Customer(String name, String email) {
    super(name, &amp;quot;&amp;quot;, Collections.singletonList(new SimpleGrantedAuthority(&amp;quot;USER&amp;quot;)));
    this.email = email;
  }

  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When this code is deployed and a user tries to access a protected resource by presenting a session created before the deployment, an exception is thrown.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;org.springframework.data.redis.serializer.SerializationException: Cannot deserialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.InvalidClassException: in.sdqali.spring.vo.Customer; local class incompatible: stream classdesc serialVersionUID = 5161850915957547690, local class serialVersionUID = 1045726772100761661
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This happens because the serialized object in the session and the current structure of the session differ.&lt;/p&gt;
&lt;h2 id=&#34;solutions&#34;&gt;Solutions&lt;/h2&gt;
&lt;p&gt;This issue was raised on the Spring Session issue tracker &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; and there were a lot of work-arounds discussed. Of the work arounds, wrapping the session repository offers the least disruption to the end user.
This approach ensures that every time a de-serialization error is thrown while trying to read an object from the session, that object is deleted, preventing subsequent errors.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SafeDeserializationRepository&amp;lt;S extends ExpiringSession&amp;gt; implements SessionRepository&amp;lt;S&amp;gt; {
  private final SessionRepository&amp;lt;S&amp;gt; delegate;
  private final RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate;

  private static final String BOUNDED_HASH_KEY_PREFIX = &amp;quot;spring:session:sessions:&amp;quot;;
  private static final Logger logger = getLogger(SafeDeserializationRepository.class);

  public SafeDeserializationRepository(SessionRepository&amp;lt;S&amp;gt; delegate,
                                       RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate) {
    this.delegate = delegate;
    this.redisTemplate = redisTemplate;
  }

  @Override
  public S createSession() {
    return delegate.createSession();
  }

  @Override
  public void save(S session) {
    delegate.save(session);
  }

  @Override
  public S getSession(String id) {
    try {
      return delegate.getSession(id);
    } catch(SerializationException e) {
      logger.info(&amp;quot;Deleting non-deserializable session with key {}&amp;quot;, id);
      redisTemplate.delete(BOUNDED_HASH_KEY_PREFIX + id);
      return null;
    }
  }

  @Override
  public void delete(String id) {
    delegate.delete(id);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, it is not easy to wire up this repository in the configuration. Since Spring Redis Session is auto configured, the only way to override beans for Redis Session is to extend &lt;code&gt;RedisHttpSessionConfiguration&lt;/code&gt; and specify beans. Ideally, we want to override the method &lt;code&gt;RedisHttpSessionConfiguration#sessionRepository&lt;/code&gt;. This would mean that &lt;code&gt;SafeDeserializationRepository&lt;/code&gt; inherits from &lt;code&gt;RedisOperationsSessionRepository&lt;/code&gt;. That does not sound too complicated till you realize that &lt;code&gt;RedisOperationsSessionRepository#getSession(java.lang.String)&lt;/code&gt; returns &lt;code&gt;RedisSession&lt;/code&gt; which is a final class declared inside &lt;code&gt;RedisOperationsSessionRepository&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;On closer look, the repository is hooked in to &lt;code&gt;SessionRepositoryFilter&lt;/code&gt; and it is indeed possible to override the &lt;code&gt;SpringHttpSessionConfiguration#springSessionRepositoryFilter&lt;/code&gt; method to create a new filter that takes our &lt;code&gt;SafeDeserializationRepository&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class RedisSessionConfig extends RedisHttpSessionConfiguration {
  @Autowired
  RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate;

  @Bean
  @Override
  public &amp;lt;S extends ExpiringSession&amp;gt; SessionRepositoryFilter&amp;lt;? extends ExpiringSession&amp;gt; springSessionRepositoryFilter(SessionRepository&amp;lt;S&amp;gt; sessionRepository) {
    return super.springSessionRepositoryFilter(new SafeDeserializationRepository&amp;lt;&amp;gt;(sessionRepository, redisTemplate));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/spring-projects/spring-session/issues/280&#34;&gt;SerializationFailedException after re-deploying with changed session object #280&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>CSRF Protection with Spring Security and Angular JS</title>
      <link>https://sadique.io/blog/2016/07/21/csrf-protection-with-spring-security-and-angular-js/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Thu, 21 Jul 2016 01:57:01 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/07/21/csrf-protection-with-spring-security-and-angular-js/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;Both Spring Security and Angular JS provide support for CSRF protection. However, getting these to work together to provide protection from CSRF requires some non-obvious configuration. This blog post explains how to add CSRF protection to an application that uses Spring Security with an Angular JS front end.&lt;/p&gt;
&lt;p&gt;Cross-Site Request Forgery (CSRF) &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; is an attack that forces an end user to execute unwanted actions on a web application in which they&amp;rsquo;re currently authenticated. This blog post implements the CSRF token part of the protection described by OWASP. The application still needs to have protection to enforce the right Origin for requests.&lt;/p&gt;
&lt;h3 id=&#34;front-end&#34;&gt;Front end&lt;/h3&gt;
&lt;p&gt;For this example, we will build a simple Spring Boot application with an Angular front end. The front end is based on the application we built for the &lt;a href=&#34;https://sadique.io/blog/2016/07/02/jwt-authentication-with-spring-web-part-1/&#34;&gt;series&lt;/a&gt; on authentication with JWT. The changes are in how the initial authentication is done - we will be using Basic Auth in this example to perform the initial authentication.&lt;/p&gt;
&lt;p&gt;This involves changing the &lt;code&gt;LoginService&lt;/code&gt; to this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(angular) {
  var LoginFactory = function($http) {
    return function(credentials, success, error) {
      $http({
        method: &#39;POST&#39;,
        url: &#39;/login&#39;,
        headers: {
          Authorization: &amp;quot;Basic &amp;quot; + btoa(credentials.username + &amp;quot;:&amp;quot; + credentials.password)
        }
      }).then(function (resp) {
        success(resp.data, resp.headers())
      }, error);
    };
  };

  LoginFactory.$inject = [&#39;$http&#39;];
  angular.module(&#39;jwtDemo.services&#39;).factory(&#39;Login&#39;, LoginFactory);

  var HelloFactory = function($resource) {
    return $resource(&#39;/hello&#39;, {}, {
      hello: {
        method: &#39;GET&#39;
      }
    });
  };

  HelloFactory.$inject = [&#39;$resource&#39;];
  angular.module(&#39;jwtDemo.services&#39;).factory(&#39;Hello&#39;, HelloFactory);}(angular));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the controllers are changed to use these services.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(angular) {
  var LoginController = function($scope, $localStorage, $http, $location, Login) {
    $scope.login = function(username, password) {
      new Login({username: username, password: password},
          function (data, headers) {
            $localStorage.user = data.user;
            $localStorage.authToken = headers[&#39;x-auth-token&#39;];
            $http.defaults.headers.common[&#39;x-auth-token&#39;] = headers[&#39;x-auth-token&#39;];
            $location.path(&amp;quot;/&amp;quot;);
          }, function (error) {
            console.log(error);
          });
    };

    $scope.logout = function () {
      delete $localStorage.user;
      delete $localStorage.authToken;
      $http.defaults.headers.common = {};
    }

    $scope.logout();
  };

  LoginController.$inject = [&#39;$scope&#39;, &#39;$localStorage&#39;, &#39;$http&#39;, &#39;$location&#39;,&#39;Login&#39;];
  angular.module(&amp;quot;jwtDemo.controllers&amp;quot;).controller(&amp;quot;LoginController&amp;quot;, LoginController);


  var ProfileController = function ($scope, $localStorage, Hello) {
    $scope.profile = $localStorage.user;
    new Hello().$hello(function (resp, headers) {
      $scope.greeting = resp.message;
    }, function (error) {
      console.log(error);
    })
  };
  ProfileController.inject = [&#39;$scope&#39;, &#39;$localStorage&#39;, &#39;Hello&#39;];
  angular.module(&amp;quot;jwtDemo.controllers&amp;quot;).controller(&amp;quot;ProfileController&amp;quot;, ProfileController);
  }(angular));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It can be noted that there are no CSRF specific code in there. We will be relying on Angular&amp;rsquo;s CSRF (or XSRF as Angular refers to it) protection.&lt;/p&gt;
&lt;h3 id=&#34;the-back-end&#34;&gt;The back end&lt;/h3&gt;
&lt;p&gt;The main API returns a greeting:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/hello&amp;quot;)
public class HelloController {
  @RequestMapping(method = GET,
      path = &amp;quot;&amp;quot;,
      produces = APPLICATION_JSON_VALUE)
  public Map&amp;lt;String, String&amp;gt; hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also have an end point that clients can authenticate against and it returns the currently authenticated user:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/login&amp;quot;)
public class LoginController {
  @RequestMapping(method = POST,
      path = &amp;quot;&amp;quot;,
      produces = APPLICATION_JSON_VALUE)
  public Map&amp;lt;String, Object&amp;gt; login(Authentication auth) {
    return Collections.singletonMap(&amp;quot;user&amp;quot;, auth.getName());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;security&#34;&gt;Security&lt;/h3&gt;
&lt;p&gt;In this example, we will be using an in-memory authentication. We will also be using a header based session instead of a Cookie based session by wiring up &lt;code&gt;HeaderHttpSessionStrategy&lt;/code&gt;. Sessions are stored in-memory using &lt;code&gt;MapSessionRepository&lt;/code&gt;. We also secure all end points except the front end components and the &lt;code&gt;/login&lt;/code&gt; end point.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@EnableWebSecurity
@Configuration
@EnableSpringHttpSession
public class SecurityConfig extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    String[] patterns = new String[] {
        &amp;quot;/&amp;quot;,
        &amp;quot;/login&amp;quot;,
        &amp;quot;/bower_components/**/*&amp;quot;,
        &amp;quot;/app/**/*&amp;quot;,
        &amp;quot;/index.html&amp;quot;,
        &amp;quot;/home.html&amp;quot;,
        &amp;quot;/signin.html&amp;quot;,
        &amp;quot;/favicon.ico&amp;quot;
    };

    http
        .authorizeRequests()
        .antMatchers(patterns)
        .permitAll()
        .antMatchers(&amp;quot;/hello/**&amp;quot;)
        .hasRole(&amp;quot;USER&amp;quot;)
        .and()
        .csrf()
        .disable()
        .httpBasic();
  }

  @Autowired
  public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .inMemoryAuthentication()
        .withUser(&amp;quot;user&amp;quot;).password(&amp;quot;password&amp;quot;).roles(&amp;quot;USER&amp;quot;);
  }

  @Bean
  public SessionRepository sessionRepository() {
    return new MapSessionRepository();
  }

  @Bean
  public HeaderHttpSessionStrategy sessionStrategy() {
    return new HeaderHttpSessionStrategy();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this in place, access to the end point &lt;code&gt;/hello&lt;/code&gt; is not permitted unless authenticated.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -s -X GET &amp;quot;http://localhost:8080/hello&amp;quot; | jq .
{
  &amp;quot;timestamp&amp;quot;: 1469068247812,
  &amp;quot;status&amp;quot;: 401,
  &amp;quot;error&amp;quot;: &amp;quot;Unauthorized&amp;quot;,
  &amp;quot;message&amp;quot;: &amp;quot;Full authentication is required to access this resource&amp;quot;,
  &amp;quot;path&amp;quot;: &amp;quot;/hello&amp;quot;
}

$ curl -s -v -X POST &amp;quot;http://localhost:8080/login&amp;quot; -uuser:password | jq .
*   Trying ::1...
* Connected to localhost (::1) port 8080 (#0)
* Server auth using Basic with user &#39;user&#39;
&amp;gt; POST /login HTTP/1.1
&amp;gt; Host: localhost:8080
&amp;gt; Authorization: Basic dXNlcjpwYXNzd29yZA==
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Server: Apache-Coyote/1.1
&amp;lt; X-Content-Type-Options: nosniff
&amp;lt; X-XSS-Protection: 1; mode=block
&amp;lt; Cache-Control: no-cache, no-store, max-age=0, must-revalidate
&amp;lt; Pragma: no-cache
&amp;lt; Expires: 0
&amp;lt; X-Frame-Options: DENY
&amp;lt; x-auth-token: 4ec4c614-0dc8-4e64-afa6-bd0ac03517b5
&amp;lt; Content-Type: application/json;charset=UTF-8
&amp;lt; Transfer-Encoding: chunked
&amp;lt; Date: Thu, 21 Jul 2016 02:31:10 GMT
&amp;lt;
{ [18 bytes data]
* Connection #0 to host localhost left intact
{
  &amp;quot;user&amp;quot;: &amp;quot;user&amp;quot;
}

$ curl -s -X GET &amp;quot;http://localhost:8080/hello&amp;quot; -H &amp;quot;x-auth-token: 4ec4c614-0dc8-4e64-afa6-bd0ac03517b5&amp;quot; | jq .
{
  &amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;enabling-csrf-protection&#34;&gt;Enabling CSRF protection&lt;/h3&gt;
&lt;p&gt;In Spring Security, CSRF protection can be enabled by replacing &lt;code&gt;csrf().disable()&lt;/code&gt; with &lt;code&gt;.csrf()&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    http
        .authorizeRequests()
        .antMatchers(patterns)
        .permitAll()
        .antMatchers(&amp;quot;/hello/**&amp;quot;)
        .hasRole(&amp;quot;USER&amp;quot;)
        .and()
        .csrf()
        .and()
        .httpBasic();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this in place however, we notice that all end points, including static assets and the login end point need CSRF protection tokens to access.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -s -X POST &amp;quot;http://localhost:8080/login&amp;quot; -uuser:password | jq .
{
  &amp;quot;timestamp&amp;quot;: 1469068611814,
  &amp;quot;status&amp;quot;: 403,
  &amp;quot;error&amp;quot;: &amp;quot;Forbidden&amp;quot;,
  &amp;quot;message&amp;quot;: &amp;quot;Expected CSRF token not found. Has your session expired?&amp;quot;,
  &amp;quot;path&amp;quot;: &amp;quot;/login&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;protecting-urls-selectively&#34;&gt;Protecting URLs selectively&lt;/h3&gt;
&lt;p&gt;We want a mechanism to specify a list of URL patterns for which CSRF protection need to be turned OFF. Spring Security provides a &lt;code&gt;requireCsrfProtectionMatcher&lt;/code&gt; method. With this, we will add a matcher that returns false when any of the URL patters we have matches the current request&amp;rsquo;s path.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;http
        .authorizeRequests()
        .antMatchers(patterns)
        .permitAll()
        .antMatchers(&amp;quot;/hello/**&amp;quot;)
        .hasRole(&amp;quot;USER&amp;quot;)
        .and()
        .csrf()
        .requireCsrfProtectionMatcher(new NoAntPathRequestMatcher(patterns))
        .and()
        .httpBasic();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;NoAntPathRequestMatcher&lt;/code&gt; can be implemented as a combination of two request matchers provided by Spring - &lt;code&gt;NegatedRequestMatcher&lt;/code&gt; and &lt;code&gt;AndRequestMatcher&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NoAntPathRequestMatcher implements RequestMatcher {
  private final AndRequestMatcher andRequestMatcher;

  public NoAntPathRequestMatcher(String[] patterns) {
    List&amp;lt;RequestMatcher&amp;gt; requestMatchers = Arrays.asList(patterns)
        .stream()
        .map(p -&amp;gt; new NegatedRequestMatcher(new AntPathRequestMatcher(p)))
        .collect(Collectors.toList());

    andRequestMatcher = new AndRequestMatcher(requestMatchers);
  }

  @Override
  public boolean matches(HttpServletRequest request) {
    return andRequestMatcher.matches(request);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this in place, we should be able to authenticate.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -s -v -X POST &amp;quot;http://localhost:8080/login&amp;quot; -uuser:password | jq .
*   Trying ::1...
* Connected to localhost (::1) port 8080 (#0)
* Server auth using Basic with user &#39;user&#39;
&amp;gt; POST /login HTTP/1.1
&amp;gt; Host: localhost:8080
&amp;gt; Authorization: Basic dXNlcjpwYXNzd29yZA==
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Server: Apache-Coyote/1.1
&amp;lt; X-Content-Type-Options: nosniff
&amp;lt; X-XSS-Protection: 1; mode=block
&amp;lt; Cache-Control: no-cache, no-store, max-age=0, must-revalidate
&amp;lt; Pragma: no-cache
&amp;lt; Expires: 0
&amp;lt; X-Frame-Options: DENY
&amp;lt; x-auth-token: c5af3ea9-e3f8-4425-a6e8-de35588af0ca
&amp;lt; Content-Type: application/json;charset=UTF-8
&amp;lt; Transfer-Encoding: chunked
&amp;lt; Date: Thu, 21 Jul 2016 02:44:28 GMT
&amp;lt;
{ [18 bytes data]
* Connection #0 to host localhost left intact
{
  &amp;quot;user&amp;quot;: &amp;quot;user&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But we do not see anything in the response that tells the client what the token allocated to it for the current session is. This is because Spring Security&amp;rsquo;s CSRF protection by default provides enforcement and allocation of tokens, but it does not expose the token granted to the client out of the box.&lt;/p&gt;
&lt;h3 id=&#34;granting-csrf-token-to-the-client&#34;&gt;Granting CSRF Token to the client&lt;/h3&gt;
&lt;p&gt;One way to grant the client the CSRF token allocated to the current session will be to add a filter that sets the token as a Cookie once it is available. For this, we will add a filter immediately after the session is assigned by Spring Security&amp;rsquo;s &lt;code&gt;SessionManagementFilter&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    http
        .authorizeRequests()
        .antMatchers(patterns)
        .permitAll()
        .antMatchers(&amp;quot;/hello/**&amp;quot;)
        .hasRole(&amp;quot;USER&amp;quot;)
        .and()
        .csrf()
        .requireCsrfProtectionMatcher(csrfProtectionMatcher(patterns))
        .and()
        .httpBasic()
        .and()
        .addFilterAfter(new CsrfGrantingFilter(), SessionManagementFilter.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The filter is implemented as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CsrfGrantingFilter implements Filter {
  @Override
  public void init(FilterConfig filterConfig) throws ServletException {}

  @Override
  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)
      throws IOException, ServletException {
    CsrfToken csrf = (CsrfToken) servletRequest.getAttribute(CsrfToken.class.getName());
    String token = csrf.getToken();
    if (token != null &amp;amp;&amp;amp; isAuthenticating(servletRequest)) {
      HttpServletResponse response = (HttpServletResponse) servletResponse;
      Cookie cookie = new Cookie(&amp;quot;CSRF-TOKEN&amp;quot;, token);
      cookie.setPath(&amp;quot;/&amp;quot;);
      response.addCookie(cookie);
    }
    filterChain.doFilter(servletRequest, servletResponse);
  }

  private boolean isAuthenticating(ServletRequest servletRequest) {
    HttpServletRequest request = (HttpServletRequest) servletRequest;
    return request.getRequestURI().equals(&amp;quot;/login&amp;quot;);
  }

  @Override
  public void destroy() {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The filter checks to see if the current request has a CSRF token set on it by Spring Security&amp;rsquo;s &lt;code&gt;CsrfFilter&lt;/code&gt; and then sets it as a Cookie on the response, if the current request was made by a client to authenticate.&lt;/p&gt;
&lt;p&gt;With this filter in place, when we authenticate, we will see the following behavior:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -I -X POST &amp;quot;http://localhost:8080/login&amp;quot; -uuser:password
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Frame-Options: DENY
Set-Cookie: CSRF-TOKEN=628ae2c8-f35b-49a4-acc7-04fe87bdb98e; Path=/
x-auth-token: 9444d058-eccb-471d-bc0d-460fd4c968e8
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Thu, 21 Jul 2016 02:51:19 GMT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can clearly see that the CSRF token is sent to the client as a Cookie. At this point, we can make changes to our front end to send this token with every subsequent request. However, it is easier to use Angular&amp;rsquo;s support for CSRF tokens.&lt;/p&gt;
&lt;h3 id=&#34;customizing-csrf-protection-for-angular&#34;&gt;Customizing CSRF protection for Angular&lt;/h3&gt;
&lt;p&gt;Angular&amp;rsquo;s CSRF protection &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; uses the cookie &lt;code&gt;XSRF-TOKEN&lt;/code&gt; it expects from server responses and the header &lt;code&gt;X-XSRF-TOKEN&lt;/code&gt; which it will send for every subsequent request, once the Cookie is found in a response. We will have to configure Spring Security to use this header and token instead of it&amp;rsquo;s default header &lt;code&gt;X-CSRF-TOKEN&lt;/code&gt; and Cookie name &lt;code&gt;CSRF-TOKEN&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The first step is to pass Spring Security a custom &lt;code&gt;CsrfTokenRepository&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    http
        .authorizeRequests()
        .antMatchers(patterns)
        .permitAll()
        .antMatchers(&amp;quot;/hello/**&amp;quot;)
        .hasRole(&amp;quot;USER&amp;quot;)
        .and()
        .csrf()
        .csrfTokenRepository(csrfTokenRepository())
        .requireCsrfProtectionMatcher(csrfProtectionMatcher(patterns))
        .and()
        .httpBasic()
        .and()
        .addFilterAfter(new CsrfGrantingFilter(), SessionManagementFilter.class);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;CsrfTokenRepository&lt;/code&gt; is configured with the right header:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  private CsrfTokenRepository csrfTokenRepository() {
    HttpSessionCsrfTokenRepository repository = new HttpSessionCsrfTokenRepository();
    repository.setHeaderName(&amp;quot;X-XSRF-TOKEN&amp;quot;);
    return repository;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next step is to set the Cookie with the right name in the &lt;code&gt;CsrfGrantingFilter&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CsrfGrantingFilter implements Filter {

  @Override
  public void init(FilterConfig filterConfig) throws ServletException {}

  @Override
  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)
      throws IOException, ServletException {
    CsrfToken csrf = (CsrfToken) servletRequest.getAttribute(CsrfToken.class.getName());
    String token = csrf.getToken();
    if (token != null &amp;amp;&amp;amp; isAuthenticating(servletRequest)) {
      HttpServletResponse response = (HttpServletResponse) servletResponse;
      Cookie cookie = new Cookie(&amp;quot;XSRF-TOKEN&amp;quot;, token);
      cookie.setPath(&amp;quot;/&amp;quot;);
      response.addCookie(cookie);
    }
    filterChain.doFilter(servletRequest, servletResponse);
  }

  private boolean isAuthenticating(ServletRequest servletRequest) {
    HttpServletRequest request = (HttpServletRequest) servletRequest;
    return request.getRequestURI().equals(&amp;quot;/login&amp;quot;);
  }

  @Override
  public void destroy() {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With these configurations in place, the front end is able to authenticate and obtain a token Cookie which Angular will pass for every subsequent request.&lt;/p&gt;
&lt;h3 id=&#34;configuring-order-of-enforcement&#34;&gt;Configuring order of enforcement&lt;/h3&gt;
&lt;p&gt;The only drawback to the configurations we have developed so far is that when a client makes a request to a protected end point with out Authentication and CSRF token, it will receive a &lt;code&gt;403 Forbidden&lt;/code&gt; instead of a &lt;code&gt;401 Unauthorized&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -I -X GET &amp;quot;http://localhost:8080/hello&amp;quot;
HTTP/1.1 403 Forbidden
Server: Apache-Coyote/1.1
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Frame-Options: DENY
x-auth-token: a0abe09c-94cb-4966-9ee6-a5327f3bd939
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Thu, 21 Jul 2016 03:16:01 GMT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This happens because by default, when CSRF protection is enabled, &lt;code&gt;CsrfFilter&lt;/code&gt; appears in the filter chain before &lt;code&gt;FilterSecurityInterceptor&lt;/code&gt;. For this example, this is the order:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 = {WebAsyncManagerIntegrationFilter@7344}
1 = {SecurityContextPersistenceFilter@7343}
2 = {HeaderWriterFilter@7342}
3 = {CsrfFilter@7339}
4 = {LogoutFilter@7382}
5 = {BasicAuthenticationFilter@7381}
6 = {RequestCacheAwareFilter@8965}
7 = {SecurityContextHolderAwareRequestFilter@8964}
8 = {AnonymousAuthenticationFilter@8963}
9 = {SessionManagementFilter@8962}
10 = {CsrfGrantingFilter@8978}
11 = {ExceptionTranslationFilter@9333}
12 = {FilterSecurityInterceptor@9334}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If this is not the behavior desirable for your application, we can disable the default CSRF protection and enable the required filters, enforcing the right order. This is achieved with the following configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    http
        .authorizeRequests()
        .antMatchers(patterns)
        .permitAll()
        .antMatchers(&amp;quot;/hello/**&amp;quot;)
        .hasRole(&amp;quot;USER&amp;quot;)
        .and()
        .csrf()
        .disable()
        .httpBasic()
        .and()
        .addFilterAfter(csrfFilter(patterns), FilterSecurityInterceptor.class)
        .addFilterAfter(new CsrfGrantingFilter(), CsrfFilter.class);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The CSRF filter is built with the right repository and URL matchers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  private Filter csrfFilter(String[] patterns) {
    CsrfFilter csrfFilter = new CsrfFilter(csrfTokenRepository());
    csrfFilter.setRequireCsrfProtectionMatcher(csrfProtectionMatcher(patterns));
    return csrfFilter;
  }

  private NoAntPathRequestMatcher csrfProtectionMatcher(String[] patterns) {
    return new NoAntPathRequestMatcher(patterns);
  }

  private CsrfTokenRepository csrfTokenRepository() {
    HttpSessionCsrfTokenRepository repository = new HttpSessionCsrfTokenRepository();
    repository.setHeaderName(&amp;quot;X_XSRF_TOKEN&amp;quot;);
    return repository;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will result in the right order of errors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -I -X GET &amp;quot;http://localhost:8080/hello&amp;quot;
HTTP/1.1 401 Unauthorized
Server: Apache-Coyote/1.1
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Frame-Options: DENY
WWW-Authenticate: Basic realm=&amp;quot;Realm&amp;quot;
x-auth-token: 08a06acd-3398-4fc4-af25-23d3f4155a2b
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Thu, 21 Jul 2016 03:27:58 GMT

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the end of this blog post. In this example, we built an application with CSRF protection that works well with Angular JS. The code for this blog post is available &lt;a href=&#34;https://github.com/sdqali/csrf-demo&#34;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;For a detailed explanation, see Cross-Site Request Forgery (CSRF) &lt;a href=&#34;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)&#34;&gt;on OWASP&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;See section &lt;em&gt;Cross Site Request Forgery (XSRF) Protection&lt;/em&gt; in &lt;a href=&#34;https://docs.angularjs.org/api/ng/service/$http&#34;&gt;the official documentation&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Controlling Redis auto-configuration for Spring Boot Session</title>
      <link>https://sadique.io/blog/2016/07/16/controlling-redis-auto-configuration-for-spring-boot-session/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sat, 16 Jul 2016 22:42:05 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/07/16/controlling-redis-auto-configuration-for-spring-boot-session/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;If you have been using Spring Boot, chances are that you are using the Spring Session library to handle sessions. Spring Session has the ability to persist the sessions to various data stores, including Redis. The default behaviors of Spring Boot when combined with Spring Session is to start using Redis as the session store the moment &lt;code&gt;spring-session-data-redis&lt;/code&gt; is detected in the class path, thereby making it hard to conditionally turn Redis support ON and OFF. This blog post explores why this is the default behavior and presents a solution to control this behavior.&lt;/p&gt;
&lt;h3 id=&#34;the-application&#34;&gt;The application&lt;/h3&gt;
&lt;p&gt;The application we will be using to demonstrate this behavior is a Spring Boot 1.3.6 application with a single controller.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/hello&amp;quot;)
public class HelloController {
  @RequestMapping(method = GET,
      path = &amp;quot;&amp;quot;,
      produces = APPLICATION_JSON_VALUE)
  public Map&amp;lt;String, String&amp;gt; hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The application also has Spring Security configured to allow authentication for a single user named &lt;code&gt;user&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
        .antMatchers(&amp;quot;/hello/**&amp;quot;).hasRole(&amp;quot;USER&amp;quot;)
        .and()
        .httpBasic();
  }

  @Autowired
  public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .inMemoryAuthentication()
        .withUser(&amp;quot;user&amp;quot;).password(&amp;quot;password&amp;quot;).roles(&amp;quot;USER&amp;quot;);
  }

  @Bean
  public HeaderHttpSessionStrategy sessionStrategy() {
    return new HeaderHttpSessionStrategy();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This forces clients to authenticate for access to resources under &lt;code&gt;/hello&lt;/code&gt; and configures an in memory user &lt;code&gt;user&lt;/code&gt; with password &lt;code&gt;password&lt;/code&gt;. In this example, we will also be using &lt;code&gt;HeaderHttpSessionStrategy&lt;/code&gt; &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; to pass the session value between client and server using the &lt;code&gt;x-auth-token&lt;/code&gt; header instead of a Cookie.&lt;/p&gt;
&lt;h3 id=&#34;the-issue&#34;&gt;The issue&lt;/h3&gt;
&lt;p&gt;This is an issue only when using Spring Boot 1.3 or greater. If we are to follow the instructions provided at the &lt;a href=&#34;http://docs.spring.io/spring-session/docs/1.2.1.RELEASE/reference/html5/guides/boot.html&#34;&gt;official documentation&lt;/a&gt; from Spring Session &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, we end up with the following configuration.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@EnableRedisHttpSession
public class RedisSessionConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this in place, authentication works as we expect. The application allows the user to obtain a session and authenticates correctly when presented with the session token.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -i -s -X GET &amp;quot;http://localhost:8080/hello&amp;quot; -uuser:password  | grep &amp;quot;x-auth-token&amp;quot;
x-auth-token: c0fbb47d-d19f-44b1-a8d7-44e4837f403d
$ curl -s -X GET &amp;quot;http://localhost:8080/hello&amp;quot; --header &amp;quot;x-auth-token: c0fbb47d-d19f-44b1-a8d7-44e4837f403d&amp;quot; | jq .
{
  &amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can monitor the interactions the application performs with Redis by running Redis monitor:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ redis-cli monitor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is great. Now, let&amp;rsquo;s attempt to modify our configuration to use Redis only in some environments and use the in-memory session store in others. We start by making &lt;code&gt;RedisSessionConfig&lt;/code&gt; conditional on the value of the property &lt;code&gt;use.redis.session.store&lt;/code&gt; being &lt;code&gt;true&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ConditionalOnProperty(name = &amp;quot;use.redis.session.store&amp;quot;, havingValue = &amp;quot;true&amp;quot;)
@EnableRedisHttpSession
public class RedisSessionConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will create a new configuration that sets up the in-memory session store if &lt;code&gt;use.redis.session.store&lt;/code&gt; is false or missing.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableSpringHttpSession
@ConditionalOnProperty(name = &amp;quot;use.redis.session.store&amp;quot;, havingValue = &amp;quot;false&amp;quot;, matchIfMissing = true)
public class MapSessionConfig {
  @Bean
  public SessionRepository sessionRepository() {
    return new MapSessionRepository();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s set the property to &lt;code&gt;false&lt;/code&gt; so that we do not have to depend on Redis in the local environment.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;use.redis.session.store=false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this in place, we expect that there are no interactions with Redis server. If we were to start the server, we will get the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
Caused by: java.net.ConnectException: Connection refused
    at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_45]
    at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:345) ~[na:1.8.0_45]
    at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_45]
    at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_45]
    at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_45]
    at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_45]
    at redis.clients.jedis.Connection.connect(Connection.java:158) ~[jedis-2.7.3.jar:na]
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It appears that the application is trying to make connections to Redis, even though we configured it not to. What is going on? It looks like some where along the chain, some configuration with the annotation &lt;code&gt;@EnableSpringHttpSession&lt;/code&gt; is being loaded. Why could that happen?&lt;/p&gt;
&lt;h3 id=&#34;spring-boot-autoconfig&#34;&gt;Spring Boot Autoconfig&lt;/h3&gt;
&lt;p&gt;Like a lot of Spring Boot applications, we are using the &lt;code&gt;@SpringBootApplication&lt;/code&gt; annotation in our application. This is a meta-annotation &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; that takes the following form:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Configuration
@EnableAutoConfiguration
@ComponentScan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; annotation is interesting because it wires up most of the default configuration that makes Spring Boot great for development. The annotation itself and the supporting mechanism that automatically loads configurations are present in the &lt;code&gt;org.springframework.boot:spring-boot-autoconfigure&lt;/code&gt; library. One of these configurations is &lt;code&gt;SessionAutoConfiguration&lt;/code&gt; which was introduced in Spring Boot &lt;code&gt;1.3.0&lt;/code&gt;. It has the following code in version &lt;code&gt;1.3.6&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ConditionalOnClass(Session.class)
@AutoConfigureAfter(RedisAutoConfiguration.class)
public class SessionAutoConfiguration {

    @EnableConfigurationProperties
    @ConditionalOnClass(RedisConnectionFactory.class)
    @ConditionalOnWebApplication
    @ConditionalOnMissingBean(RedisHttpSessionConfiguration.class)
    @EnableRedisHttpSession
    @Configuration
    public static class SessionRedisHttpConfiguration {

        @Autowired
        private ServerProperties serverProperties;

        @Autowired
        private RedisOperationsSessionRepository sessionRepository;

        @PostConstruct
        public void applyConfigurationProperties() {
            Integer timeout = this.serverProperties.getSession().getTimeout();
            if (timeout != null) {
                this.sessionRepository.setDefaultMaxInactiveInterval(timeout);
            }
        }

        @Configuration
        @ConditionalOnMissingBean(value = ServerProperties.class, search = SearchStrategy.CURRENT)
        // Just in case user switches off ServerPropertiesAutoConfiguration
        public static class ServerPropertiesConfiguration {

            @Bean
            // Use the same bean name as the default one for any old webapp
            public ServerProperties serverProperties() {
                return new ServerProperties();
            }

        }

    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And this is where things get interesting. We can clearly see that &lt;code&gt;SessionRedisHttpConfiguration&lt;/code&gt; is annotated with &lt;code&gt;@EnableRedisHttpSession&lt;/code&gt;. This class will be applied by Spring the moment it&amp;rsquo;s parent class &lt;code&gt;SessionAutoConfiguration&lt;/code&gt; is applied. The third annotation on the parent class &lt;code&gt;@AutoConfigureAfter(RedisAutoConfiguration.class)&lt;/code&gt; instructs Spring to apply this configuration after &lt;code&gt;RedisAutoConfiguration&lt;/code&gt;. This configuration has the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ConditionalOnClass({ JedisConnection.class, RedisOperations.class, Jedis.class })
@EnableConfigurationProperties
public class RedisAutoConfiguration {
// ...
// ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This configuration will be applied if and only if the classes &lt;code&gt;JedisConnection&lt;/code&gt;, &lt;code&gt;RedisOperations&lt;/code&gt; and &lt;code&gt;Jedis&lt;/code&gt; are present in the class path and by adding &lt;code&gt;spring-session-data-redis&lt;/code&gt; as a dependency, we are causing exactly that to happen.&lt;/p&gt;
&lt;h3 id=&#34;a-solution&#34;&gt;A solution&lt;/h3&gt;
&lt;p&gt;We can prevent this from occurring by configuring our application to not attempt to apply this auto configuration class. This can be done by specifying this class to be excluded from the application.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication(exclude = {SessionAutoConfiguration.class})
public class RedisSessionApplication {
    public static void main(String[] args) {
        SpringApplication.run(RedisSessionApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this is place, if we run the application, it will no longer encounter the connection error previously saw. Authentication works as before, except that it now uses the in-memory session store.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -i -s -X GET &amp;quot;http://localhost:8080/hello&amp;quot; -uuser:password  | grep &amp;quot;x-auth-token&amp;quot;
x-auth-token: d0962e39-6423-46b3-b815-8979950e063a
$ curl -s -X GET &amp;quot;http://localhost:8080/hello&amp;quot; --header &amp;quot;x-auth-token: d0962e39-6423-46b3-b815-8979950e063a&amp;quot; | jq .
{
  &amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;HeaderHttpSessionStrategy allows the use of a header to transmit the session between client and server. The default header is &lt;code&gt;x-auth-token&lt;/code&gt;, but this can be configured. See the documentation &lt;a href=&#34;http://docs.spring.io/spring-session/docs/current/api/org/springframework/session/web/http/HeaderHttpSessionStrategy.html&#34;&gt;here&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;This example uses the default configurations for Redis connection to localhost on port 6379.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;Meta annotations are annotations that can act up on other annotations by modifying and overriding their attributes. For a discussion on how to implement custom annotations using meta annotations, please refer to &lt;a href=&#34;https://sadique.io/blog/2015/12/06/implementing-custom-annotations-for-spring-mvc/&#34;&gt;this blog post&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>JWT authentication with Spring Web - Part 5</title>
      <link>https://sadique.io/blog/2016/07/14/jwt-authentication-with-spring-web-part-5/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Thu, 14 Jul 2016 06:05:53 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/07/14/jwt-authentication-with-spring-web-part-5/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In parts 1 through 4 of this series, we built a Spring API that can issue a JWT when a user successfully authenticates and verify the JWT presented by the client for subsequent requests. In this blog post - the last in the series, we will build a simple Angular JS application with authentication that uses this API as the backend.&lt;/p&gt;
&lt;p&gt;These are the blog posts in this series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/02/jwt-authentication-with-spring-web-part-1/&#34;&gt;Part 1&lt;/a&gt; - Discussion of JWT and implementation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/03/jwt-authentication-with-spring-web-part-2/&#34;&gt;Part 2&lt;/a&gt; - A Spring User Profiles API&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/05/jwt-authentication-with-spring-web-part-3/&#34;&gt;Part 3&lt;/a&gt; - Issuing a token from the server&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/07/jwt-authentication-with-spring-web-part-4/&#34;&gt;Part 4&lt;/a&gt; - Verifying the token sent back by the client&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/13/jwt-authentication-with-spring-web-part-5/&#34;&gt;Part 5&lt;/a&gt; - Securing the front end&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will use the following Angular plugins - &lt;code&gt;angular-resource&lt;/code&gt; for interacting with our APIs, &lt;code&gt;ngstorage&lt;/code&gt; to access the localStorage to store the JWT and &lt;code&gt;angular-ui-router&lt;/code&gt; to handle routing and managing UI views.&lt;/p&gt;
&lt;p&gt;For this example, our UI components are under the &lt;code&gt;src/main/resources/static&lt;/code&gt; directory. We will be loading our dependencies using bower by adding a &lt;code&gt;.bowerrc&lt;/code&gt; file at the root of our project.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;directory&amp;quot;: &amp;quot;src/main/resources/static/bower_components&amp;quot;,
  &amp;quot;json&amp;quot;: &amp;quot;bower.json&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will specify the dependencies we need in our &lt;code&gt;bower.json&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;jwt&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;angular&amp;quot;: &amp;quot;~1.3.0&amp;quot;,
    &amp;quot;angular-resource&amp;quot;: &amp;quot;~1.3.0&amp;quot;,
    &amp;quot;bootstrap-css-only&amp;quot;: &amp;quot;~3.2.0&amp;quot;,
    &amp;quot;ngstorage&amp;quot;: &amp;quot;0.3.10&amp;quot;,
    &amp;quot;angular-ui-router&amp;quot;: &amp;quot;1.0.0-beta.1&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The dependencies can be installed using &lt;code&gt;bower install&lt;/code&gt;. Once we have the dependencies, we can start by configuring Spring Security to allow access to the UI components:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        String[] patterns = new String[] {
            &amp;quot;/login&amp;quot;,
            &amp;quot;/bower_components/**/*&amp;quot;,
            &amp;quot;/app/**/*&amp;quot;,
            &amp;quot;/index.html&amp;quot;,
            &amp;quot;/home.html&amp;quot;,
            &amp;quot;/signin.html&amp;quot;
        };
        http.authorizeRequests()
                .antMatchers(patterns)
                .permitAll()
        // ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will start by creating our UI template &lt;code&gt;index.html&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;./bower_components/bootstrap-css-only/css/bootstrap.min.css&amp;quot; /&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body ng-app=&amp;quot;jwtDemo&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
      &amp;lt;ui-view&amp;gt;&amp;lt;/ui-view&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./bower_components/angular/angular.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./bower_components/angular-resource/angular-resource.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./bower_components/ngstorage/ngStorage.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./bower_components/angular-ui-router/release/angular-ui-router.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./app/app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./app/controllers.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./app/services.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For this example, we will have one Angular service in &lt;code&gt;app/services.js&lt;/code&gt; that performs login:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(angular) {
  var LoginFactory = function($resource) {
    return $resource(&#39;/login&#39;, {}, {
      login: {
        method: &#39;POST&#39;
      }
    });
  };

  LoginFactory.$inject = [&#39;$resource&#39;];
  angular.module(&#39;jwtDemo.services&#39;).factory(&#39;Login&#39;, LoginFactory);
}(angular));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will need two controllers in &lt;code&gt;app/controller.js&lt;/code&gt; - one for the login page to manage login and one for the profile page:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(angular) {
  var LoginController = function($scope, $localStorage, $http, $location, Login) {
    $scope.login = function(username, password) {
      new Login({username: username, password: password})
          .$login(function (profile, headers) {
            $localStorage.user = profile;
            $localStorage.token = headers().token;
            $http.defaults.headers.common.Authorization = &#39;Bearer &#39; + headers().token;
            $location.path(&amp;quot;/&amp;quot;);
          }, function (error) {
            console.log(error);
          });
    };

    $scope.logout = function () {
      delete $localStorage.user;
      delete $localStorage.token;
      $http.defaults.headers.common = {};
    }

    $scope.logout();
  };

  LoginController.$inject = [&#39;$scope&#39;, &#39;$localStorage&#39;, &#39;$http&#39;, &#39;$location&#39;,&#39;Login&#39;];
  angular.module(&amp;quot;jwtDemo.controllers&amp;quot;).controller(&amp;quot;LoginController&amp;quot;, LoginController);


  var ProfileController = function ($scope, $localStorage) {
    $scope.profile = $localStorage.user;
  };
  ProfileController.inject = [&#39;$scope&#39;, &#39;$localStorage&#39;];
  angular.module(&amp;quot;jwtDemo.controllers&amp;quot;).controller(&amp;quot;ProfileController&amp;quot;, ProfileController);
}(angular));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;LoginController&lt;/code&gt; has two methods - login and logout. The login method uses the &lt;code&gt;LoginService&lt;/code&gt; to make a request and saves the JWT and user profile returned up on successful login. It also sets the &lt;code&gt;Authorization&lt;/code&gt; header default to the JWT returned so that every subsequent request uses it to authenticate. The user is then navigated to the home page. Logout is performed by removing the JWT and profile from local storage and clearing the header defaults.&lt;/p&gt;
&lt;p&gt;The next step is to create &lt;code&gt;app/app.js&lt;/code&gt; to wire up the Angular application together:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(angular) {
  angular.module(&amp;quot;jwtDemo.controllers&amp;quot;, []);
  angular.module(&amp;quot;jwtDemo.services&amp;quot;, []);
  angular.module(&amp;quot;jwtDemo&amp;quot;, [&amp;quot;ui.router&amp;quot;, &amp;quot;ngResource&amp;quot;, &amp;quot;ngStorage&amp;quot;, &amp;quot;jwtDemo.controllers&amp;quot;, &amp;quot;jwtDemo.services&amp;quot;])
      .config(function ($stateProvider, $urlRouterProvider) {
        $urlRouterProvider.otherwise(&amp;quot;/&amp;quot;);

        $stateProvider
            .state(&#39;home&#39;, {
              url: &#39;/&#39;,
              templateUrl: &#39;home.html&#39;,
              controller: &#39;ProfileController&#39;
            })
            .state(&#39;signin&#39;, {
              url: &#39;/signin&#39;,
              templateUrl: &#39;signin.html&#39;,
              controller: &#39;LoginController&#39;
            })
            .state(&#39;signout&#39;, {
              url: &#39;/signout&#39;,
              templateUrl: &#39;signin.html&#39;,
              controller: &#39;LoginController&#39;
            });
      })
      .run(function ($localStorage, $http, $location, $rootScope) {
        if ($localStorage.user) {
          $http.defaults.headers.common.Authorization = &#39;Bearer &#39; + $localStorage.token;
        }

        $rootScope.$on(&#39;$locationChangeStart&#39;, function (event, next, current) {
          if ($location.path() !== &amp;quot;/signin&amp;quot; &amp;amp;&amp;amp; !$localStorage.user) {
            $location.path(&#39;/signin&#39;);
          } else if ($location.path() === &amp;quot;/signin&amp;quot; &amp;amp;&amp;amp; $localStorage.user) {
            $location.path(&#39;/&#39;);
          }
        });
      });
}(angular));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We start by wiring together our services and controllers to the main module. We use the state provider to map front end URLs to templates. The home page will use the &lt;code&gt;home.html&lt;/code&gt; template and the sign in and sign out URLs will use the &lt;code&gt;sigin.html&lt;/code&gt; template.&lt;/p&gt;
&lt;p&gt;It also configures a listener that observes for URL changes made by the user and redirects them to the sign in page, unless they are already authenticated. If there is already a token in local storage when the application loads, that signifies that the user has already logged in a different tab and the authorization header default is set.&lt;/p&gt;
&lt;p&gt;The two views we have are simple - &lt;code&gt;signin.html&lt;/code&gt; has a sign form:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&#39;col-md-3&#39;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-6&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;login-box well&amp;quot;&amp;gt;
      &amp;lt;form role=&amp;quot;form&amp;quot; ng-submit=&amp;quot;login(username, password)&amp;quot;&amp;gt;
        &amp;lt;legend&amp;gt;Sign In&amp;lt;/legend&amp;gt;
        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
          &amp;lt;label for=&amp;quot;username-email&amp;quot;&amp;gt;Username&amp;lt;/label&amp;gt;
          &amp;lt;input ng-model=&amp;quot;username&amp;quot; value=&#39;&#39; id=&amp;quot;username-email&amp;quot; placeholder=&amp;quot;Username&amp;quot; type=&amp;quot;text&amp;quot;
                 class=&amp;quot;form-control&amp;quot; /&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
          &amp;lt;label for=&amp;quot;password&amp;quot;&amp;gt;Password&amp;lt;/label&amp;gt;
          &amp;lt;input ng-model=&amp;quot;password&amp;quot; id=&amp;quot;password&amp;quot; value=&#39;&#39; placeholder=&amp;quot;Password&amp;quot; type=&amp;quot;password&amp;quot;
                 class=&amp;quot;form-control&amp;quot; /&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
          &amp;lt;input type=&amp;quot;submit&amp;quot; class=&amp;quot;btn btn-default btn-login-submit btn-block m-t-md&amp;quot; value=&amp;quot;Login&amp;quot; /&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&#39;col-md-3&#39;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The view for home page - &lt;code&gt;home.html&lt;/code&gt; renders a user profile:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;h1&amp;gt;Welcome, {{profile.name.first}}&amp;lt;/h1&amp;gt;
  &amp;lt;div class=&amp;quot;col-lg-3 col-sm-6&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;card hovercard&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;cardheader&amp;quot;&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;avatar&amp;quot;&amp;gt;
        &amp;lt;img alt=&amp;quot;&amp;quot; src=&amp;quot;{{profile.thumbnail}}&amp;quot;&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;info&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;title&amp;quot;&amp;gt;
          {{profile.username}}
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;desc&amp;quot;&amp;gt;{{profile.name.first}} {{profile.name.last}}&amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;a href=&amp;quot;/#/signout&amp;quot;&amp;gt;Sign Out&amp;lt;/a&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It also has a link for signing out. With this code in place, we can start our Spring application and sign in from the browser.&lt;/p&gt;
&lt;p&gt;This is the last of this series of blog posts on JWT and Spring. We built an API capable of authenticating with JWTs and a front end capable of authenticating against this API. The code for the complete example is available on &lt;a href=&#34;https://github.com/sdqali/jwt-demo&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JWT authentication with Spring Web - Part 4</title>
      <link>https://sadique.io/blog/2016/07/08/jwt-authentication-with-spring-web-part-4/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Fri, 08 Jul 2016 06:47:53 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/07/08/jwt-authentication-with-spring-web-part-4/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In parts 1 through 3 of this series, we built a Spring API that can issue a JWT when a user successfully authenticates. In this blog post, we will add the capability to verify the JWT presented by the client for subsequent requests.&lt;/p&gt;
&lt;p&gt;These are the blog posts in this series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/02/jwt-authentication-with-spring-web-part-1/&#34;&gt;Part 1&lt;/a&gt; - Discussion of JWT and implementation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/03/jwt-authentication-with-spring-web-part-2/&#34;&gt;Part 2&lt;/a&gt; - A Spring User Profiles API&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/05/jwt-authentication-with-spring-web-part-3/&#34;&gt;Part 3&lt;/a&gt; - Issuing a token from the server&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/07/jwt-authentication-with-spring-web-part-4/&#34;&gt;Part 4&lt;/a&gt; - Verifying the token sent back by the client&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/13/jwt-authentication-with-spring-web-part-5/&#34;&gt;Part 5&lt;/a&gt; - Securing the front end&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will start by configuring Spring security with a filter to capture the JWT passed by the client in the &lt;code&gt;Authorization&lt;/code&gt; header. We will wire up this filter to go before the &lt;code&gt;UsernamePasswordAuthenticationFilter&lt;/code&gt; provided by Spring security.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private JwtAuthFilter jwtAuthFilter;
    // ...

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();

        http.authorizeRequests()
                .antMatchers(&amp;quot;/login&amp;quot;)
                .permitAll()
                .antMatchers(&amp;quot;/**/*&amp;quot;)
                .hasAuthority(&amp;quot;ROLE_USER&amp;quot;)
                .and()
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                // ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The filter captures the &lt;code&gt;Authorization&lt;/code&gt; header and creates a &lt;code&gt;JwtAuthToken&lt;/code&gt; and sets that as the current authentication for the request.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class JwtAuthFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest servletRequest = (HttpServletRequest) request;
        String authorization = servletRequest.getHeader(&amp;quot;Authorization&amp;quot;);
        if (authorization != null) {
            JwtAuthToken token = new JwtAuthToken(authorization.replaceAll(&amp;quot;Bearer &amp;quot;, &amp;quot;&amp;quot;));
            SecurityContextHolder.getContext().setAuthentication(token);
        }
        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;JwtAuthToken&lt;/code&gt; is simply a conduit to carry the token and although it implements the &lt;code&gt;Authentication&lt;/code&gt; interface, it does not do much.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JwtAuthToken implements Authentication {
    private final String token;

    public JwtAuthToken(String token) {
        this.token = token;
    }

    @Override
    public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities() {
        return null;
    }

    @Override
    public Object getCredentials() {
        return token;
    }

    @Override
    public Object getDetails() {
        return null;
    }

    @Override
    public Object getPrincipal() {
        return null;
    }

    @Override
    public boolean isAuthenticated() {
        return false;
    }

    @Override
    public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException {

    }

    @Override
    public String getName() {
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point, we need to tell Spring Security how to verify the tokens. This can be done by providing a custom &lt;code&gt;AuthenticationProvider&lt;/code&gt;. This can be done by overriding the &lt;code&gt;configure&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private JwtAuthenticationProvider jwtAuthenticationProvider;

    // ...
    @Override
    public void configure(AuthenticationManagerBuilder auth)  throws Exception {
        auth.authenticationProvider(jwtAuthenticationProvider);
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;JwtAuthenticationProvider&lt;/code&gt; receives the &lt;code&gt;Authentication&lt;/code&gt; instance set on the &lt;code&gt;SecurityContext&lt;/code&gt;, which in our case is the &lt;code&gt;JwtAuthToken&lt;/code&gt; we set using the &lt;code&gt;JwtAuthFilter&lt;/code&gt;. This token is then verified using the &lt;code&gt;JwtService&lt;/code&gt;. If the token is valid, we return a &lt;code&gt;JwtAuthenticatedProfile&lt;/code&gt; or throw an exception if it is invalid.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class JwtAuthenticationProvider implements AuthenticationProvider {
    private final JwtService jwtService;

    @SuppressWarnings(&amp;quot;unused&amp;quot;)
    public JwtAuthenticationProvider() {
        this(null);
    }

    @Autowired
    public JwtAuthenticationProvider(JwtService jwtService) {
        this.jwtService = jwtService;
    }

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        try {
            Optional&amp;lt;MinimalProfile&amp;gt; possibleProfile = jwtService.verify((String) authentication.getCredentials());
            return new JwtAuthenticatedProfile(possibleProfile.get());
        } catch (Exception e) {
            throw new JwtAuthenticationException(&amp;quot;Failed to verify token&amp;quot;, e);
        }
    }

    @Override
    public boolean supports(Class&amp;lt;?&amp;gt; authentication) {
        return JwtAuthToken.class.equals(authentication);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;JwtAuthenticatedProfile&lt;/code&gt; is another implementation of &lt;code&gt;Authentication&lt;/code&gt; that wraps the user&amp;rsquo;s profile information:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JwtAuthenticatedProfile implements Authentication {

    private final MinimalProfile minimalProfile;

    public JwtAuthenticatedProfile(MinimalProfile minimalProfile) {
        this.minimalProfile = minimalProfile;
    }

    @Override
    public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority(&amp;quot;ROLE_USER&amp;quot;));
    }

    @Override
    public Object getCredentials() {
        return null;
    }

    @Override
    public Object getDetails() {
        return null;
    }

    @Override
    public Object getPrincipal() {
        return null;
    }

    @Override
    public boolean isAuthenticated() {
        return true;
    }

    @Override
    public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException {

    }

    @Override
    public String getName() {
        return minimalProfile.getUsername();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we implement the verify functionality in &lt;code&gt;JwtService&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public Optional&amp;lt;MinimalProfile&amp;gt; verify(String token) throws IOException, URISyntaxException {
        byte[] secretKey = secretKeyProvider.getKey();
        Jws&amp;lt;Claims&amp;gt; claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);
        return profileService.minimal(claims.getBody().getSubject().toString());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we generated the JWT, we had set the username as the JWT subject.&lt;/p&gt;
&lt;p&gt;The last thing to do is to ensure that we handle exceptions that occur during token verification gracefully. Since the token verification is happening outside controllers, we won&amp;rsquo;t be able to leverage &lt;code&gt;ControllerAdvice&lt;/code&gt; to handle exceptions. This is where Spring Security&amp;rsquo;s &lt;code&gt;AuthenticationEntryPoint&lt;/code&gt; comes in to play. We will configure a custom &lt;code&gt;AuthenticationEntryPoint&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        http.authorizeRequests()
                .antMatchers(&amp;quot;/login&amp;quot;, &amp;quot;/bower_components/**/*&amp;quot;, &amp;quot;/app/**/*&amp;quot;, &amp;quot;/index.html&amp;quot;)
                .permitAll()
                .antMatchers(&amp;quot;/**/*&amp;quot;)
                .hasAuthority(&amp;quot;ROLE_USER&amp;quot;)
                .and()
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling()
                .authenticationEntryPoint(jwtAuthEndPoint);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our entry point, sets the HTTP status to &lt;code&gt;403&lt;/code&gt;, and sets the response body to a JSON showing the error.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e)
            throws IOException, ServletException {
        httpServletResponse.setStatus(SC_FORBIDDEN);
        httpServletResponse.setContentType(MediaType.APPLICATION_JSON_VALUE);

        String message;
        if(e.getCause() != null) {
            message = e.getCause().getMessage();
        } else {
            message = e.getMessage();
        }
        byte[] body = new ObjectMapper()
                .writeValueAsBytes(Collections.singletonMap(&amp;quot;error&amp;quot;, message));
        httpServletResponse.getOutputStream().write(body);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this configuration in place, we can request a token and make a subsequent request with the received JWT.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl -i -X POST &amp;quot;http://localhost:8080/login&amp;quot; -d &#39;{&amp;quot;username&amp;quot;:&amp;quot;greenrabbit948&amp;quot;, &amp;quot;password&amp;quot;:&amp;quot;celeste&amp;quot;}&#39; --header &amp;quot;Content-Type: application/json&amp;quot;
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Frame-Options: DENY
Token: eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJncmVlbnJhYmJpdDk0OCIsImV4cCI6MTQ2ODE0MDg1MiwiaXNzIjoiaW4uc2RxYWxpLmp3dCJ9.t9pqrOmYfaVkzuAQgo4D4VbN2PibQuHPuPA6RKYU-keTzbFAX58l77hQTc4Cq28HpjFOeiDvNpNEgilNHFOfVA
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Sun, 10 Jul 2016 06:54:12 GMT

{&amp;quot;username&amp;quot;:&amp;quot;greenrabbit948&amp;quot;,&amp;quot;name&amp;quot;:{&amp;quot;title&amp;quot;:&amp;quot;miss&amp;quot;,&amp;quot;first&amp;quot;:&amp;quot;dionaura&amp;quot;,&amp;quot;last&amp;quot;:&amp;quot;rodrigues&amp;quot;},&amp;quot;thumbnail&amp;quot;:&amp;quot;https://randomuser.me/api/portraits/thumb/women/78.jpg&amp;quot;}

$ curl -s &amp;quot;http://localhost:8080/profile/details/yellowfrog347&amp;quot; --header &amp;quot;Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJncmVlbnJhYmJpdDk0OCIsImV4cCI6MTQ2ODE0MDg1MiwiaXNzIjoiaW4uc2RxYWxpLmp3dCJ9.t9pqrOmYfaVkzuAQgo4D4VbN2PibQuHPuPA6RKYU-keTzbFAX58l77hQTc4Cq28HpjFOeiDvNpNEgilNHFOfVA&amp;quot; | jq .
{
  &amp;quot;picture&amp;quot;: {
    &amp;quot;large&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/women/71.jpg&amp;quot;,
    &amp;quot;medium&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/med/women/71.jpg&amp;quot;,
    &amp;quot;thumbnail&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/thumb/women/71.jpg&amp;quot;
  },
  &amp;quot;name&amp;quot;: {
    &amp;quot;title&amp;quot;: &amp;quot;ms&amp;quot;,
    &amp;quot;first&amp;quot;: &amp;quot;sofia&amp;quot;,
    &amp;quot;last&amp;quot;: &amp;quot;hansen&amp;quot;
  },
  &amp;quot;email&amp;quot;: &amp;quot;sofia.hansen@example.com&amp;quot;,
  &amp;quot;username&amp;quot;: &amp;quot;yellowfrog347&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we were to make a request with an invalid JWT, we will receive an error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl -s &amp;quot;http://localhost:8080/profile/details/yellowfrog347&amp;quot; --header &amp;quot;Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJncmVlbnJhYmJpdDk0OCIsImV4cCI6MTQ2ODE0MDg1MiwiaXNzIjoiaW4uc2RxYWxpLmp3dCJ9.t9pqrOmYfaVkzuAQgo4D4VbN2PibQuHPuPA6RKYU-keTzbFAX58l77hQTc4Cq28HpjFOeiDvNpNEgilNHFOfVAAAAAA&amp;quot; | jq .
{
  &amp;quot;error&amp;quot;: &amp;quot;JWT signature does not match locally computed signature. JWT validity cannot be asserted and should not be trusted.&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the next blog post, the fifth is this series, we will move on to building the front end with Angular JS and managing authentication from the front end. The source code for this example for the progress made from part 1 through part 4 is available on &lt;a href=&#34;https://github.com/sdqali/jwt-demo/tree/verify_tokens&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JWT authentication with Spring Web - Part 3</title>
      <link>https://sadique.io/blog/2016/07/06/jwt-authentication-with-spring-web-part-3/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Wed, 06 Jul 2016 05:30:53 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/07/06/jwt-authentication-with-spring-web-part-3/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;https://sadique.io/blog/2016/07/03/jwt-authentication-with-spring-web-part-2/&#34;&gt;previous blog post&lt;/a&gt;, we built the Spring API that responds with Profile information. Continuing on the path to building authentication with JWT, in this blog post, we will create a login mechanism that issues a JWT when the user presents the correct credentials.&lt;/p&gt;
&lt;p&gt;These are the blog posts in this series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/02/jwt-authentication-with-spring-web-part-1/&#34;&gt;Part 1&lt;/a&gt; - Discussion of JWT and implementation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/03/jwt-authentication-with-spring-web-part-2/&#34;&gt;Part 2&lt;/a&gt; - A Spring User Profiles API&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/05/jwt-authentication-with-spring-web-part-3/&#34;&gt;Part 3&lt;/a&gt; - Issuing a token from the server&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/07/jwt-authentication-with-spring-web-part-4/&#34;&gt;Part 4&lt;/a&gt; - Verifying the token sent back by the client&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/13/jwt-authentication-with-spring-web-part-5/&#34;&gt;Part 5&lt;/a&gt; - Securing the front end&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our fist step is to configure Spring Security to allow access to the login end point we will be building. This can be done as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().ignoringAntMatchers(&amp;quot;/login&amp;quot;);

        http.authorizeRequests()
                .antMatchers(&amp;quot;/login&amp;quot;)
                .permitAll()
                .antMatchers(&amp;quot;/**/*&amp;quot;)
                .denyAll();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are turning off authentication and CSRF token checking for the &lt;code&gt;/login&lt;/code&gt; end point.&lt;/p&gt;
&lt;p&gt;Next, we build a &lt;code&gt;LoginController&lt;/code&gt; to issue tokens up on a user presenting valid credentials:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(path = &amp;quot;/login&amp;quot;)
public class LoginController {

    private final LoginService loginService;
    private final JwtService jwtService;

    @SuppressWarnings(&amp;quot;unused&amp;quot;)
    public LoginController() {
        this(null, null);
    }

    @Autowired
    public LoginController(LoginService loginService, JwtService jwtService) {
        this.loginService = loginService;
        this.jwtService = jwtService;
    }

    @RequestMapping(path = &amp;quot;&amp;quot;,
            method = POST,
            produces = APPLICATION_JSON_VALUE)
    public MinimalProfile login(@RequestBody LoginCredentials credentials,
                                HttpServletResponse response) {
        return loginService.login(credentials)
                .map(minimalProfile -&amp;gt; {
                    try {
                        response.setHeader(&amp;quot;Token&amp;quot;, jwtService.tokenFor(minimalProfile));
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                    return minimalProfile;
                })
                .orElseThrow(() -&amp;gt; new FailedToLoginException(credentials.getUsername()));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use the login service to verify the credentials and it returns an &lt;code&gt;Optional&amp;lt;MinimalProfile&amp;gt;&lt;/code&gt;. If there is a valid &lt;code&gt;MinimalProfile&lt;/code&gt;, we ask the &lt;code&gt;JwtService&lt;/code&gt; to issue a token.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;LoginService&lt;/code&gt; uses the &lt;code&gt;ProfileService&lt;/code&gt; to load a profile matching the user name and the password presented by the user.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class LoginService {

    private ProfileService profileService;

    @SuppressWarnings(&amp;quot;unused&amp;quot;)
    public LoginService() {
        this(null);
    }

    @Autowired
    public LoginService(ProfileService profileService) {
        this.profileService = profileService;
    }

    public Optional&amp;lt;MinimalProfile&amp;gt; login(LoginCredentials credentials) {
        return profileService.get(credentials.getUsername())
                .filter(profile -&amp;gt; profile.getLogin().getPassword().equals(credentials.getPassword()))
                .map(profile -&amp;gt; new MinimalProfile(profile));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Please note that in real applications, you never want to do this. You should be comparing the hashed version of the password presented by the user with the hashed version of the password stored in the database.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;JwtService&lt;/code&gt; creates a token using the profile information and an expiration date of 2 hours with the &lt;code&gt;HMASHA256&lt;/code&gt; algorithm. It uses the key provided by &lt;code&gt;SecretKeyProvider&lt;/code&gt;. For creating the JWT token, we use the excellent jjwt &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; library we introduced in &lt;a href=&#34;https://sadique.io/blog/2016/07/02/jwt-authentication-with-spring-web-part-1/&#34;&gt;part 1&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class JwtService {
    private static final String ISSUER = &amp;quot;in.sdqali.jwt&amp;quot;;
    private SecretKeyProvider secretKeyProvider;

    @SuppressWarnings(&amp;quot;unused&amp;quot;)
    public JwtService() {
        this(null);
    }

    @Autowired
    public JwtService(SecretKeyProvider secretKeyProvider) {
        this.secretKeyProvider = secretKeyProvider;
    }

    public String tokenFor(MinimalProfile minimalProfile) throws IOException, URISyntaxException {
        byte[] secretKey = secretKeyProvider.getKey();
        Date expiration = Date.from(LocalDateTime.now().plusHours(2).toInstant(UTC));
        return Jwts.builder()
                .setSubject(minimalProfile.getUsername())
                .setExpiration(expiration)
                .setIssuer(ISSUER)
                .signWith(SignatureAlgorithm.HS512, secretKey)
                .compact();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;SecretKeyProvider&lt;/code&gt; in this example will simply load the secret key from a file, where it is stored in plain text. In a real application, you may store and encrypted version of it and decrypt it when required.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class SecretKeyProvider {
    public byte[] getKey() throws URISyntaxException, IOException {
        return Files.readAllBytes(Paths.get(this.getClass().getResource(&amp;quot;/jwt.key&amp;quot;).toURI()));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this code, a client can authenticate and receive a JWT. When request is made with correct username and password:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl -v -X POST &amp;quot;http://localhost:8080/login&amp;quot; -d &#39;{&amp;quot;username&amp;quot;:&amp;quot;greenrabbit948&amp;quot;, &amp;quot;password&amp;quot;:&amp;quot;celeste&amp;quot;}&#39; --header &amp;quot;Content-Type: application/json&amp;quot;   | jq .
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying ::1...
* Connected to localhost (::1) port 8080 (#0)
&amp;gt; POST /login HTTP/1.1
&amp;gt; Host: localhost:8080
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt; Content-Type: application/json
&amp;gt; Content-Length: 51
&amp;gt;
} [51 bytes data]
* upload completely sent off: 51 out of 51 bytes
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Server: Apache-Coyote/1.1
&amp;lt; X-Content-Type-Options: nosniff
&amp;lt; X-XSS-Protection: 1; mode=block
&amp;lt; Cache-Control: no-cache, no-store, max-age=0, must-revalidate
&amp;lt; Pragma: no-cache
&amp;lt; Expires: 0
&amp;lt; X-Frame-Options: DENY
&amp;lt; Token: eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJqd3QtZGVtbyIsImV4cCI6MTQ2Nzc2Njk3MSwiaXNzIjoiaW4uc2RxYWxpLmp3dCJ9.eu_OuBIkc4BfcTsTu4t_6TCwyLkH4HcuQzvWIMzNQYdxXiWA77SfvwCe4mdc7C17mXdtBAsvFGDj7A9fzI0M1w
&amp;lt; Content-Type: application/json;charset=UTF-8
&amp;lt; Transfer-Encoding: chunked
&amp;lt; Date: Wed, 06 Jul 2016 06:02:51 GMT
&amp;lt;
{ [164 bytes data]
100   211    0   160  100    51  15071   4804 --:--:-- --:--:-- --:--:-- 16000
* Connection #0 to host localhost left intact
{
  &amp;quot;username&amp;quot;: &amp;quot;greenrabbit948&amp;quot;,
  &amp;quot;name&amp;quot;: {
    &amp;quot;title&amp;quot;: &amp;quot;miss&amp;quot;,
    &amp;quot;first&amp;quot;: &amp;quot;dionaura&amp;quot;,
    &amp;quot;last&amp;quot;: &amp;quot;rodrigues&amp;quot;
  },
  &amp;quot;thumbnail&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/thumb/women/78.jpg&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see the &lt;code&gt;Token&lt;/code&gt; header has value &lt;code&gt;eyJhbGciOiJIUzUxMiJ9. eyJzdWIiOiJqd3QtZGVtbyIsImV4cCI6MTQ2Nzc2Njk3MSwiaXNzIjoiaW4uc2RxYWxpLmp3dCJ9. eu_OuBIkc4BfcTsTu4t_6TCwyLkH4HcuQzvWIMzNQYdxXiWA77SfvwCe4mdc7C17mXdtBAsvFGDj 7A9fzI0M1w&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If we were to present invalid credentials, the API will return a &lt;code&gt;401&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl -i -X POST &amp;quot;http://localhost:8080/login&amp;quot; -d &#39;{&amp;quot;username&amp;quot;:&amp;quot;greenrabbit948&amp;quot;, &amp;quot;password&amp;quot;:&amp;quot;wrongpassword&amp;quot;}&#39; --header &amp;quot;Content-Type: application/json&amp;quot;
HTTP/1.1 401 Unauthorized
Server: Apache-Coyote/1.1
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Frame-Options: DENY
Content-Length: 0
Date: Wed, 06 Jul 2016 06:05:46 GMT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the next blog post, the fourth is this series, we will move on to verifying the token presented by the client for subsequent requests. The source code for this example for the progress made from part 1 through part 3 is available on &lt;a href=&#34;https://github.com/sdqali/jwt-demo/tree/09b02336e4b7c746cb4c134dc020243aef827b66&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;jjwt - Java JWT: JSON Web Token for Java and Android, available on &lt;a href=&#34;https://github.com/jwtk/jjwt&#34;&gt;GitHub&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>JWT authentication with Spring Web - Part 2</title>
      <link>https://sadique.io/blog/2016/07/03/jwt-authentication-with-spring-web-part-2/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sun, 03 Jul 2016 16:22:53 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/07/03/jwt-authentication-with-spring-web-part-2/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;https://sadique.io/blog/2016/07/02/jwt-authentication-with-spring-web-part-1/&#34;&gt;previous blog post&lt;/a&gt; in this series, we looked at the basics of JWT. We will move on to building the Spring API that we will use JWT for authentication in this blog post.&lt;/p&gt;
&lt;p&gt;These are the blog posts in this series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/02/jwt-authentication-with-spring-web-part-1/&#34;&gt;Part 1&lt;/a&gt; - Discussion of JWT and implementation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/03/jwt-authentication-with-spring-web-part-2/&#34;&gt;Part 2&lt;/a&gt; - A Spring User Profiles API&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/05/jwt-authentication-with-spring-web-part-3/&#34;&gt;Part 3&lt;/a&gt; - Issuing a token from the server&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/07/jwt-authentication-with-spring-web-part-4/&#34;&gt;Part 4&lt;/a&gt; - Verifying the token sent back by the client&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/13/jwt-authentication-with-spring-web-part-5/&#34;&gt;Part 5&lt;/a&gt; - Securing the front end&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;the-api&#34;&gt;The API&lt;/h2&gt;
&lt;p&gt;The API we will be using in the example gives access to user profiles. It has the following end points:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET /profiles/{:username}&lt;/li&gt;
&lt;li&gt;GET /profiles/details/{:username}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The profiles that we use for this example were generated using the &lt;a href=&#34;https://randomuser.me/&#34;&gt;Random User Generator&lt;/a&gt; and stored in a JSON file, for convenience for this example. In the real world, you never want to store user information in a file. All the code for this example is available on &lt;a href=&#34;https://github.com/sdqali/jwt-demo&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;structure-of-the-user-profile&#34;&gt;Structure of the User Profile&lt;/h2&gt;
&lt;p&gt;For this example, I specifically generated 500 random profiles with only a subset of fields - &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, &lt;code&gt;login&lt;/code&gt; and &lt;code&gt;picture&lt;/code&gt;. With these fields, a profile has the following structure:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot;: {
    &amp;quot;title&amp;quot;: &amp;quot;mr&amp;quot;,
    &amp;quot;first&amp;quot;: &amp;quot;matt&amp;quot;,
    &amp;quot;last&amp;quot;: &amp;quot;hahn&amp;quot;
  },
  &amp;quot;email&amp;quot;: &amp;quot;matt.hahn@example.com&amp;quot;,
  &amp;quot;login&amp;quot;: {
    &amp;quot;username&amp;quot;: &amp;quot;greenostrich307&amp;quot;,
    &amp;quot;password&amp;quot;: &amp;quot;darkange&amp;quot;,
    &amp;quot;salt&amp;quot;: &amp;quot;V5xi38lN&amp;quot;,
    &amp;quot;md5&amp;quot;: &amp;quot;cba0d5fb77ae3e0dbe177b9624df5ceb&amp;quot;,
    &amp;quot;sha1&amp;quot;: &amp;quot;5f22fdcc79affdef604d89b64b7db599ed454c5e&amp;quot;,
    &amp;quot;sha256&amp;quot;: &amp;quot;23afb0983e874169669f96cd72b69234aef4cf54a86f89a25e14e91941ac95a2&amp;quot;
  },
  &amp;quot;picture&amp;quot;: {
    &amp;quot;large&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/men/20.jpg&amp;quot;,
    &amp;quot;medium&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/med/men/20.jpg&amp;quot;,
    &amp;quot;thumbnail&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/thumb/men/20.jpg&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point, you can see the password and hash in there. As I explained above, you &lt;em&gt;do not&lt;/em&gt; want to do this in a real application. As such, this example focuses on JWT and we are doing this purely for convenience.&lt;/p&gt;
&lt;h2 id=&#34;the-data-models&#34;&gt;The data models&lt;/h2&gt;
&lt;p&gt;The models for representing the data provided from the random user generator are as follows. We will be using the Lombok &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;code&gt;@Data&lt;/code&gt; annotation to stay away from having to write explicit setters and getters.&lt;/p&gt;
&lt;h3 id=&#34;profile&#34;&gt;Profile&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import lombok.Data;

@Data
public class Profile {
    private Name name;
    private String email;
    private Login login;
    private Picture picture;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;name&#34;&gt;Name&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data
public class Name {
    private String title;
    private String first;
    private String last;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;login&#34;&gt;Login&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data
public class Login {
    String username;
    String password;
    String salt;
    String md5;
    String sha1;
    String sha256;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;picture&#34;&gt;Picture&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data
public class Picture {
    private URL large;
    private URL medium;
    private URL thumbnail;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will also create two other data models that expose a minimal set of profile information without the credentials.&lt;/p&gt;
&lt;h3 id=&#34;minimalprofile&#34;&gt;MinimalProfile&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data
public class MinimalProfile {
    private final String username;
    private final Name name;
    private final URL thumbnail;

    public MinimalProfile(Profile profile) {
        name = profile.getName();
        username = profile.getLogin().getUsername();
        thumbnail = profile.getPicture().getThumbnail();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;detailedprofile&#34;&gt;DetailedProfile&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data
public class DetailedProfile {

    private final Picture picture;
    private final Name name;
    private final String email;
    private final String username;

    public DetailedProfile(Profile profile) {
        name = profile.getName();
        email = profile.getEmail();
        picture = profile.getPicture();
        username = profile.getLogin().getUsername();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;the-controllers&#34;&gt;The Controllers&lt;/h2&gt;
&lt;p&gt;The code for the API&amp;rsquo;s controller is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(path = &amp;quot;/profile&amp;quot;)
public class ProfileController {

    private final ProfileService profileService;

    @SuppressWarnings(&amp;quot;unused&amp;quot;)
    public ProfileController() {
        this(null);
    }

    @Autowired
    public ProfileController(ProfileService profileService) {
        this.profileService = profileService;
    }

    @RequestMapping(path = &amp;quot;/{username}&amp;quot;,
            method = GET,
            produces = APPLICATION_JSON_VALUE)
    public MinimalProfile minimal(@PathVariable String username) {
        return profileService.minimal(username)
                .orElseThrow(() -&amp;gt; new ProfileNotFoundException(username));
    }

    @RequestMapping(path = &amp;quot;/details/{username}&amp;quot;,
            method = GET,
            produces = APPLICATION_JSON_VALUE)
    public DetailedProfile details(@PathVariable String username) {
        return profileService.detailed(username)
                .orElseThrow(() -&amp;gt; new ProfileNotFoundException(username));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It delegates querying for profiles to the &lt;code&gt;ProfileService&lt;/code&gt; and throws exceptions if a Profile is not present. Notice the use of Java&amp;rsquo;s &lt;code&gt;Optional&lt;/code&gt; to throw exceptions.&lt;/p&gt;
&lt;h3 id=&#34;the-profileservice&#34;&gt;The ProfileService&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class ProfileService {
    private final List&amp;lt;Profile&amp;gt; profiles;

    private final Path PROFILES_FILE = Paths.get(this.getClass().getResource(&amp;quot;/profiles.json&amp;quot;).toURI());

    public ProfileService() throws IOException, URISyntaxException {
        ObjectMapper objectMapper = new ObjectMapper();
        profiles = objectMapper.readValue(PROFILES_FILE.toFile(), new TypeReference&amp;lt;List&amp;lt;Profile&amp;gt;&amp;gt;() {
        });
    }

    protected Optional&amp;lt;Profile&amp;gt; get(String username) {
        return profiles.stream()
                .filter(profile -&amp;gt; profile.getLogin().getUsername().equals(username))
                .findFirst();
    }

    public Optional&amp;lt;MinimalProfile&amp;gt; minimal(String username) {
        return get(username).map(profile -&amp;gt; new MinimalProfile(profile));
    }

    public Optional&amp;lt;DetailedProfile&amp;gt; detailed(String username) {
        return get(username).map(profile -&amp;gt; new DetailedProfile(profile));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exception-handling&#34;&gt;Exception Handling&lt;/h3&gt;
&lt;p&gt;We will also need to wire up a &lt;code&gt;ControllerAdvice&lt;/code&gt; to handle exceptions appropriately:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
@ControllerAdvice
public class GlobalExceptionHandler {
    @ResponseStatus(NOT_FOUND)
    @ExceptionHandler(ProfileNotFoundException.class)
    public void profileNotFound() {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this, you should have a profile service up and running.&lt;/p&gt;
&lt;h3 id=&#34;minimal-profile&#34;&gt;Minimal profile&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ curl -s &amp;quot;http://localhost:8080/profile/yellowfrog347&amp;quot; | jq .
{
  &amp;quot;username&amp;quot;: &amp;quot;yellowfrog347&amp;quot;,
  &amp;quot;name&amp;quot;: {
    &amp;quot;title&amp;quot;: &amp;quot;ms&amp;quot;,
    &amp;quot;first&amp;quot;: &amp;quot;sofia&amp;quot;,
    &amp;quot;last&amp;quot;: &amp;quot;hansen&amp;quot;
  },
  &amp;quot;thumbnail&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/thumb/women/71.jpg&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;detailed-profile&#34;&gt;Detailed Profile&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ curl -s &amp;quot;http://localhost:8080/profile/details/yellowfrog347&amp;quot; | jq .
{
  &amp;quot;picture&amp;quot;: {
    &amp;quot;large&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/women/71.jpg&amp;quot;,
    &amp;quot;medium&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/med/women/71.jpg&amp;quot;,
    &amp;quot;thumbnail&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/thumb/women/71.jpg&amp;quot;
  },
  &amp;quot;name&amp;quot;: {
    &amp;quot;title&amp;quot;: &amp;quot;ms&amp;quot;,
    &amp;quot;first&amp;quot;: &amp;quot;sofia&amp;quot;,
    &amp;quot;last&amp;quot;: &amp;quot;hansen&amp;quot;
  },
  &amp;quot;email&amp;quot;: &amp;quot;sofia.hansen@example.com&amp;quot;,
  &amp;quot;username&amp;quot;: &amp;quot;yellowfrog347&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code for the application so far can be found &lt;a href=&#34;https://github.com/sdqali/jwt-demo/tree/4f1da432a51fb8c88fc21a6fad895e03ca3611d9&#34;&gt;here&lt;/a&gt;. In the next blog post of the series, we will wire up Spring Security and build a login feature that issues a JWT after successful login.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://projectlombok.org/index.html&#34;&gt;Project Lombok&lt;/a&gt; is a Java library that helps minimize boiler plate code by replacing them with a set of convenient annotations. I tend to use it when I have to build data objects.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>JWT authentication with Spring Web - Part 1</title>
      <link>https://sadique.io/blog/2016/07/03/jwt-authentication-with-spring-web-part-1/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sun, 03 Jul 2016 01:42:04 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/07/03/jwt-authentication-with-spring-web-part-1/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;meta content=&#34;jwt authentication example&#34; name=&#34;keywords&#34;&gt;
JSON Web Tokens (JWTs) are signed tokens issued by a server that it can use to verify a claim made by a client. This blog post is the first in a series where I implement authentication based on JWT in a Spring Web application with an Angular JS front end.
&lt;p&gt;These are the blog posts in this series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/02/jwt-authentication-with-spring-web-part-1/&#34;&gt;Part 1&lt;/a&gt; - Discussion of JWT and implementation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/03/jwt-authentication-with-spring-web-part-2/&#34;&gt;Part 2&lt;/a&gt; - A Spring User Profiles API&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/05/jwt-authentication-with-spring-web-part-3/&#34;&gt;Part 3&lt;/a&gt; - Issuing a token from the server&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/07/jwt-authentication-with-spring-web-part-4/&#34;&gt;Part 4&lt;/a&gt; - Verifying the token sent back by the client&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/13/jwt-authentication-with-spring-web-part-5/&#34;&gt;Part 5&lt;/a&gt; - Securing the front end&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;what-is-jwt&#34;&gt;What is JWT?&lt;/h2&gt;
&lt;p&gt;The official JWT &lt;a href=&#34;https://jwt.io/&#34;&gt;website&lt;/a&gt; defines JWT as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A &lt;code&gt;JWT&lt;/code&gt; contains 3 parts - a &lt;code&gt;header&lt;/code&gt;, a &lt;code&gt;payload&lt;/code&gt; and a &lt;code&gt;signature&lt;/code&gt;. A &lt;code&gt;JWT&lt;/code&gt; can in turn be represented as a &lt;code&gt;JWS&lt;/code&gt; or &lt;code&gt;JWE&lt;/code&gt;. &lt;code&gt;JWS&lt;/code&gt; stands for JSON Web Signature as defined in RFC 7515 and &lt;code&gt;JWE&lt;/code&gt; stands for JSON Web Encryption defined by RFC 7516. In a &lt;code&gt;JWS&lt;/code&gt;, the payload being sent is not encrypted, whereas it is encrypted in a &lt;code&gt;JWE&lt;/code&gt; &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. This blog post will deal only with &lt;code&gt;JWS&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;structure-of-a-jwt&#34;&gt;Structure of a JWT&lt;/h2&gt;
&lt;p&gt;A JWT has the following structure:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;base64(header) + &amp;quot;.&amp;quot; + base64(payload) + &amp;quot;.&amp;quot; + signature(header, payload, key)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The signature itself is generated by signing the header and payload with a key, for example using the HMAC-SHA256 algorithm:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HMASHA256(base64(header) + &amp;quot;.&amp;quot; + base64(payload), key)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A JWT header is a JSON object that typically has the following values:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;alg&lt;/code&gt; - The algorithm used for signing the token.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typ&lt;/code&gt; - This optional parameter, set to &lt;code&gt;JWT&lt;/code&gt; declares this JSON object as a JWT.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An example JWT header when the algorithm used is HMA-SHA256:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;alg&amp;quot;: &amp;quot;HM256&amp;quot;,
    &amp;quot;typ&amp;quot;: &amp;quot;JWT&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A JWT payload contains a series of &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4&#34;&gt;claims&lt;/a&gt;. There is an IANA &amp;ldquo;JSON Web Token Claims&amp;rdquo; registry that has a number of claim names reserved for specific purposes. Applications are free to use any other names, except these for their claims. Claim names that are important include &lt;code&gt;exp&lt;/code&gt; that represents the expiration time on or after which the JWT MUST NOT be accepted for processing. The following payload sets issuer, expiry date and a username.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;exp&amp;quot;: 1467509846,
  &amp;quot;iss&amp;quot;: &amp;quot;in.sdqali.jwt&amp;quot;,
  &amp;quot;username&amp;quot;: &amp;quot;greenrabbit948&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;generating-a-jwt&#34;&gt;Generating a JWT&lt;/h2&gt;
&lt;p&gt;For the header and payload shown above, if we were to generate a JWT with the HMAC256 algorithm and key &lt;code&gt;secretKey&lt;/code&gt;, it will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* Header - eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
* Payload - eyJleHAiOjE0Njc1MDk4NDYsImlzcyI6ImluLnNkcWFsaS5qd3QiLCJ1c2VybmFtZSI6ImdyZWVucmFiYml0OTQ4In0
* Signature - rStkUmx0SRWjBxKFVF2-lwwZNxlkGRJ4uH49TCIIN7o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The end token will have the following form:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0Njc1MDk4NDYsImlzcyI6ImluLnNkcWFsaS5qd3QiLCJ1c2VybmFtZSI6ImdyZWVucmFiYml0OTQ4In0.rStkUmx0SRWjBxKFVF2-lwwZNxlkGRJ4uH49TCIIN7o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I have been implementing the JWT RFC to learn about it and it was fairly straight forward. I did the token generation part and did not finish the token verification part. The code for that exercise can be found &lt;a href=&#34;https://github.com/sdqali/jwt&#34;&gt;here&lt;/a&gt;. A more complete implementation of the RFC for the JVM is &lt;a href=&#34;https://github.com/jwtk/jjwt&#34;&gt;jjwt&lt;/a&gt; and the rest of the series will be using that implementation. The JWT website has a &lt;a href=&#34;https://jwt.io/#debugger&#34;&gt;debugger&lt;/a&gt; that allows for creation and verification of tokens.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;A detailed explanation of the differences between JWS and JWE can be found &lt;a href=&#34;https://securedb.co/community/jwt-vs-jws-vs-jwe/&#34;&gt;here&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>

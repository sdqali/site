<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sql on {code that works}</title>
    <link>https://sadique.io/tags/sql/?utm_source=site&amp;utm_medium=feed</link>
    <description>Recent content in Sql on {code that works}</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 09 May 2019 17:10:23 -0700</lastBuildDate>
    <atom:link href="https://sadique.io/tags/sql/?utm_source=site&amp;utm_medium=feed" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Looking up Enum types and values in Postgres</title>
      <link>https://sadique.io/blog/2019/05/09/looking-up-enum-types-and-values-in-postgres/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Thu, 09 May 2019 17:10:23 -0700</pubDate>
      
      <guid>https://sadique.io/blog/2019/05/09/looking-up-enum-types-and-values-in-postgres/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In this blog post, we will explore how Postgres stores Enum types and how to query for Enum types and their values. Postgres&amp;rsquo; Enum, like their counterparts in many programming languags are data types that allow only a predefined set of values to be assigned to them. An interesting difference is that compared to programming languages, Postgres does allow blanks within the values of Enums.&lt;/p&gt;
&lt;p&gt;Postgres Enums are created using the &lt;code&gt;CREATE TYPE&lt;/code&gt; statement. The values are ordered in the order in which they are specified in the &lt;code&gt;CREATE&lt;/code&gt; statement.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; CREATE TYPE weather AS ENUM (
  &#39;sunny&#39;, &#39;rainy&#39;, &#39;cloudy&#39;, &#39;snow&#39;
  );

CREATE TYPE

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Postgres stores Enums in the &lt;code&gt;pg_type&lt;/code&gt; catalog. This catalog assigns a &lt;code&gt;typcategory&lt;/code&gt; to every type and Enums &lt;a href=&#34;https://www.postgresql.org/docs/current/catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE&#34;&gt;have category&lt;/a&gt; &lt;code&gt;E&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT
  *
  FROM pg_type
  WHERE typcategory = &#39;E&#39;;

-[ RECORD 1 ]--+----------
typname        | weather
typnamespace   | 2200
typowner       | 24576
typlen         | 4
typbyval       | t
typtype        | e
typcategory    | E
typispreferred | f
typisdefined   | t
typdelim       | ,
typrelid       | 0
typelem        | 0
typarray       | 41019
typinput       | enum_in
typoutput      | enum_out
typreceive     | enum_recv
typsend        | enum_send
typmodin       | -
typmodout      | -
typanalyze     | -
typalign       | i
typstorage     | p
typnotnull     | f
typbasetype    | 0
typtypmod      | -1
typndims       | 0
typcollation   | 0
typdefaultbin  |
typdefault     |
typacl         |

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This shows us that the name of the enum is &lt;code&gt;weather&lt;/code&gt;. How do we find the possible values of this Enum? Values are stored in the catalog &lt;code&gt;pg_enum&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT
  *
  FROM pg_enum;

 enumtypid | enumsortorder | enumlabel
-----------+---------------+-----------
     41020 |             1 | sunny
     41020 |             2 | rainy
     41020 |             3 | cloudy
     41020 |             4 | snow
(4 rows)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is worth noting that each of the enum values are in separate rows of the catalog, with each row using the same &lt;code&gt;enumtypid&lt;/code&gt;. The &lt;code&gt;enumtypid&lt;/code&gt; is referring to the &lt;code&gt;oid&lt;/code&gt; of the enum entry in &lt;code&gt;pg_type&lt;/code&gt; catalog. We can verify that we are indeed looking at the same type. &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT
  *
FROM pg_type
WHERE oid = 41020;

-[ RECORD 1 ]--+----------
typname        | weather
typnamespace   | 2200
typowner       | 24576
typlen         | 4
typbyval       | t
typtype        | e
typcategory    | E
typispreferred | f
typisdefined   | t
typdelim       | ,
typrelid       | 0
typelem        | 0
typarray       | 41019
typinput       | enum_in
typoutput      | enum_out
typreceive     | enum_recv
typsend        | enum_send
typmodin       | -
typmodout      | -
typanalyze     | -
typalign       | i
typstorage     | p
typnotnull     | f
typbasetype    | 0
typtypmod      | -1
typndims       | 0
typcollation   | 0
typdefaultbin  |
typdefault     |
typacl         |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use the information we have so far to perform a &lt;code&gt;JOIN&lt;/code&gt; on these catalogs to get all Enum types. To test that values and types are fetched correctly, lets create another enum.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; CREATE TYPE transport AS ENUM (
  &#39;bus&#39;, &#39;tram&#39;, &#39;rail&#39;, &#39;ferry&#39;
);

CREATE TYPE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This enum will create more entries in &lt;code&gt;pg_enum&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT
  *
FROM pg_enum;

 enumtypid | enumsortorder | enumlabel
-----------+---------------+-----------
     41020 |             1 | sunny
     41020 |             2 | rainy
     41020 |             3 | cloudy
     41020 |             4 | snow
     41030 |             1 | bus
     41030 |             2 | tram
     41030 |             3 | rail
     41030 |             4 | ferry
(8 rows)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now perform the &lt;code&gt;JOIN&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT
  type.typname,
  enum.enumlabel AS value
FROM pg_enum AS enum
JOIN pg_type AS type
  ON (type.oid = enum.enumtypid)
GROUP BY enum.enumlabel,
         type.typname;

  typname  | value
-----------+--------
 weather   | cloudy
 transport | ferry
 transport | bus
 transport | tram
 transport | rail
 weather   | rainy
 weather   | sunny
 weather   | snow
(8 rows)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This query needs a &lt;code&gt;GROUP BY&lt;/code&gt; due to the fact that there are multiple rows representing a single Enum&amp;rsquo;s values.&lt;/p&gt;
&lt;p&gt;This result gives us everything we want in most cases. But sometimes we want to get a single row with an Enum and all it&amp;rsquo;s values. This can be accomplished by the use of Postgres&amp;rsquo; &lt;a href=&#34;https://www.postgresql.org/docs/9.0/functions-aggregate.html&#34;&gt;&lt;code&gt;string_agg&lt;/code&gt;&lt;/a&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT
  type.typname AS name,
  string_agg(enum.enumlabel, &#39;|&#39;) AS value
FROM pg_enum AS enum
JOIN pg_type AS type
  ON (type.oid = enum.enumtypid)
GROUP BY type.typname;

   name    |          value
-----------+-------------------------
 transport | bus|tram|rail|ferry
 weather   | sunny|rainy|cloudy|snow
(2 rows)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our choice of &lt;code&gt;|&lt;/code&gt; as the separator is arbitrary, but it is important to remember that Postgres does allow blanks in Enum values and using blank as the separator will lead to unexpected and wrong results. &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Postgres does not display values of &lt;code&gt;oid&lt;/code&gt; columns of catalogs by default. It has to be explicitly queried for.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Being bit hard by this issue is how I learned about this.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Viewing Sequence ownership information in Postgres</title>
      <link>https://sadique.io/blog/2019/05/07/viewing-sequence-ownership-information-in-postgres/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Tue, 07 May 2019 18:04:42 -0700</pubDate>
      
      <guid>https://sadique.io/blog/2019/05/07/viewing-sequence-ownership-information-in-postgres/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;This blog post is an exercise in identifying all the &lt;code&gt;sequences&lt;/code&gt; in a PostgreSQL database that is associated with a table column via an &lt;code&gt;OWNED BY&lt;/code&gt; relationship. Figuring out how to do this was harder than it should have been and this journals my understanding of it.&lt;/p&gt;
&lt;p&gt;When I first started looking at this, I ended up at this Stack Overflow &lt;a href=&#34;https://stackoverflow.com/questions/9900346/how-do-you-view-new-sequence-ownership-information-in-postgres-after-using-alter&#34;&gt;answer&lt;/a&gt; from 2012. While that seemed to work, it is fair to say that I had no idea what it did. So, I set out to understand it and hopefully improve it.&lt;/p&gt;
&lt;p&gt;We will start by creating a &lt;code&gt;table&lt;/code&gt; that we will later associate a &lt;code&gt;sequence&lt;/code&gt; with.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE users
  (
     id   BIGINT NOT NULL,
     NAME VARCHAR(40) NOT NULL
  );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we will create a sequence that is not going to be owned by any columns - a freehanging sequence.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE SEQUENCE freehanging;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Postgres stores &lt;code&gt;sequence&lt;/code&gt;s across two different catalogs - &lt;a href=&#34;https://www.postgresql.org/docs/current/catalog-pg-sequence.html&#34;&gt;&lt;code&gt;pg_sequence&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://www.postgresql.org/docs/current/catalog-pg-class.html&#34;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt;. Catalog &lt;code&gt;pg_sequence&lt;/code&gt; contains sequence parameters like &lt;code&gt;seqstart&lt;/code&gt;, &lt;code&gt;seqincrement&lt;/code&gt; etc. The rest of the information gets stored in &lt;code&gt;pg_class&lt;/code&gt; catalog with the &lt;code&gt;seqlrelid&lt;/code&gt; column in &lt;code&gt;pg_sequence&lt;/code&gt; pointing to the corresponding &lt;code&gt;pg_class&lt;/code&gt; entry.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; \x
Expanded display is on.

=&amp;gt; SELECT *
FROM   pg_sequence;

-[ RECORD 1 ]+--------------------
seqrelid     | 41000
seqtypid     | 20
seqstart     | 1
seqincrement | 1
seqmax       | 9223372036854775807
seqmin       | 1
seqcache     | 1
seqcycle     | f

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That has the information that Postgres can use, but it does not look particularly useful to a human being. Luckily, Postgres provides a &lt;code&gt;view&lt;/code&gt; named &lt;a href=&#34;https://www.postgresql.org/docs/10/view-pg-sequences.html&#34;&gt;&lt;code&gt;pg_sequences&lt;/code&gt;&lt;/a&gt; that shows us more information.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT *
FROM   pg_sequences;

-[ RECORD 1 ]-+--------------------
schemaname    | public
sequencename  | freehanging
sequenceowner | todo
data_type     | bigint
start_value   | 1
min_value     | 1
max_value     | 9223372036854775807
increment_by  | 1
cycle         | f
cache_size    | 1
last_value    |

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can query &lt;code&gt;pg_class&lt;/code&gt; with our &lt;code&gt;seqrelid&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT *
FROM   pg_class
WHERE  relfilenode = 41000;

-[ RECORD 1 ]-------+------------
relname             | freehanging
relnamespace        | 2200
reltype             | 41001
reloftype           | 0
relowner            | 24576
relam               | 0
relfilenode         | 41000
reltablespace       | 0
relpages            | 1
reltuples           | 1
relallvisible       | 0
reltoastrelid       | 0
relhasindex         | f
relisshared         | f
relpersistence      | p
relkind             | S
relnatts            | 3
relchecks           | 0
relhasoids          | f
relhasrules         | f
relhastriggers      | f
relhassubclass      | f
relrowsecurity      | f
relforcerowsecurity | f
relispopulated      | t
relreplident        | n
relispartition      | f
relrewrite          | 0
relfrozenxid        | 0
relminmxid          | 0
relacl              |
reloptions          |
relpartbound        |

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can create a second sequence we want to associate with the &lt;code&gt;users&lt;/code&gt; table.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; CREATE SEQUENCE users_id_seq;

CREATE SEQUENCE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will now show up in our queries.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT *
FROM   pg_sequence;

-[ RECORD 1 ]+--------------------
seqrelid     | 41000
seqtypid     | 20
seqstart     | 1
seqincrement | 1
seqmax       | 9223372036854775807
seqmin       | 1
seqcache     | 1
seqcycle     | f
-[ RECORD 2 ]+--------------------
seqrelid     | 41002
seqtypid     | 20
seqstart     | 1
seqincrement | 1
seqmax       | 9223372036854775807
seqmin       | 1
seqcache     | 1
seqcycle     | f

=&amp;gt; SELECT *
FROM   pg_sequences;

-[ RECORD 1 ]-+--------------------
schemaname    | public
sequencename  | freehanging
sequenceowner | todo
data_type     | bigint
start_value   | 1
min_value     | 1
max_value     | 9223372036854775807
increment_by  | 1
cycle         | f
cache_size    | 1
last_value    |
-[ RECORD 2 ]-+--------------------
schemaname    | public
sequencename  | users_id_seq
sequenceowner | todo
data_type     | bigint
start_value   | 1
min_value     | 1
max_value     | 9223372036854775807
increment_by  | 1
cycle         | f
cache_size    | 1
last_value    |

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can perform a &lt;code&gt;join&lt;/code&gt; on these catalogs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT seqclass.relname,
       seqclass.relfilenode
FROM   pg_class AS seqclass
       JOIN pg_sequence AS seq
         ON ( seq.seqrelid = seqclass.relfilenode );

-[ RECORD 1 ]-------------
relname     | freehanging
relfilenode | 41000
-[ RECORD 2 ]-------------
relname     | users_id_seq
relfilenode | 41002

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can go ahead and associate the new sequence with the &lt;code&gt;users&lt;/code&gt; table by specifying &lt;code&gt;OWNED BY&lt;/code&gt;. By setting &lt;code&gt;OWNED BY&lt;/code&gt;, we are specifying that if the column is dropped, we want the sequence to be dropped as well.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;=&amp;gt; ALTER SEQUENCE users_id_seq OWNED BY users.id;

ALTER SEQUENCE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This association is recorded by Postgres in the &lt;a href=&#34;https://www.postgresql.org/docs/current/catalog-pg-depend.html&#34;&gt;&lt;code&gt;pg_depend&lt;/code&gt;&lt;/a&gt; catalog, using an &lt;code&gt;a&lt;/code&gt; dependency type.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DEPENDENCY_AUTO (a)&lt;/p&gt;
&lt;p&gt;The dependent object can be dropped separately from the referenced object, and should be automatically dropped (regardless of RESTRICT or CASCADE mode) if the referenced object is dropped. Example: a named constraint on a table is made autodependent on the table, so that it will go away if the table is dropped.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT *
FROM   pg_depend
WHERE  objid = 41002
       AND deptype = &#39;a&#39;;

-[ RECORD 1 ]------
classid     | 1259
objid       | 41002
objsubid    | 0
refclassid  | 1259
refobjid    | 40997
refobjsubid | 1
deptype     | a

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also verify that the &lt;code&gt;freehanging&lt;/code&gt; sequence has no dependencies of type &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT *
FROM   pg_depend
WHERE  objid = 41000
       AND deptype = &#39;a&#39;;

(0 rows)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a dependency identified for this relationship, we can verify that the dependency is indeed with the &lt;code&gt;users&lt;/code&gt; table. For this, we will query using the dependency&amp;rsquo;s &lt;code&gt;refobjid&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT *
FROM   pg_class
WHERE  relfilenode = 40997;

-[ RECORD 1 ]-------+------
relname             | users
relnamespace        | 2200
reltype             | 40999
reloftype           | 0
relowner            | 24576
relam               | 0
relfilenode         | 40997
reltablespace       | 0
relpages            | 0
reltuples           | 0
relallvisible       | 0
reltoastrelid       | 0
relhasindex         | f
relisshared         | f
relpersistence      | p
relkind             | r
relnatts            | 2
relchecks           | 0
relhasoids          | f
relhasrules         | f
relhastriggers      | f
relhassubclass      | f
relrowsecurity      | f
relforcerowsecurity | f
relispopulated      | t
relreplident        | d
relispartition      | f
relrewrite          | 0
relfrozenxid        | 5021
relminmxid          | 1
relacl              |
reloptions          |
relpartbound        |

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can indeed see that the dependency is on the &lt;code&gt;users&lt;/code&gt; table.&lt;/p&gt;
&lt;p&gt;What about the column associated with this dependency? Postgres stores information about table columns in &lt;a href=&#34;https://www.postgresql.org/docs/current/catalog-pg-attribute.html&#34;&gt;&lt;code&gt;pg_attribute&lt;/code&gt;&lt;/a&gt; catalog. We can verify that the dependency is on the &lt;code&gt;id&lt;/code&gt; column, by querying &lt;code&gt;pg_attribute&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT *
FROM   pg_attribute
WHERE  attrelid = 40997
       AND attnum = 1;

-[ RECORD 1 ]-+------
attrelid      | 40997
attname       | id
atttypid      | 20
attstattarget | -1
attlen        | 8
attnum        | 1
attndims      | 0
attcacheoff   | -1
atttypmod     | -1
attbyval      | t
attstorage    | p
attalign      | d
attnotnull    | t
atthasdef     | f
atthasmissing | f
attidentity   |
attisdropped  | f
attislocal    | t
attinhcount   | 0
attcollation  | 0
attacl        |
attoptions    |
attfdwoptions |
attmissingval |

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that the column corresponding to the dependency is indeed &lt;code&gt;id&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Our &lt;code&gt;join&lt;/code&gt; can now be improved to use this information. First, we will add the table name:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT seqclass.relname     AS sequence_name,
       seqclass.relfilenode AS sequenceref,
       dep.refobjid         AS depobjref,
       depclass.relname     AS table_name
FROM   pg_class AS seqclass
       JOIN pg_sequence AS seq
         ON ( seq.seqrelid = seqclass.relfilenode )
       JOIN pg_depend AS dep
         ON ( seq.seqrelid = dep.objid )
       JOIN pg_class AS depclass
         ON ( dep.refobjid = depclass.relfilenode );

-[ RECORD 1 ]+-------------
sequence_name | users_id_seq
sequenceref  | 41002
depobjref    | 40997
table_name    | users

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have to join twice on the &lt;code&gt;pg_class&lt;/code&gt; catalog - once to get the &lt;code&gt;sequence&lt;/code&gt;&amp;rsquo;s columns and once to get the &lt;code&gt;dependency&lt;/code&gt;&amp;rsquo;s columns. This leaves us with the name of the table and the sequence name.&lt;/p&gt;
&lt;p&gt;Finally, we can perform a join on &lt;code&gt;pg_attribute&lt;/code&gt; to get column information.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT seqclass.relname     AS sequence_name,
       seqclass.relfilenode AS sequenceref,
       dep.refobjid         AS depobjref,
       depclass.relname     AS tabl_ename,
       attrib.attname       AS column_name
FROM   pg_class AS seqclass
       JOIN pg_sequence AS seq
         ON ( seq.seqrelid = seqclass.relfilenode )
       JOIN pg_depend AS dep
         ON ( seq.seqrelid = dep.objid )
       JOIN pg_class AS depclass
         ON ( dep.refobjid = depclass.relfilenode )
       JOIN pg_attribute AS attrib
         ON ( attrib.attnum = dep.refobjsubid
              AND attrib.attrelid = dep.refobjid );

-[ RECORD 1 ]+-------------
sequence_name | users_id_seq
sequenceref   | 41002
depobjref     | 40997
table_name    | users
column_name   | id

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can drop &lt;code&gt;sequenceref&lt;/code&gt; and &lt;code&gt;depobjref&lt;/code&gt; from the result as it is not of particular interest to us when reporting this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT seqclass.relname AS sequence_name,
       depclass.relname AS table_name,
       attrib.attname   AS column_name
FROM   pg_class AS seqclass
       JOIN pg_sequence AS seq
         ON ( seq.seqrelid = seqclass.relfilenode )
       JOIN pg_depend AS dep
         ON ( seq.seqrelid = dep.objid )
       JOIN pg_class AS depclass
         ON ( dep.refobjid = depclass.relfilenode )
       JOIN pg_attribute AS attrib
         ON ( attrib.attnum = dep.refobjsubid
              AND attrib.attrelid = dep.refobjid );

-[ RECORD 1 ]+-------------
sequenc_ename | users_id_seq
table_name    | users
column_name   | id

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;postgres-versions-before-10&#34;&gt;Postgres versions before 10&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;pg_sequence&lt;/code&gt; catalog was introduced in Postgres 10. For versions before 10, we need another way to get hold of the sequence&amp;rsquo;s representation in &lt;code&gt;pg_class&lt;/code&gt; so that we can look up the dependencies. Luckily, &lt;code&gt;pg_class&lt;/code&gt; has a column &lt;code&gt;relkind&lt;/code&gt; that holds this informations. For a sequence, this column will be &lt;code&gt;S&lt;/code&gt;. We can use this in the &lt;code&gt;join&lt;/code&gt; instead of &lt;code&gt;pg_sequence&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; SELECT seqclass.relname AS sequence_name,
       depclass.relname AS table_name,
       attrib.attname   as column_name
FROM   pg_class AS seqclass
       JOIN pg_depend AS dep
         ON ( seqclass.relfilenode = dep.objid )
       JOIN pg_class AS depclass
         ON ( dep.refobjid = depclass.relfilenode )
       JOIN pg_attribute AS attrib
         ON ( attrib.attnum = dep.refobjsubid
              AND attrib.attrelid = dep.refobjid )
WHERE  seqclass.relkind = &#39;S&#39;;

-[ RECORD 1 ]-+-------------
sequence_name | users_id_seq
table_name    | users
column_name   | id

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This seems like information that should be surfaced by Postgres in an easier to access way. In fact there is a patch from &lt;a href=&#34;https://web.archive.org/web/20190508035646/https://www.postgresql.org/message-id/1228622212.10877.59.camel%40godzilla.local.scalefeather.com&#34;&gt;2008&lt;/a&gt; that would have introduced this capability. When Postgres 10 introduced the &lt;a href=&#34;https://web.archive.org/web/20190508035646/https://www.postgresql.org/message-id/1228622212.10877.59.camel%40godzilla.local.scalefeather.com&#34;&gt;&lt;code&gt;pg_sequences&lt;/code&gt;&lt;/a&gt; catalog, it stopped at surfacing the id of the user who owns the sequence.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>

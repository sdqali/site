<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dropwizard on {code that works}</title>
    <link>https://sadique.io/tags/dropwizard/?utm_source=site&amp;utm_medium=feed</link>
    <description>Recent content in Dropwizard on {code that works}</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 02 Aug 2019 18:19:32 -0700</lastBuildDate>
    <atom:link href="https://sadique.io/tags/dropwizard/?utm_source=site&amp;utm_medium=feed" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Flushing Metrics in Dropwizard Commands</title>
      <link>https://sadique.io/blog/2019/08/02/flushing-metrics-in-dropwizard-commands/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Fri, 02 Aug 2019 18:19:32 -0700</pubDate>
      
      <guid>https://sadique.io/blog/2019/08/02/flushing-metrics-in-dropwizard-commands/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;Users of Dropwizard Metrics will be familiar with &lt;code&gt;ScheduledReporter&lt;/code&gt;  - it is a nice pattern that allows metrics reporting to be off loaded to a different thread which periodically sends out the collected metrics instead of making a network call every time a metric is collected. In most use cases, this works great - especially if you are running a server.&lt;/p&gt;
&lt;p&gt;However, the implementation of &lt;code&gt;ScheduledReporter&lt;/code&gt; comes with an interesting quirk - it reports metrics only on the configured schedule, but does not flush the metrics it has collected after the last flush when the reporter is closed.&lt;/p&gt;
&lt;p&gt;Datadog Metrics wires up ScheduledReporters that you configure as Dropwizard Lifecycle managed entities, guaranteeing that when your application shuts down, the reporter is closed.&lt;/p&gt;
&lt;p&gt;This results in metrics collected immediately before an application is shutdown being discarded. This is especially problematic for Dropwizard commands that have varying run times depending on how much data processing it performs.&lt;/p&gt;
&lt;p&gt;Imagine a Dropwizard command that when run downloads a file and processes it. Suppose the usual run time is in minutes, so you have configured your metric reporter&amp;rsquo;s frequency to be &lt;code&gt;1 minute&lt;/code&gt;, which is reasonable for this command. However, consider the situation where the downloaded file contains no data - the command will finish in seconds, thereby discarding any metric it has collected, as it hasn&amp;rsquo;t ran for long enough for the scheduled reporter&amp;rsquo;s executor to kick in.&lt;/p&gt;
&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;
&lt;p&gt;If you have the ability to override the specific &lt;code&gt;ScheduledReporter&lt;/code&gt; you are using, you could inherit from it and override the &lt;code&gt;#close()&lt;/code&gt; method to call &lt;code&gt;#report&lt;/code&gt; before issuing &lt;code&gt;#stop&lt;/code&gt;. For example, if you were using the &lt;code&gt;ConsoleReporter&lt;/code&gt;, you could override the method and then use a &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html&#34;&gt;Service Provider Interface&lt;/a&gt; to provide your new reporter to Datadog Metrics.&lt;/p&gt;
&lt;p&gt;The SPI goes in the file &lt;code&gt;src/main/resources/META-INF/services/io.dropwizard.metrics.ReporterFactory&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;io.sadique.dropwizard.metrics.flush.CustomReporterFactory
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CustomReporterFactory extends BaseReporterFactory {
  @Override
  public ScheduledReporter build(MetricRegistry registry) {
    return FlushingReporter.forRegistry(registry)
      .build();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are using a reporter like &lt;code&gt;DataogReporter&lt;/code&gt;, it is hard to override it as the constructor is marked private. In such situations, we can create a wrapper that provides the overridden behavior:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FlushOnCloseReporter extends ScheduledReporter  {
  private final ScheduledReporter wrapped;

  public FlushOnCloseReporter(ScheduledReporter wrapped, MetricRegistry registry, String name,
                              MetricFilter filter, TimeUnit rateUnit, TimeUnit durationUnit) {
    super(registry, name, filter, rateUnit, durationUnit);
    this.wrapped = wrapped;
  }

  @Override
  public void report(SortedMap&amp;lt;String, Gauge&amp;gt; gauges, SortedMap&amp;lt;String, Counter&amp;gt; counters,
                     SortedMap&amp;lt;String, Histogram&amp;gt; histograms, SortedMap&amp;lt;String, Meter&amp;gt; meters,
                     SortedMap&amp;lt;String, Timer&amp;gt; timers) {
    wrapped.report(gauges, counters, histograms, meters, timers);
  }

  @Override
  public void start(long period, TimeUnit unit) {
    wrapped.start(period, unit);
  }

  @Override
  public void stop() {
    wrapped.report();
    wrapped.stop();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the reporter factory can be modified to wrap the &lt;code&gt;DatadogReporter&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CustomReporterFactory extends BaseReporterFactory {
  @Override
  public ScheduledReporter build(MetricRegistry registry) {
    DatadogReporter consoleReporter = DatadogReporter.forRegistry(registry)
      .filter(getFilter())
      .convertDurationsTo(getDurationUnit())
      .convertRatesTo(getRateUnit())
      .build();
    return new FlushOnCloseReporter(consoleReporter, registry, &amp;quot;flush-on-close(DatadogReporter)&amp;quot;,
      getFilter(), getRateUnit(), getDurationUnit());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will ensure that reports are always flushed before the reporter is shutdown by Dropwizard lifecycle.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Managing environment lifecycles for Dropwizard Commands</title>
      <link>https://sadique.io/blog/2019/07/28/managing-environment-lifecycles-for-dropwizard-commands/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sun, 28 Jul 2019 18:29:49 -0700</pubDate>
      
      <guid>https://sadique.io/blog/2019/07/28/managing-environment-lifecycles-for-dropwizard-commands/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;If you have built background workers or other non-server applications with Dropwizard, chances are that you used the Dropwizard Command pattern. In fact, even the sever you wrote with Dropwizard executes a command - specifically &lt;code&gt;io.dropwizard.cli.ServerCommand&lt;/code&gt;. While the server command is great, sometimes you want to build applications that have all the goodies that Dropwizard offers, but you dont want to start a server. Managing Lifecycles is one example of a Dropwizard feature that works great for server applications, but needs some tweaking to get working for non-server commands.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take the following example. We have the simplest Dropwizard command below. It doesn&amp;rsquo;t do much, except print some logs and sleep for a second in between.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WaitingCommand extends EnvironmentCommand&amp;lt;AppConfiguration&amp;gt; {

  public WaitingCommand(Application&amp;lt;AppConfiguration&amp;gt; application) {
    super(application, &amp;quot;wait&amp;quot;, &amp;quot;Wait for a second.&amp;quot;);
  }

  @Override
  protected void run(Environment environment, Namespace namespace, AppConfiguration configuration) throws Exception {
    Logger.getInstance(getClass()).info(&amp;quot;Starting command&amp;quot;);
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    Logger.getInstance(getClass()).info(&amp;quot;Finished running command&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can wire this to our application.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MetricsApplication extends Application&amp;lt;AppConfiguration&amp;gt; {
  public static void main(String[] args) throws Exception {
    new MetricsApplication().run(args);
  }

  @Override
  public void run(AppConfiguration configuration, Environment environment) throws Exception {

  }

  @Override
  public void initialize(Bootstrap&amp;lt;AppConfiguration&amp;gt; bootstrap) {
    bootstrap.addCommand(new WaitingCommand(this));

    bootstrap.setConfigurationSourceProvider(new ResourceConfigurationSourceProvider());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When our application runs with the &lt;code&gt;wait&lt;/code&gt; command (i.e. we invoke it as &lt;code&gt;java -jar app.jar wait config.yml&lt;/code&gt;), it does the little work we asked it to do.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INFO  [2019-07-29 01:42:43,703] org.eclipse.jetty.util.log: Logging initialized @2699ms to org.eclipse.jetty.util.log.Slf4jLog
INFO  [2019-07-29 01:42:43,952] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: /
INFO  [2019-07-29 01:42:43,957] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: /
INFO  [2019-07-29 01:42:43,960] io.sadique.dropwizard.WaitingCommand: Starting command
INFO  [2019-07-29 01:42:44,966] io.sadique.dropwizard.WaitingCommand: Finished running command
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;adding-a-lifecycle&#34;&gt;Adding a lifecycle&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s try adding an object whose lifecycle we intend to be managed by Dropwizard. Again, this entity in the example doesn&amp;rsquo;t do much - except log when it is started and stopped by Dropwizard.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import io.dropwizard.lifecycle.Managed;
import org.apache.log4j.Logger;

public class ManagedObject implements Managed {
  @Override
  public void start() throws Exception {
    Logger.getInstance(getClass()).info(&amp;quot;Starting managed object&amp;quot;);
  }

  @Override
  public void stop() throws Exception {
    Logger.getInstance(getClass()).info(&amp;quot;Stopping managed object&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will of course need to tell Dropwizard to manage this object:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
  @Override
  public void run(AppConfiguration configuration, Environment environment) throws Exception {
    environment.lifecycle().manage(new ManagedObject());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the application is run with the &lt;code&gt;wait&lt;/code&gt; command, the log looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INFO  [2019-07-29 01:50:28,510] org.eclipse.jetty.util.log: Logging initialized @1640ms to org.eclipse.jetty.util.log.Slf4jLog
INFO  [2019-07-29 01:50:28,640] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: /
INFO  [2019-07-29 01:50:28,642] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: /
INFO  [2019-07-29 01:50:28,647] io.sadique.dropwizard.WaitingCommand: Starting command
INFO  [2019-07-29 01:50:29,649] io.sadique.dropwizard.WaitingCommand: Finished running command
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looks like the object we expected Dropwizard to start and stop was ignored. What if we run the application with the &lt;code&gt;server&lt;/code&gt; command?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INFO  [2019-07-29 02:09:17,067] org.eclipse.jetty.setuid.SetUIDListener: Opened application@680a66dd{HTTP/1.1,[http/1.1]}{0.0.0.0:8080}
INFO  [2019-07-29 02:09:17,067] org.eclipse.jetty.setuid.SetUIDListener: Opened admin@2dd8239{HTTP/1.1,[http/1.1]}{0.0.0.0:8081}
INFO  [2019-07-29 02:09:17,126] org.eclipse.jetty.server.Server: jetty-9.4.z-SNAPSHOT
INFO  [2019-07-29 02:09:17,143] io.sadique.dropwizard.ManagedObject: Starting managed object
...
...
...
INFO  [2019-07-29 02:09:21,747] org.eclipse.jetty.server.AbstractConnector: Stopped admin@2dd8239{HTTP/1.1,[http/1.1]}{0.0.0.0:8081}
INFO  [2019-07-29 02:09:21,751] org.eclipse.jetty.server.handler.ContextHandler: Stopped i.d.j.MutableServletContextHandler@2ee83775{/,null,UNAVAILABLE}
INFO  [2019-07-29 02:09:21,756] org.eclipse.jetty.server.handler.ContextHandler: Stopped i.d.j.MutableServletContextHandler@19382338{/,null,UNAVAILABLE}
INFO  [2019-07-29 02:09:21,760] io.sadique.dropwizard.ManagedObject: Stopping managed object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The server seems to manage the lifecycle of the object as expected. Why is it the case that server command can manage the lifecycle, but our custom command can&amp;rsquo;t?&lt;/p&gt;
&lt;p&gt;It turns out, it is not enough to register an entity whose lifecycle needs to be managed, someone needs to attach a lifecycle container to the &lt;code&gt;LifecycleEnvironment&lt;/code&gt;. It is not an issue for the server command because it builds a server using &lt;code&gt;io.dropwizard.server.AbstractServerFactory#buildServer&lt;/code&gt;, which in turn &lt;a href=&#34;https://github.com/dropwizard/dropwizard/blob/master/dropwizard-core/src/main/java/io/dropwizard/server/AbstractServerFactory.java#L611&#34;&gt;attaches the container&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;building-a-lifecyclemanagedcommand&#34;&gt;Building a LifecycleManagedCommand&lt;/h2&gt;
&lt;p&gt;We can mimic the behavior of the server by constructing our own &lt;code&gt;ContainerLifecycle&lt;/code&gt; and starting it before our command performs it&amp;rsquo;s actions. This pattern can be generalized as a &lt;code&gt;LifecycleManagedCommand&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class LifecycleManagedCommand&amp;lt;T extends Configuration&amp;gt; extends EnvironmentCommand&amp;lt;T&amp;gt; {

  private final ContainerLifeCycle containerLifeCycle;

  public LifecycleManagedCommand(Application&amp;lt;T&amp;gt; application, String name, String description) {
    super(application, name, description);
    containerLifeCycle = new ContainerLifeCycle();
  }

  @Override
  protected void run(Environment environment, Namespace namespace, T configuration) throws Exception {
    environment.lifecycle().getManagedObjects().stream().forEach(mo -&amp;gt; containerLifeCycle.addBean(mo));
    ShutdownThread.register(containerLifeCycle);
    containerLifeCycle.start();

    runManaged(environment, namespace, configuration);

    containerLifeCycle.stop();
  }

  abstract void runManaged(Environment environment, Namespace namespace, T configuration);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command ensures that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A new &lt;code&gt;ContainerLifeCycle&lt;/code&gt; is built before running the command.&lt;/li&gt;
&lt;li&gt;Every managed object registered with the Lifecycle is added to the container.&lt;/li&gt;
&lt;li&gt;The container is started and registered with &lt;code&gt;ShutdownThread&lt;/code&gt;, which is Dropwizard&amp;rsquo;s shut down hook.&lt;/li&gt;
&lt;li&gt;The container is stopped after the command performs it&amp;rsquo;s action.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can now now modify &lt;code&gt;WaitCommand&lt;/code&gt; to use this pattern.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class WaitingCommand extends LifecycleManagedCommand&amp;lt;AppConfiguration&amp;gt; {

  public WaitingCommand(Application&amp;lt;AppConfiguration&amp;gt; application) {
    super(application, &amp;quot;wait&amp;quot;, &amp;quot;Wait for a second.&amp;quot;);
  }

  @Override
  protected void runManaged(Environment environment, Namespace namespace, AppConfiguration configuration) {
    Logger.getInstance(getClass()).info(&amp;quot;Starting command&amp;quot;);
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    Logger.getInstance(getClass()).info(&amp;quot;Finished running command&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this change, we can see that Dropwizard correctly handles the lifecycle when the &lt;code&gt;wait&lt;/code&gt; command is executed.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INFO  [2019-07-29 02:26:34,560] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: /
INFO  [2019-07-29 02:26:34,563] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: /
INFO  [2019-07-29 02:26:34,569] io.sadique.dropwizard.ManagedObject: Starting managed object
INFO  [2019-07-29 02:26:34,569] io.sadique.dropwizard.WaitingCommand: Starting command
INFO  [2019-07-29 02:26:35,575] io.sadique.dropwizard.WaitingCommand: Finished running command
INFO  [2019-07-29 02:26:35,575] io.sadique.dropwizard.ManagedObject: Stopping managed object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The server command will of course continue to work as expected.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>

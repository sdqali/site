<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ruby on {code that works}</title>
    <link>https://sadique.io/tags/ruby/?utm_source=site&amp;utm_medium=feed</link>
    <description>Recent content in Ruby on {code that works}</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 22 Mar 2018 02:44:03 +0000</lastBuildDate>
    <atom:link href="https://sadique.io/tags/ruby/?utm_source=site&amp;utm_medium=feed" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Net::HTTP and the simplest of explanations</title>
      <link>https://sadique.io/blog/2018/03/22/nethttp-and-the-simplest-of-explanations/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Thu, 22 Mar 2018 02:44:03 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2018/03/22/nethttp-and-the-simplest-of-explanations/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;&lt;em&gt;This blog post exists purely to remind myself that Ruby&amp;rsquo;s &lt;code&gt;Net::HTTP&lt;/code&gt; expects a &lt;code&gt;host&lt;/code&gt; and a &lt;code&gt;port&lt;/code&gt; as parameters when creating a new connection and not a &lt;code&gt;url&lt;/code&gt; string.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This is a story about how many layers of abstractions and indirections one works through on a daily basis as a developer and the effort required to dive through these layers, all the while ignoring the simplest of explanations of why things may have gone wrong in the first place.&lt;/p&gt;
&lt;p&gt;At work, we have a homegrown orchestration tool that brings up Docker containers and configures dependencies and network access between them - essentially an abstraction over &lt;code&gt;docker-compose&lt;/code&gt;. In our continuous integration environment, this tool sets up all the different components of our system and then starts another container in which &lt;code&gt;RSpec&lt;/code&gt; based integration tests that exercise various inetractions between the components of the system are run.&lt;/p&gt;
&lt;p&gt;We added a new component and wanted a library used by the specs to use an API provided by this component. This essentially meant this for us:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Change our configurations so that the Docker container with the new component is started before the test container is started.&lt;/li&gt;
&lt;li&gt;Ensure that the test container can talk to the new component container.&lt;/li&gt;
&lt;li&gt;Tell the test container, through environment variables the &lt;code&gt;host&lt;/code&gt; and the &lt;code&gt;port&lt;/code&gt; of the new component.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, off we went and configured everything:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;env.NEWAPP_HOST=http://new-app.local
env.NEWAPP_PORT=1313
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We ran the tests and boom:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;SocketError (Failed to open TCP connection to http://new-app.local:1313 (getaddrinfo: nodename nor servname provided, or not known))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Well, that does not look right. We double check all the configurations and run the test again. Same result. May be we should be using a Ruby &lt;code&gt;Symbol&lt;/code&gt; instead of a &lt;code&gt;String&lt;/code&gt; in that particular config? May be. We try that, same result.&lt;/p&gt;
&lt;p&gt;At this point, we hop on to the test container and ping &lt;code&gt;new-app.local&lt;/code&gt;. It can connect.
What if the app is not available? We should totally &lt;code&gt;telnet&lt;/code&gt; it. Well, this container does not have &lt;code&gt;telnet&lt;/code&gt;. We can totally install it, right? Right. What kind of distro is this running? Well &lt;code&gt;cat /etc/*release*&lt;/code&gt;. Debian, huh? &lt;code&gt;apt-get install telnet&lt;/code&gt;. Wooh. Back to &lt;code&gt;telnet&lt;/code&gt; then. That looks good.&lt;/p&gt;
&lt;p&gt;At this point, the attention turns to the RSpec tests. What if the tests have some environment variables? Let&amp;rsquo;s debug it and look for things in Ruby&amp;rsquo;s &lt;code&gt;ENV&lt;/code&gt;. Hmmm, nothing interesting there. Can the Ruby process even connect to &lt;code&gt;new-app&lt;/code&gt;? We have &lt;code&gt;Faraday&lt;/code&gt;, let&amp;rsquo;s try that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-irb&#34;&gt;&amp;gt; require &#39;faraday&#39;
=&amp;gt; true
&amp;gt; resp = Faraday.get &amp;quot;http://google.com&amp;quot;
&amp;gt; resp.status
200
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Okay, does the library we use for the test even use &lt;code&gt;Faraday&lt;/code&gt;? Let&amp;rsquo;s open the source code for that and poke around. Nah, it uses &lt;code&gt;Net::Http&lt;/code&gt;. Let&amp;rsquo;s try the example from &lt;a href=&#34;https://ruby-doc.org/stdlib-2.5.0/libdoc/net/http/rdoc/Net/HTTP.html&#34;&gt;it&amp;rsquo;s documentation&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-irb&#34;&gt;&amp;gt; require &#39;net/http&#39;
=&amp;gt; true
&amp;gt; Net::HTTP.get_response(URI(&amp;quot;http://new-app.local:1313&amp;quot;))
=&amp;gt; #&amp;lt;Net::HTTPOK 200 OK readbody=true&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looks good. Well, wait! Our library uses &lt;code&gt;Net::HTTP.new&lt;/code&gt; to create a connection. Let&amp;rsquo;s try that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-irb&#34;&gt;&amp;gt; conn = Net::HTTP.new(&amp;quot;http://new-app.local&amp;quot;, 1313)
=&amp;gt; #&amp;lt;Net::HTTP http://new-app.local:1313 open=false&amp;gt;
&amp;gt; conn.get(&amp;quot;/&amp;quot;)
Traceback (most recent call last):
.
.
.
SocketError (Failed to open TCP connection to http://new-app.local:1313 (getaddrinfo: nodename nor servname provided, or not known))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point, we are covered in a mix of disappointment and excitement. We are annoyed that things are not working. But, may be, may be we have uncovered some obscure bug somewhere in the toolset? We would learn later that this is the point where we should have known what&amp;rsquo;s up? But we didn&amp;rsquo;t and the story continues.&lt;/p&gt;
&lt;p&gt;At this point, we ping the Slack channels of the teams involved in building the library we consume. They have not seen this before. Someone suggests that they have had issues with Ruby inside Docker containers. We finally find a GitHub issue for a different project where someone encountered their container setting the &lt;code&gt;HTTP_PROXY&lt;/code&gt; env variable and that causing &lt;code&gt;Net::HTTP&lt;/code&gt; to fail. We pore over everything to make sure that there is no proxy set. What now?&lt;/p&gt;
&lt;p&gt;What if we attempt to connect to the new app from a Ruby process running on one of the other 10 containers we run?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; docker exec -it 51dbf9f75ca8 ruby -e &#39;require &amp;quot;net/http&amp;quot;; conn = Net::HTTP.new(&amp;quot;http://new-app.local&amp;quot;, 1313); conn.get(&amp;quot;/&amp;quot;)&#39;
Traceback (most recent call last):
.
.
.
SocketError (Failed to open TCP connection to http://new-app.local:1313 (getaddrinfo: nodename nor servname provided, or not known))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is interesting, isn&amp;rsquo;t it? Is it happening to only our systems? What if we just tried to hit Google?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; docker exec -it 51dbf9f75ca8 ruby -e &#39;require &amp;quot;net/http&amp;quot;; conn = Net::HTTP.new(&amp;quot;http://google.com&amp;quot;, 80); conn.get(&amp;quot;/&amp;quot;)&#39;
Traceback (most recent call last):
.
.
.
SocketError (Failed to open TCP connection to http://google.com:80 (getaddrinfo: nodename nor servname provided, or not known))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What if somehow our orchestration tool or containers created by us are causing it? Let&amp;rsquo;s try a random container from DockerHub:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; docker run -it ruby:2.5-slim ruby -e &#39;require &amp;quot;net/http&amp;quot;; conn = Net::HTTP.new(&amp;quot;http://google.com&amp;quot;,80); conn.get(&amp;quot;/&amp;quot;)&#39;
Traceback (most recent call last):
.
.
.
SocketError (Failed to open TCP connection to http://google.com:80 (getaddrinfo: nodename nor servname provided, or not known))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point, light bulbs are beginning to go off. Let&amp;rsquo;s try this on our laptops? Same result. And then it struck us. It says it can&amp;rsquo;t open a TCP connection to a URL with &lt;code&gt;http&lt;/code&gt; in it.  Of course, it cant. It should be looking for &lt;code&gt;google.com&lt;/code&gt;, should not it? Yes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-irb&#34;&gt;&amp;gt; docker run -it ruby:2.5-slim ruby -e &#39;require &amp;quot;net/http&amp;quot;; conn = Net::HTTP.new(&amp;quot;google.com&amp;quot;, 80); res = conn.get(&amp;quot;/&amp;quot;); puts res.code&#39;
301
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And with a lot of excitement and some shame, we realize that the library really meant &lt;code&gt;host&lt;/code&gt; when it asked for the &lt;code&gt;NEWAPP_HOST&lt;/code&gt; environment variable.&lt;/p&gt;
&lt;p&gt;I don&amp;rsquo;t think there are any big lessons in this story other than that, sometimes the simplest explanation of a problems makes a lot more sense than you would think it does. Also, if you ever use &lt;code&gt;Net::HTTP.new&lt;/code&gt;, remember that it expects you to provide a &lt;code&gt;host&lt;/code&gt; as the first param, not a URL.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Importing the Yelp dataset into MongoDB</title>
      <link>https://sadique.io/blog/2014/08/02/importing-the-yelp-dataset-into-mongodb/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sat, 02 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2014/08/02/importing-the-yelp-dataset-into-mongodb/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;Today Yelp announced their dataset challenge &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. The dataset they released includes data from 5 cities (Phoenix, Las Vegas, Madison, Waterloo and Edinburgh) and consists of&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;42,153 businesses&lt;/li&gt;
&lt;li&gt;320,002 business attributes&lt;/li&gt;
&lt;li&gt;31,617 check-in sets&lt;/li&gt;
&lt;li&gt;252,898 users&lt;/li&gt;
&lt;li&gt;955,999 edge social graph&lt;/li&gt;
&lt;li&gt;403,210 tips&lt;/li&gt;
&lt;li&gt;1,125,458 reviews&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The data is available for public consumption, although Yelp owns any derivative dataset you create from the original &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;The data is available as files with each line representing a JSON object. Since I am using MongoDB these days to analyze geospatial data, I wanted to convert this into an easy format that I could import into Mongo. Mongo puts a strict constraint on how a location needs to be specified - It expects a location field in a document to be an array in the format &lt;code&gt;[longitude, latitude]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With this in mind, the first step is to convert and transform the objects into objects that Mongo can make sense of. The following Ruby script does the job:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby

require &amp;quot;json&amp;quot;

businesses = IO.readlines(&amp;quot;yelp.business.json&amp;quot;).map do |line|
  b = JSON.parse(line)
  b[&amp;quot;location&amp;quot;] = {
    &amp;quot;type&amp;quot; =&amp;gt; &amp;quot;Point&amp;quot;,
    &amp;quot;coordinates&amp;quot; =&amp;gt; [b[&amp;quot;longitude&amp;quot;], b[&amp;quot;latitude&amp;quot;]]
  }
  b
end
IO.write &amp;quot;businesses.mongo.json&amp;quot;, businesses.to_json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next step is to import this data into Mongo using the &lt;code&gt;mongoimport&lt;/code&gt; tool.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mongoimport --collection businesses --file businesses.mongo.json --jsonArray
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need the &lt;code&gt;--jsonArray&lt;/code&gt; parameter because our data is an array.&lt;/p&gt;
&lt;p&gt;Since there are 42153 businesses, it will take some time. On my Macbook Pro, it took around 2 minutes, 10 seconds. Once the import is done, make sure that we have a Geospatial index on the &lt;code&gt;location&lt;/code&gt; field.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;db.businesses.ensureIndex({location: &amp;quot;2dsphere&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the indexing is done, we can use Mongo&amp;rsquo;s Geospatial queries to find interesting things. As an example, here we look up all the restaurants within 1 kilometer distance from downtown Phoenix.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;db.businesses.find({
  location: {
    $near: {
      $geometry: {
	type: &amp;quot;Point&amp;quot;,
	coordinates: [-112.0667, 33.4500]
      },
      $maxDistance: 1000
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Happy hacking.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://www.yelp.com/dataset_challenge&#34;&gt;Yelp Dataset Challenge, 2014&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;DATASET CHALLENGE ACADEMIC DATASET TERMS OF USE &lt;a href=&#34;https://www.yelp.com/html/pdf/Dataset_Challenge_Academic_Dataset_Agreement.pdf&#34;&gt;Section 5, Ownership&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Implementing Rate Limiting in Rails - Part 2</title>
      <link>https://sadique.io/blog/2013/10/13/implementing-rate-limiting-in-rails-part-2/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sun, 13 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2013/10/13/implementing-rate-limiting-in-rails-part-2/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;&lt;em&gt;The first part of this series can be found &lt;a href=&#34;https://sadique.io/blog/2013/10/12/implementing-rate-limiting-in-rails-part-1/&#34;&gt;here&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The first part of this series looked at how to implement basic rate limiting in a Rails application. However, as pointed out in the improvements section, the implementation was not complete - it did not provide clients enough information about the rate limiting that is in place and how long they should wait before making further requests once they hit the limit.&lt;/p&gt;
&lt;p&gt;In order to tell the client about the rate limit parameters, the mechanism needs to be able to set headers on the response. While a &lt;code&gt;before_filter&lt;/code&gt; is useful to limit the requests, it can not change the response from a valid request. One could use an &lt;code&gt;after_filter&lt;/code&gt; to achieve this, but a Rack middleware &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; is a more suitable solution given that middlewares can act up on a request as well as the response generated by the application for that request.&lt;/p&gt;
&lt;p&gt;We will need to comment out the &lt;code&gt;before_filter&lt;/code&gt; that was introduced in Part 1. Then we will define a blank middleware and wire it up. The convention is to define middlwares in &lt;code&gt;app/middleware&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;
# app/middleware/rate_limit.rb

class RateLimit
  def initialize(app)
    @app = app
  end

  def call(env)
    @app.env
  end
end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This middleware is wired up as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;
# config/application.rb

class Application &amp;lt; Rails::Application
  ...
  config.middleware.use &amp;quot;RateLimit&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;basic-rate-limiting&#34;&gt;Basic Rate Limiting&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s re-implement what we implemented in Part 1 using the middleware.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def call(env)
    client_ip = env[&amp;quot;REMOTE_ADDR&amp;quot;]
    key = &amp;quot;count:#{client_ip}&amp;quot;
    count = REDIS.get(key)
    unless count
      REDIS.set(key, 0)
      REDIS.expire(key, THROTTLE_TIME_WINDOW)
    end

    if count.to_i &amp;gt;= THROTTLE_MAX_REQUESTS
      [
       429,
       {},
       [message]
      ]
    else
      REDIS.incr(key)
      @app.call(env)
    end
  end

  private
  def message
    {
      :message =&amp;gt; &amp;quot;You have fired too many requests. Please wait for some time.&amp;quot;
    }.to_json
  end

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;rate-limit-status&#34;&gt;Rate limit status&lt;/h3&gt;
&lt;p&gt;There are various header conventions for providing a client it&amp;rsquo;s rate limit status. For this example, we will use the convention that GitHub &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; and Twitter &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; use. The following headers represent the rate limit status:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;X-RateLimit-Limit&lt;/code&gt; - The maximum number of requests that the client is permitted to make in the time window.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X-RateLimit-Remaining&lt;/code&gt; - The number of requests remaining in the current rate limit window.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X-RateLimit-Reset&lt;/code&gt; - The time at which the current rate limit window resets in UTC epoch seconds &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The middleware will set these headers for all requests with the following change:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def call(env)
    client_ip = env[&amp;quot;REMOTE_ADDR&amp;quot;]
    key = &amp;quot;count:#{client_ip}&amp;quot;
    count = REDIS.get(key)
    unless count
      REDIS.set(key, 0)
      REDIS.expire(key, THROTTLE_TIME_WINDOW)
    end

    if count.to_i &amp;gt;= THROTTLE_MAX_REQUESTS
      [
       429,
       rate_limit_headers(count, key),
       [message]
      ]
    else
      REDIS.incr(key)
      status, headers, body = @app.call(env)
      [
       status,
       headers.merge(rate_limit_headers(count.to_i + 1, key)),
       body
      ]
    end
  end

  private
  def message
    {
      :message =&amp;gt; &amp;quot;You have fired too many requests. Please wait for some time.&amp;quot;
    }.to_json
  end

  def rate_limit_headers(count, key)
    ttl = REDIS.ttl(key)
    time = Time.now.to_i
    time_till_reset = (time + ttl.to_i).to_s
    {
      &amp;quot;X-Rate-Limit-Limit&amp;quot; =&amp;gt;  &amp;quot;60&amp;quot;,
      &amp;quot;X-Rate-Limit-Remaining&amp;quot; =&amp;gt; (60 - count.to_i).to_s,
      &amp;quot;X-Rate-Limit-Reset&amp;quot; =&amp;gt; time_till_reset
    }
  end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This computes the time remaining till the limit is reset and the number of requests remaining and sets the appropriate headers.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s test this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash$ for i in {1..100}
do
curl -i http://localhost:3000/foo.json &amp;gt;&amp;gt; /tmp/headers.log
done

bash$ less /tmp/headers.log | grep X-Rate-Limit
X-Rate-Limit-Limit: 60
X-Rate-Limit-Remaining: 59
X-Rate-Limit-Reset: 1381717125
X-Rate-Limit-Limit: 60
X-Rate-Limit-Remaining: 58
X-Rate-Limit-Reset: 1381717125
...
X-Rate-Limit-Limit: 60
X-Rate-Limit-Remaining: 1
X-Rate-Limit-Reset: 1381717124
X-Rate-Limit-Limit: 60
X-Rate-Limit-Remaining: 0
X-Rate-Limit-Reset: 1381717124
X-Rate-Limit-Limit: 60
X-Rate-Limit-Remaining: 0
X-Rate-Limit-Reset: 1381717124
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code for this implementation is on my &lt;a href=&#34;https://github.com/sdqali/rails_throttle&#34;&gt;GitHub profile&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;RailsCast &lt;a href=&#34;http://railscasts.com/episodes/151-rack-middleware&#34;&gt;#151 - Rack Middleware&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;GitHub API V3 - &lt;a href=&#34;http://developer.github.com/v3/#rate-limiting&#34;&gt;Rate limiting&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;Twitter - &lt;a href=&#34;https://dev.twitter.com/docs/rate-limiting/1.1&#34;&gt;REST API Rate Limiting in v1.1&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Wikipedia - Unix time - &lt;a href=&#34;https://en.wikipedia.org/wiki/Unix_time#Encoding_time_as_a_number&#34;&gt;Encoding time as a number&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Implementing Rate Limiting in Rails - Part 1</title>
      <link>https://sadique.io/blog/2013/10/12/implementing-rate-limiting-in-rails-part-1/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sat, 12 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2013/10/12/implementing-rate-limiting-in-rails-part-1/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;&lt;em&gt;The second part of this series can be found &lt;a href=&#34;https://sadique.io/blog/2013/10/13/implementing-rate-limiting-in-rails-part-2/&#34;&gt;here&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Rate limiting or throttling is the practice of limiting how frequently legitimate users of a web service can access the service. Rate limiting is often put in place to prevent the hogging of resources by a sub set of the users of the system. Rate limiting works by responding with error messages when a client exceeds their allocated share of requests within a predefined time window. In addition to the error message, the response should also include information as to when rate limit will be reset so that the client can continue accessing the system after the reset.&lt;/p&gt;
&lt;p&gt;What we need is a way to record the number of requests each client is making and reset this number to zero after a predefined time period and decide for each request whether the client making the request has exceeded the limits.&lt;/p&gt;
&lt;h3 id=&#34;the-test-application&#34;&gt;The test application&lt;/h3&gt;
&lt;p&gt;We will create a simple Rails application with a single API endpoint at &lt;code&gt;foo.json&lt;/code&gt;. The code needed for this is as follows:&lt;/p&gt;
&lt;p&gt;Routes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb

RailsThrottle::Application.routes.draw do
  get &#39;foo.json&#39; =&amp;gt; &#39;foo#index&#39;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The controller:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/foo_controller.rb

class FooController &amp;lt; ApplicationController
  def index
    render json: {foo: :bar}
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;storing-the-rate-data&#34;&gt;Storing the rate data&lt;/h3&gt;
&lt;p&gt;We need a place to store each client&amp;rsquo;s IP address and the number of requests it made. We need to increment this count for each request and reset the count to zero after a time period. Considering these needs, &lt;a href=&#34;http://redis.io/&#34;&gt;Redis&lt;/a&gt; is a great fit for this data store. Redis stores key value pairs and allows expiry time to be specified for each entry. Redis also comes with an &lt;code&gt;INCR&lt;/code&gt; &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; command that ensures that increment operations are atomic. This will be useful to us if we were to run multiple instances of our app behind a load balancer.&lt;/p&gt;
&lt;p&gt;To setup the application to use Redis, we will need to install the &lt;code&gt;redis&lt;/code&gt; &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; gem. Once we have the gem, we will add a new &lt;code&gt;initializer&lt;/code&gt; named &lt;code&gt;throttle.rb&lt;/code&gt; which configures our Redis client.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/throttle.rb

require &amp;quot;redis&amp;quot;

redis_conf  = YAML.load(File.join(Rails.root, &amp;quot;config&amp;quot;, &amp;quot;redis.yml&amp;quot;))
REDIS = Redis.new(:host =&amp;gt; redis_conf[&amp;quot;host&amp;quot;], :port =&amp;gt; redis_conf[&amp;quot;port&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will load the Redis server&amp;rsquo;s host and port from the configuration file located at &lt;code&gt;config/redis.yml&lt;/code&gt;. This file will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# config/redis.yml

host: localhost
port: 6379
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;using-a-before_filter-for-rate-limiting&#34;&gt;Using a &lt;code&gt;before_filter&lt;/code&gt; for rate limiting.&lt;/h3&gt;
&lt;p&gt;The first step is to log the number of requests each client is making. This can easily be achieved with a &lt;code&gt;before_filter&lt;/code&gt; &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. Let&amp;rsquo;s add the filter into the &lt;code&gt;ApplicationController&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/application_controller.rb

class ApplicationController &amp;lt; ActionController::Base
  ...

  before_filter :throttle

  def throttle
    client_ip = request.env[&amp;quot;REMOTE_ADDR&amp;quot;]
    key = &amp;quot;count:#{client_ip}&amp;quot;
    count = REDIS.get(key)

    unless count
      REDIS.set(key, 0)
    end
    REDIS.incr(key)
    true
  end

  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since this &lt;code&gt;before_filter&lt;/code&gt; belongs to the &lt;code&gt;ApplicationController&lt;/code&gt;, it will be applied to all requests, unless a specific controller chooses to skip it. So before every request is processed, the filter grabs the client&amp;rsquo;s IP and checks whether there is a count in Redis for this IP. If there is no count key, it creates one. Finally it increments the count.&lt;/p&gt;
&lt;p&gt;At this point, the filter just records the requests made, but does not limit requests. Let&amp;rsquo;s go ahead and implement limiting. We need to specify the time window for rate limiting and how many requests should be allowed in that time window. We will allow a client a maximum of &lt;code&gt;60&lt;/code&gt; requests in &lt;code&gt;15&lt;/code&gt; minutes. The following constants need to be defined in &lt;code&gt;throttle.rb&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;THROTTLE_TIME_WINDOW = 15 * 60
THROTTLE_MAX_REQUESTS = 60
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The filter needs to be changed to respond with error messages when the rate limit is exceeded.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/application_controller.rb

class ApplicationController &amp;lt; ActionController::Base
  ...

  before_filter :throttle

  def throttle
    client_ip = request.env[&amp;quot;REMOTE_ADDR&amp;quot;]
    key = &amp;quot;count:#{client_ip}&amp;quot;
    count = REDIS.get(key)

    unless count
      REDIS.set(key, 0)
      REDIS.expire(key, THROTTLE_TIME_WINDOW)
      return true
    end

    if count.to_i &amp;gt;= THROTTLE_MAX_REQUESTS
      render :status =&amp;gt; 429, :json =&amp;gt; {:message =&amp;gt; &amp;quot;You have fired too many requests. Please wait for some time.&amp;quot;}
      return
    end
    REDIS.incr(key)
    true
  end

  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the limit is reached, subsequent requests will be responded with an error message and the HTTP status code &lt;code&gt;429&lt;/code&gt;. The 429 &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; status code indicates that the user has sent too many requests in a given amount of time.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s go ahead and test this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash$ for i in {1..100}
do
curl -i http://localhost:3000/foo.json &amp;gt;&amp;gt; /dev/null
done

bash$ less log/development.log | grep &amp;quot;200 OK&amp;quot; | wc -l
      60

bash$ less log/development.log | grep &amp;quot;429 Too Many Requests&amp;quot; | wc -l
      40

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see after &lt;code&gt;60&lt;/code&gt; requests, all requests get the &lt;code&gt;429&lt;/code&gt; response.&lt;/p&gt;
&lt;h3 id=&#34;improvements&#34;&gt;Improvements&lt;/h3&gt;
&lt;p&gt;While what we have implemented limits the requests, it does not give the client enough information as to how long it has to wait before making requests again. It would also be helpful if the server tells the client on each request how many total requests it is allowed to make in a window and how many more requests it can perform before limiting kicks in. We will look at this in the next blog post.&lt;/p&gt;
&lt;p&gt;A sample application with this rate limiting in place is on &lt;a href=&#34;https://github.com/sdqali/rails_throttle/tree/filter&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://redis.io/commands/incr&#34;&gt;Redis documentation&lt;/a&gt; for INCR command.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://rubygems.org/gems/redis&#34;&gt;redis&lt;/a&gt; - A Ruby client that tries to match Redis&amp;rsquo; API one-to-one, while still providing an idiomatic interface. It features thread-safety, client-side sharding, pipelining, and an obsession for performance.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;Rails&amp;rsquo; &lt;a href=&#34;http://apidock.com/rails/AbstractController/Callbacks/ClassMethods/before_filter&#34;&gt;before filter&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;IETF: Additional HTTP Status Codes - &lt;a href=&#34;https://tools.ietf.org/html/rfc6585#section-4&#34;&gt;429 Too Many Requests&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Ruby, Named Capture Groups and Local Variables</title>
      <link>https://sadique.io/blog/2013/10/01/ruby-named-capture-groups-and-local-variables/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Tue, 01 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2013/10/01/ruby-named-capture-groups-and-local-variables/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;Ruby&amp;rsquo;s regular expressions support &lt;a href=&#34;https://sadique.io/blog/2013/09/29/named-capture-groups-in-regular-expressions/&#34;&gt;named capture groups&lt;/a&gt;, since 1.9. However, there is a weird behaviour while using named capture groups with the &lt;code&gt;Regexp#=~&lt;/code&gt; method. When named capture groups are used with &lt;code&gt;=~&lt;/code&gt;, the captured values are placed in local variables with the same name as the capture group. The following example demonstrates this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby

month = &amp;quot;January&amp;quot;
test_string = &amp;quot;Today&#39;s date is: 9/28/2013.&amp;quot;
/(?&amp;lt;month&amp;gt;\d{1,2})\/(?&amp;lt;day&amp;gt;\d{1,2})\/(?&amp;lt;year&amp;gt;\d{4})/ =~ test_string
puts month.inspect
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This when executed will print &lt;code&gt;9&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The official documentation &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When named capture groups are used with a literal regexp on the left-hand side of an expression and the =~ operator, the captured text is also assigned to local variables with corresponding names.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This local variable assignment does not happen if the regular expression is on the right-hand side of the expression or the regular expression contains a variable interpolation.&lt;/p&gt;
&lt;h3 id=&#34;regexp-on-right-hand-side&#34;&gt;Regexp on right-hand side&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby

month = &amp;quot;January&amp;quot;
test_string = &amp;quot;Today&#39;s date is: 9/28/2013.&amp;quot;
test_string =~ /(?&amp;lt;month&amp;gt;\d{1,2})\/(?&amp;lt;day&amp;gt;\d{1,2})\/(?&amp;lt;year&amp;gt;\d{4})/
puts month.inspect
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will print &lt;code&gt;January&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;regexp-with-interpolation&#34;&gt;Regexp with interpolation&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby

month = &amp;quot;January&amp;quot;
DAY = &amp;quot;day&amp;quot;
test_string = &amp;quot;Today&#39;s date is: 9/28/2013.&amp;quot;
/(?&amp;lt;month&amp;gt;\d{1,2})\/(?&amp;lt;#{DAY}&amp;gt;\d{1,2})\/(?&amp;lt;year&amp;gt;\d{4})/ =~ test_string
puts month.inspect
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will print &lt;code&gt;January&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This behaviour is present only for the &lt;code&gt;Regexp#=~&lt;/code&gt; method and not for &lt;code&gt;Regexp#match&lt;/code&gt;. So it is safer to use the latter without worrying about unintended side effects.&lt;/p&gt;
&lt;p&gt;PS: Hat tip to &lt;a href=&#34;http://www.nilenso.com/people.html#gja&#34;&gt;Tejas&lt;/a&gt; for telling me about this quirk.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Ruby docs for &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.3/Regexp.html#label-Capturing&#34;&gt;Class: Regexp (Ruby 1.9.3)&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Named Capture Groups in Regular Expressions</title>
      <link>https://sadique.io/blog/2013/09/29/named-capture-groups-in-regular-expressions/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sun, 29 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2013/09/29/named-capture-groups-in-regular-expressions/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;I will admit that I find regular expressions somewhat hard to parse. While the thinking process needed to write a regular expression is iterative and hence results in the correct expression suitable for the situation, once it is written it lacks readability. I have faced that pain of trying to grok a complex regular expression written years ago. So I was pleasantly surprised when I saw &lt;a href=&#34;https://news.ycombinator.com/item?id=6463144&#34;&gt;this example&lt;/a&gt; from Hacker News user &lt;em&gt;WestCoastJustin&lt;/em&gt;. I found it very easy to understand because of the names he had assigned to each capture group in the expression.&lt;/p&gt;
&lt;h2 id=&#34;ruby&#34;&gt;Ruby&lt;/h2&gt;
&lt;p&gt;Ruby has supported named capture groups since version 1.9. Each match group is named by using &lt;code&gt;?&amp;lt;name&amp;gt;&lt;/code&gt; inside the match group and these matches are made available has a hash and each match can be accessed by using the match group name as the key.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;WestCoastJustin&lt;/em&gt;&amp;rsquo;s example will look like this in Ruby:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby

test_string = &amp;quot;Today&#39;s date is: 9/28/2013.&amp;quot;

match = test_string.match /(?&amp;lt;month&amp;gt;\d{1,2})\/(?&amp;lt;day&amp;gt;\d{1,2})\/(?&amp;lt;year&amp;gt;\d{4})/
puts match.inspect
puts match[:month]
puts match[:day]
puts match[:year]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is much easier to understand because looking at it, it makes it clear that the intent of matching the first group of 1 or 2 digits is to look for the &lt;strong&gt;month&lt;/strong&gt; in the date. Similarly, the intent of the &lt;em&gt;day&lt;/em&gt; and &lt;em&gt;year&lt;/em&gt; matches are easier to understand.&lt;/p&gt;
&lt;p&gt;This will result in:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; ruby /tmp/named_matches.rb
#&amp;lt;MatchData &amp;quot;9/28/2013&amp;quot; month:&amp;quot;9&amp;quot; day:&amp;quot;28&amp;quot; year:&amp;quot;2013&amp;quot;&amp;gt;
9
28
2013
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##Python
Python&amp;rsquo;s &lt;code&gt;re&lt;/code&gt; module supports named match groups using the &lt;code&gt;?P&amp;lt;name&amp;gt;&lt;/code&gt; pattern. After a pattern search, the results are placed in a &lt;code&gt;dict&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env ruby

import re

test_string = &amp;quot;Today&#39;s date is: 9/28/2013.&amp;quot;
pattern = re.compile(r&amp;quot;(?P&amp;lt;month&amp;gt;\d{1,2})\/(?P&amp;lt;day&amp;gt;\d{1,2})\/(?P&amp;lt;year&amp;gt;\d{4})&amp;quot;)
match_dict = pattern.search(test_string).groupdict()
print(match_dict)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JavaScript does not support named capture groups. There are a lot of &lt;a href=&#34;http://trentrichardson.com/2011/08/02/javascript-regexp-match-named-captures/&#34;&gt;hacks&lt;/a&gt; aimed at providing this functionality. The XRegExp library &lt;a href=&#34;http://xregexp.com/syntax/#namedCapture&#34;&gt;supports&lt;/a&gt; named capture groups.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Managing Gemsets in Rbenv</title>
      <link>https://sadique.io/blog/2013/09/12/managing-gemsets-in-rbenv/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Thu, 12 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2013/09/12/managing-gemsets-in-rbenv/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;When I was setting up my new laptop today, I decided to use Rbenv &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; to manage my Ruby versions. I have typically used RVM &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; and had never used Rbenv. Rbenv is a Ruby version manager written by &lt;a href=&#34;https://github.com/sstephenson/&#34;&gt;Sam Stephenson&lt;/a&gt; and deliberately tries to do less and do it well. Instead of overriding Bash commands like RVM does, Rbenv chooses to use wrappers or &lt;strong&gt;shims&lt;/strong&gt; around Ruby binaries to choose the Ruby executable to run.&lt;/p&gt;
&lt;p&gt;This works well, until you have to manage Gemsets &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. Often, one is working on two projects that use the same version of Ruby, but has entirely different chain of dependency on Gems. RVM&amp;rsquo;s gemsets work really well for this use case. I was looking around to see how one would manage gemsets with Rbenv. There are three ways to do it.&lt;/p&gt;
&lt;h2 id=&#34;use-the-rbenv-gemset-plugin&#34;&gt;Use the &lt;code&gt;rbenv-gemset&lt;/code&gt; plugin&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/jf&#34;&gt;Jeffrey Lim&lt;/a&gt;&amp;rsquo;s &lt;code&gt;rbenv-gemset&lt;/code&gt;&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; plugin forces Rbenv to look in a specific path for gems. A typical workflow of using the plugin will be as follows.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Specify the gemset by adding it&amp;rsquo;s name to a &lt;code&gt;rbenv-gemsets&lt;/code&gt; file in the root directory of the project.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat rbenv-gemsets
$ .gems
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Install the gems, by using &lt;code&gt;gem install&lt;/code&gt; or with bundler.&lt;/li&gt;
&lt;li&gt;The gems will be installed in &lt;code&gt;.gems&lt;/code&gt; directory under the project root.&lt;/li&gt;
&lt;li&gt;Ruby will look for gems in the &lt;code&gt;.gems&lt;/code&gt; directory.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;use-bundler-to-manage-gemsets&#34;&gt;Use bundler to manage gemsets&lt;/h2&gt;
&lt;p&gt;In this approach, we will be using bundler&amp;rsquo;s &lt;code&gt;--path&lt;/code&gt; flag to install the gemset to a local directory and then wrap all calls with &lt;code&gt;bundle exec&lt;/code&gt;. A typical workflow in this case will look like this.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Install gems to a &lt;code&gt;.gems&lt;/code&gt; directory using bundler&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle install --path .gems
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Wrap calls with &lt;code&gt;bundle exec&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec rake --version
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;use-a-devenv-file&#34;&gt;Use a devenv file&lt;/h2&gt;
&lt;p&gt;This is a hacky way doing things and it was the first that came to my mind when I was looking at this problem. This approach involves adding a project specific &lt;code&gt;devenv&lt;/code&gt; file that is sourced when one starts to work on that project. This file will set the &lt;code&gt;GEM_HOME&lt;/code&gt; and &lt;code&gt;GEM_PATH&lt;/code&gt; environment variables to the directory where the gemset is supposed to live as well as prepend the &lt;code&gt;gems/bin&lt;/code&gt; directory of the gemset to &lt;code&gt;PATH&lt;/code&gt;. An example &lt;code&gt;devenv&lt;/code&gt; file will be as follows&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export GEM_PATH=./.gems
export GEM_HOME=./.gems
export PATH=./.gems/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the end, I ended up choosing the &lt;code&gt;bundler&lt;/code&gt; approach. I use bundler in most of my Ruby projects anyway. The downside to this is that every invocation will be spawning a &lt;code&gt;bundler&lt;/code&gt; process, in addition to whatever we intend to do.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Rbenv is used to pick a Ruby version for an application and guarantee that the development environment matches production. &lt;a href=&#34;https://github.com/sstephenson/rbenv&#34;&gt;Rbenv - Groom your appâ€™s Ruby environment&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;RVM is a command-line tool which allows you to easily install, manage, and work with multiple ruby environments from interpreters to sets of gems. &lt;a href=&#34;https://rvm.io/&#34;&gt;RVM - Cut Rubies with ease!&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;Gemsets are collection of Ruby gems specific to a project. This &lt;a href=&#34;http://stackoverflow.com/questions/11086661/why-should-i-use-application-specific-rvm-gemsets-in-addition-to-bundler&#34;&gt;StackOverflow question&lt;/a&gt; answers why one should use gemsets.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/jf/rbenv-gemset&#34;&gt;&lt;code&gt;rbenv-gemsets&lt;/code&gt; - Gem management for Rbenv&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Looking up Compiler params used to compile a Ruby version</title>
      <link>https://sadique.io/blog/2013/09/08/looking-up-compiler-params-used-to-compile-a-ruby-version/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sun, 08 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2013/09/08/looking-up-compiler-params-used-to-compile-a-ruby-version/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;Today &lt;a href=&#34;https://twitter.com/kgrz&#34;&gt;Kashyap&lt;/a&gt; asked how one can identify the compiler parameters passed when compiling a Ruby version. I was curious how to achieve this and like any confused developer started searching for and looking in the Ruby documentation. Searching for &lt;strong&gt;compiler parameters in ruby&lt;/strong&gt; did not yield any interesting results and the group of constants with the &lt;code&gt;RUBY_&lt;/code&gt; prefix &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; loaded in Ruby did not include anything related to compiler flags. Then I came across this blog post &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; by &lt;a href=&#34;https://twitter.com/happycode&#34;&gt;Jan Lelis&lt;/a&gt; and I was curious what else &lt;code&gt;RbConfig::CONFIG&lt;/code&gt; contains. This hash contains all the compiler flags used to compile the current Ruby VM.&lt;/p&gt;
&lt;p&gt;This code snippet prints the hash.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#! /usr/bin/env ruby

require &amp;quot;rbconfig&amp;quot;

RbConfig::CONFIG.each do |k, v|
  puts &amp;quot;#{k} - #{v}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When this is executed under Ruby 1.9.3p194  under OS X, a section of the output will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;target_vendor - apple
target_os - darwin12.2.1
CC - gcc-4.2
CFLAGS -  -O3 -ggdb -Wextra -Wno-unused-parameter -Wno-parentheses -Wno-long-long -Wno-missing-field-initializers -Werror=pointer-arith -Werror=write-strings -Werror=declaration-after-statement -Werror=shorten-64-to-32 -Werror=implicit-function-declaration -I/Users/sdqali/.rvm/usr/include -fno-common -pipe
LDFLAGS - -L. -L/Users/sdqali/.rvm/usr/lib -L/usr/local/lib
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;These constants are &lt;code&gt;RUBY_COPYRIGHT&lt;/code&gt;, &lt;code&gt;RUBY_DESCRIPTION&lt;/code&gt;, &lt;code&gt;RUBY_ENGINE&lt;/code&gt;, &lt;code&gt;RUBY_PATCHLEVEL&lt;/code&gt;, &lt;code&gt;RUBY_PLATFORM&lt;/code&gt;, &lt;code&gt;RUBY_RELEASE_DATE&lt;/code&gt;, &lt;code&gt;RUBY_REVISION&lt;/code&gt; and &lt;code&gt;RUBY_VERSION&lt;/code&gt; on Ruby 1.9.3p194.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Jan Lelis: &lt;a href=&#34;http://rbjl.net/35-how-to-properly-check-for-your-ruby-interpreter-version-and-os&#34;&gt;How to properly check for your Ruby interpreter, version and OS&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Heredocs in Ruby and Python</title>
      <link>https://sadique.io/blog/2012/07/04/heredocs-in-ruby-and-python/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Wed, 04 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2012/07/04/heredocs-in-ruby-and-python/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;I have been doing some coding in Python recently. While playing around with some code, I noticed that the way &lt;a href=&#34;http://en.wikipedia.org/wiki/Here_document&#34;&gt;heredocs&lt;/a&gt; are used in Python is different from Ruby.&lt;/p&gt;
&lt;h2 id=&#34;python&#34;&gt;Python&lt;/h2&gt;
&lt;p&gt;Consider the following snippet:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# test.py

print &amp;quot;some text in single line&amp;quot;

print &amp;quot;&amp;quot;&amp;quot;
As opposed to
some text
written as
heredoc
&amp;quot;&amp;quot;&amp;quot;
print &amp;quot;and then another single line&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When run, this would result in this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-3.2$ python test.py
some text in single line

As opposed to
some text
written as
heredoc

and then another single line
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice how there is a preceding and trailing linebreak around the string printed using heredoc.&lt;/p&gt;
&lt;p&gt;I spent a lot of time trying to figure out how and why this was happening. Finally, help came from &lt;code&gt;@dibb&lt;/code&gt; on &lt;code&gt;#python&lt;/code&gt;. Looks like I was doing it wrong. In Python, the useful part of the heredoc starts immediately after the &lt;code&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;. So if you don&amp;rsquo;t want those excess linebreaks, you should write something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# test2.py

print &amp;quot;some text in single line&amp;quot;

print &amp;quot;&amp;quot;&amp;quot;As opposed to
some text
written as
heredoc&amp;quot;&amp;quot;&amp;quot;

print &amp;quot;and then another single line&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When run, this would print the text without the extra line breaks:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-3.2$ python test2.py
some text in single line
As opposed to
some text
written as
heredoc
and then another single line
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&amp;rsquo;t want to write the string just after the &lt;code&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;, you could use a &lt;code&gt;\&lt;/code&gt; to remove the linebreaks, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# test3.py

print &amp;quot;&amp;quot;&amp;quot;\
As opposed to
some text
written as
heredoc\
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ruby&#34;&gt;Ruby&lt;/h2&gt;
&lt;p&gt;I come from the Ruby world, where the heredocs behave in a slightly different way. The equivalent code in Ruby would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# test.rb

puts &amp;quot;some text in single line&amp;quot;

puts &amp;lt;&amp;lt;-STR
As opposed to
some text
written as
heredoc
STR

puts &amp;quot;and then another single line&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice how the actual content of the heredoc begins only on the line after &lt;code&gt;&amp;lt;&amp;lt;-STR&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;I hope being aware of this detail saves you some time.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Know Your Tools - Don&#39;t Shoot Yourself in the Foot</title>
      <link>https://sadique.io/blog/2012/06/06/know-your-tools-dont-shoot-yourself-in-the-foot/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Wed, 06 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2012/06/06/know-your-tools-dont-shoot-yourself-in-the-foot/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;Imagine this - Your build is taking forever. You put in a lot of effort and restructure it. Things improve a lot, but it is far from where you would like it to be. You try hard to identify things that could improve the build time, but fail. You blame the platforms you use, you blame Ruby and you even blame the relative position of the Moon to Venus. Slowly you learn to accept the slow build as a part of your life. Months later a new developer joins the team and proves that there is a bug in the build scripts that causes certain tasks to be run twice.&lt;/p&gt;
&lt;p&gt;This happened to us recently, and the subsequent debugging/postmortem revealed that there were things about our tools that we simply did not know.&lt;/p&gt;
&lt;h2 id=&#34;a-bit-of-context&#34;&gt;A bit of context&lt;/h2&gt;
&lt;p&gt;Ours is a Java code base, but we use Rake for our build scripts. We have been using Ruby 1.8.7 and Rake 0.8.7. We never got around to upgrading the Ruby versions due to a number of reasons including one of our gems breaking on 1.9.3 and more importantly our laziness. Well, laziness will cause you damage in the end and that is what happened to us.&lt;/p&gt;
&lt;h2 id=&#34;what-is-the-issue-&#34;&gt;What is the issue ?&lt;/h2&gt;
&lt;h3 id=&#34;that-step-is-not-running-multiple-times-is-it&#34;&gt;&amp;ldquo;That step is not running multiple times, is it?&amp;rdquo;&lt;/h3&gt;
&lt;p&gt;While debugging our build, our new developer discovered that certain tasks that take up 10 minutes to complete were being executed twice. We soon started trying to figure out where in the chain of Rake task calls did we end up repeating a task. There were none. After some time, we would learn that we did not know enough about Rake and Ruby 1.8.7&lt;/p&gt;
&lt;h3 id=&#34;rakes-redefining-behavior&#34;&gt;Rake&amp;rsquo;s redefining behavior&lt;/h3&gt;
&lt;p&gt;Rake treats redefining a Task as akin to appending actions to the same Task. To see this in action, add the following to a Rakefile:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;task :foo do
  puts &amp;quot;foo &amp;quot; * 10
end

task :foo do
  puts &amp;quot;bar &amp;quot; * 10
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the &lt;code&gt;foo&lt;/code&gt; task, you would get:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$rake foo
foo foo foo foo foo foo foo foo foo foo
bar bar bar bar bar bar bar bar bar bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is far removed from behaviors of Ruby and &lt;a href=&#34;http://www.gnu.org/software/make/&#34; title=&#34;Make&#34;&gt;Make&lt;/a&gt;, the tools that inspired Rake. For clarity&amp;rsquo;s sake, this is how Ruby treats redefinitions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby
#example.rb

def example
  puts &amp;quot;example &amp;quot; * 10
end

def example
  puts &amp;quot;foobar &amp;quot; * 10
end

example
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ruby example.rb
foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets take a look at Make&amp;rsquo;s behavior. This is how Make treats redefinitions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;# Example Makefile

foo:
    @echo Foo target
foo:
    @echo Redefined foo target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$make foo
Makefile:6: warning: overriding commands for target `foo&#39;
Makefile:4: warning: ignoring old commands for target `foo&#39;
Redefined foo target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While this behavior of Rake may seem weird, there are some advantages to it like the ability to add custom behavior to third party Rake tasks. I asked &lt;a href=&#34;https://twitter.com/#!/jimweirich&#34;&gt;Jim Weirich&lt;/a&gt;, the creator of Rake and he was &lt;a href=&#34;http://www.quora.com/Ruby-programming-language/Why-did-Rake-choose-to-treat-a-re-definition-as-a-multiple-definition-instead-of-an-overwrite&#34;&gt;of the opinion&lt;/a&gt; that it was a useful choice. &lt;em&gt;We were &lt;strong&gt;not&lt;/strong&gt; aware of this particular behavior of Rake.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Under normal situations, this behavior should not cause us trouble, as it is unlikely that we would redefine our own Rake tasks. But this combined with the next issue led to some of our build tasks running twice.&lt;/p&gt;
&lt;h3 id=&#34;ruby-187s-multiple-require-issue&#34;&gt;Ruby 1.8.7&amp;rsquo;s multiple require issue&lt;/h3&gt;
&lt;p&gt;It turns out that in Ruby 1.8.7, whenever a file is &lt;code&gt;require&lt;/code&gt;d multiple times, Ruby decides whether to reload it based on the path of the file provided. So if you have the same file being required twice, but using different paths, the file will be loaded twice. If there are Rake tasks defined in that file, the effect of actions in the Rake task will be multiplied.&lt;/p&gt;
&lt;p&gt;Again, this can be best demonstrated with an example. Consider the following scenario. There is a paent directory with &lt;code&gt;Rakefile&lt;/code&gt;, &lt;code&gt;zoo.rb&lt;/code&gt; and a directory &lt;code&gt;subdir&lt;/code&gt; with the file &lt;code&gt;bar.rb&lt;/code&gt; inside it.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;zoo.rb&lt;/code&gt; defines a Rake task &lt;code&gt;print_zoo&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# zoo.rb

desc &amp;quot;prints zoo&amp;quot;
task :print_zoo do
  puts &amp;quot;zoo &amp;quot; * 10
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bar.rb&lt;/code&gt; in the directory &lt;code&gt;subdir&lt;/code&gt; does nothing but require &lt;code&gt;zoo&lt;/code&gt; in the parent directory.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#subdir/bar.rb

require File.dirname(__FILE__) + &amp;quot;/../zoo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Rakefile requires both &lt;code&gt;zoo.rb&lt;/code&gt; and &lt;code&gt;bar.rb&lt;/code&gt; and defines a task to show the behavior.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require File.dirname(__FILE__) + &amp;quot;/zoo&amp;quot;
require File.dirname(__FILE__) + &amp;quot;/subdir/bar&amp;quot;

desc &amp;quot;show weirdness&amp;quot;
task :test =&amp;gt; :print_zoo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now if we run the &lt;code&gt;test&lt;/code&gt; task:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$rake test
zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo
zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets take a step back and think about that. If we load Ruby files multiple times using &lt;code&gt;require&lt;/code&gt; we can easily end up repeating a build step that would take 30 minutes to complete.&lt;/p&gt;
&lt;p&gt;I must note that this issue does not happen on Ruby 1.9.3, where files are being loaded only once. All the code I showed here is available &lt;a href=&#34;https://github.com/sdqali/rake_sandbox&#34;&gt;here&lt;/a&gt;, if you want to take a closer look.&lt;/p&gt;
&lt;h2 id=&#34;learning&#34;&gt;Learning&lt;/h2&gt;
&lt;p&gt;This is not meant to be a criticism of Rake or Ruby. Although Rake&amp;rsquo;s behavior in this scenario looks weird, there are good reasons why Jim chose that behavior. And we should have moved to Ruby 1.9.3 anyway.  Certainly the learning is that we need to have a better understanding of the tools we use daily.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Wikipedia Page Hopping</title>
      <link>https://sadique.io/blog/2011/05/17/wikipedia-page-hopping/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Tue, 17 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2011/05/17/wikipedia-page-hopping/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;I have realized that like most users of Wikipedia, I do a lot of Wikipedia page-hopping [1]. Wikipedia is sort of addictive that way. You start reading about a piece of Flamenco music and after twenty minutes find yourself staring at the page about &lt;a href=&#34;http://en.wikipedia.org/wiki/ETA&#34;&gt;ETA&lt;/a&gt;, a Basque nationalist organization. So I decided to figure out how I exactly do I get lost in the huge list of interconnected articles. I use Chromium, and it stores its history in a SQLite3 database file. I wrote a small Ruby script that parses the history, splits them to chunks of articles accessed per day, and filter only Wikipedia links from this.&lt;/p&gt;
&lt;p&gt;This is basically what I had to do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Query the db for the last visit time and URLs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Chromium (and Google Chrome) stores timestamps of page visits in a not so obvious format. They basically store time stamps as the &lt;a href=&#34;http://www.mail-archive.com/chromium-discuss@googlegroups.com/msg03891.html&#34;&gt;number of micro seconds expired since Jan 01, 1601&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Splitting the URLs into chunks accessed per day involved calculating the number of micro-seconds in a day and splitting the URLs based on this. Ruby&amp;rsquo;s Array#group_by is really handy here.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Analysis of the URLs involves filtering only the URLs that contain &amp;ldquo;wikipedia&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There is a caveat here, as redirects to Wikipedia from both Google and Facebook contain the string &amp;ldquo;wikipedia&amp;rdquo; in their URLs. These need to be filtered out.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The analysis of my Wikipedia history showed me some interesting things. For example, when I was reading &lt;a href=&#34;http://en.wikipedia.org/wiki/Michael_J._Arlen&#34;&gt;Michael J. Arlen&amp;rsquo;s&lt;/a&gt; Passage to Ararat, I spent a lot of time on Wikipedia, hopping between pages about Armenian history and culture. This is what the list of Wikipedia pages on that day look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://en.wikipedia.org/wiki/TRS-80
http://en.wikipedia.org/wiki/Aunt_Sally
http://en.wikipedia.org/wiki/Pai
http://en.wikipedia.org/wiki/Pai_(surname)
http://en.wikipedia.org/wiki/Gowd_Saraswat_Brahmins
http://en.wikipedia.org/wiki/Girish_Karnad
http://en.wikipedia.org/wiki/Konkani_people
http://en.wikipedia.org/wiki/Roots_(book)
http://en.wikipedia.org/wiki/Mountains_of_Ararat
http://en.wikipedia.org/wiki/Armenian_Highland
http://en.wikipedia.org/wiki/Searches_for_Noah%27s_Ark
http://en.wikipedia.org/wiki/Tiberian_Hebrew
http://en.wikipedia.org/wiki/Mount_Judi
http://en.wikipedia.org/wiki/Islamic_view_of_Noah
http://en.wikipedia.org/wiki/Greater_Armenia_(political_concept)
http://en.wikipedia.org/wiki/Coat_of_Arms_of_Armenia
http://en.wikipedia.org/wiki/Turkish_War_of_Independence
http://en.wikipedia.org/wiki/Kuva-yi_Milliye
http://en.wikipedia.org/wiki/Turkish-Armenian_War
http://en.wikipedia.org/wiki/Anatolia
http://en.wikipedia.org/wiki/Bursa
http://en.wikipedia.org/wiki/Armenia
http://en.wikipedia.org/wiki/Hayk
http://en.wikipedia.org/wiki/Ecbatana
http://en.wikipedia.org/wiki/Goat_meat
http://en.wikipedia.org/wiki/Kid
http://en.wikipedia.org/w/index.php?title=Special%3ASearch&amp;amp;amp;search=xenophon
http://en.wikipedia.org/wiki/Xenophon
http://en.wikipedia.org/wiki/International_Mother_Language_Day
http://en.wikipedia.org/wiki/Debian
http://en.wikipedia.org/wiki/Language_Movement_Day
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When I was reading about Data warehousing, this is how the hopping happened:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://en.wikipedia.org/wiki/ROLAP
http://en.wikipedia.org/wiki/Dimension_(data_warehouse)
http://en.wikipedia.org/wiki/Extract,_transform,_load
http://en.wikipedia.org/wiki/Mondrian_OLAP_server
http://en.wikipedia.org/wiki/OLAP
http://en.wikipedia.org/wiki/Comparison_of_OLAP_Servers
http://en.wikipedia.org/wiki/Pentaho
http://en.wikipedia.org/wiki/Multidimensional_Expressions
http://en.wikipedia.org/wiki/Decision_science
http://en.wikipedia.org/wiki/Star_schema
http://en.wikipedia.org/wiki/Snowflake_schema
http://en.wikipedia.org/wiki/Sarkar
http://en.wikipedia.org/wiki/Fact_table
http://en.wikipedia.org/wiki/OLTP
http://en.wikipedia.org/wiki/Ralph_Kimball
http://en.wikipedia.org/wiki/Bill_Inmon
http://en.wikipedia.org/wiki/Decision_support
http://en.wikipedia.org/wiki/Heart_of_Midlothian_F.C.
http://en.wikipedia.org/wiki/The_Heart_of_Midlothian
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I am still trying to make more sense of the links that I clicked away and the articles I read when I was page hopping.&lt;/p&gt;
&lt;p&gt;The Ruby script that parses Chromium history and figures out the Wikipedia links is below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby
# Ruby script to parse Chromium (or Google Chrome) history to identify Wikipedia pages read per day.
# usage: ./wikipedia_history.rb &amp;lt;location of Chromium history db&amp;gt;
# The Chromium history db can be usually found under ~/.config/chromium/Default

require &#39;rubygems&#39;
require &#39;sqlite3&#39;

US_IN_A_DAY = 24 * 60 * 60 * 1000000
SITE = &amp;quot;wikipedia&amp;quot;

module ChromiumHP
  class DbConnection
    def initialize db_name
      @db_name = db_name
    end

    def urls_history
      db = SQLite3::Database.new @db_name
      urls = db.execute(&amp;quot;SELECT last_visit_time, url from urls ORDER BY last_visit_time;&amp;quot;).map do |t, u|
        {:last_visit_time =&amp;gt; t, :url =&amp;gt; u}
      end
      db.close
      urls
    end
  end

  class Parser
    def initialize db_name
      @db_name = db_name
    end

    def chunks days
      @history ||= get_history
      parts = @history.group_by do |h|
         h[:last_visit_time] / (days * US_IN_A_DAY)
      end
      parts.map { |k, group| group }
    end

    private
    def get_history
      DbConnection.new(@db_name).urls_history
    end
  end

  class Analyzer
    def self.graph chunks
      chunks.map do |c|
        c.find_all do |entry|
          url = entry[:url]
          url.include?(SITE) &amp;amp;&amp;amp;
            !url.include?(&amp;quot;facebook&amp;quot;) &amp;amp;&amp;amp;
            !url.include?(&amp;quot;google&amp;quot;)
        end
      end.find_all do |c|
        !c.empty?
      end.sort_by do |c|
        c.length
      end.map do |c|
        c.map do |entry|
          entry[:url]
        end
      end
    end
  end
end


history_loc = ARGV.first
abort &amp;quot;Error: Pass the chromium history location as parameter&amp;quot; if history_loc.nil?

daily_chunks = ChromiumHP::Parser.new(history_loc + &amp;quot;/History&amp;quot;).chunks(1)
ChromiumHP::Analyzer.graph(daily_chunks).each do |entries|
  puts entries
  puts &amp;quot;&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Empathy Log Parser</title>
      <link>https://sadique.io/blog/2011/03/24/empathy-log-parser/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Thu, 24 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2011/03/24/empathy-log-parser/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;I use Empathy as my preferred IM application. Today, I wanted to have a look at an IM conversation I had with someone. I pulled out the Empathy log corresponding to that conversation, and boom - it is in XML.&lt;/p&gt;
&lt;p&gt;Just another excuse to write code. So I came up with the following. It was easy to write and it does not do much - It uses the Hpricot gem to parse the XML and prints the name of the people involved in the chat and their messages in a human readable form. What? You are one of those souls who actually enjoy reading XML? Well, I am not one of those.&lt;/p&gt;
&lt;p&gt;So here is the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby
# empathy_lp.rb
# Usage - ./empathy_lp.rb /tmp/20110323.log

require &#39;rubygems&#39;
require &#39;hpricot&#39;

module EmpathyLP
  class LogParser
    def initialize file_path
      conversation_xml = IO.readlines(file_path).to_s
      @doc = Hpricot conversation_xml
    end

    def messages
      (@doc/&amp;quot;message&amp;quot;).map do |m|
        m.attributes[&#39;name&#39;] + &amp;quot;: &amp;quot; + m.inner_text
      end
    end
  end
end

path = ARGV.first
puts EmpathyLP::LogParser.new(path).messages
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I will modify this slightly to show a timestamp for each message.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Binary Signature Art</title>
      <link>https://sadique.io/blog/2011/03/23/binary-signature-art/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Wed, 23 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2011/03/23/binary-signature-art/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;I was reading this very interesting &lt;a href=&#34;http://forums.xkcd.com/viewtopic.php?f=7&amp;amp;t=11765&#34;&gt;thread&lt;/a&gt; on the xkcd forum when I noticed a post from a user with the following signature in binary:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;01001101 01100001 01100100 01100101 00100000 01011001 01101111 01110101 00100000 01001100 01101111 01101111 01101011 00100001&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At first, that did not particularly entice me, mostly because the topic being discussed was really interesting, but it did come back to my focus when I saw that another user had quoted the signature, along with the comment &lt;code&gt;Yeah, you know it. LOL :-)&lt;/code&gt;. I had to find what the original message was.&lt;/p&gt;
&lt;p&gt;So couple of minutes of Ruby later, I figured it out. His message was simple - &lt;code&gt;Made You Look!&lt;/code&gt;. Yeah, he sure did!&lt;/p&gt;
&lt;p&gt;Here is the rather simple Ruby code snippet that did the trick:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;code = &amp;quot;01001101 01100001 01100100 01100101 00100000 01011001 01101111 01110101 00100000 01001100 01101111 01101111 01101011 00100001&amp;quot;

parts = code.split &amp;quot; &amp;quot;

text = parts.map do |p|
  p.to_i(2).chr
end.to_s

puts text
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Java Arrays in JRuby</title>
      <link>https://sadique.io/blog/2010/03/16/java-arrays-in-jruby/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Tue, 16 Mar 2010 00:00:00 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2010/03/16/java-arrays-in-jruby/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;Recently my team encountered a frustrating thing while working with a Java library in JRuby. It took us long to figure out what was going wrong. This is an attempt to write down what was happening.&lt;/p&gt;
&lt;p&gt;You are in Ruby world, a world of weak typing, no type casting and pure bliss in coding. You forget that some languages care about the type of elements in an Array. And you end up spending a lot of time figuring out why you are staring at a stupid looking exception.&lt;/p&gt;
&lt;p&gt;I will be using a dummy example for describing the problem.&lt;/p&gt;
&lt;p&gt;The following code snippet tries to compare two arrays in JRuby using Java Arrays&amp;rsquo; equals method. In JRuby world, one would expect this to work. Actually, one should not, but Ruby really gets into you.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;java&#39;
import &#39;java.util.Arrays&#39;

puts &amp;quot;Arrays equal&amp;quot; if Arrays.equals([1, 2, 3], [1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Well, it does not. You get an error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;no equals with arguments matching [class org.jruby.RubyArray, class org.jruby.RubyArray] on object Java::JavaUtil::Arrays (NameError)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This error message is informative. In our case, our unit tests threw an error that was very difficult to make any sense of. The reason why this fails is obvious.&lt;/p&gt;
&lt;p&gt;Java does care about the Type of things that form an Array. So you need to cast it to the correct type.&lt;/p&gt;
&lt;p&gt;Here is the code that actually works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;java&#39;
import &#39;java.util.Arrays&#39;

puts &amp;quot;Arrays equal&amp;quot; if Arrays.equals([1,2,3].to_java(java.lang.Integer),
                                     [1,2,3].to_java(java.lang.Integer))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;to_java&lt;/code&gt; method casts the elements of the Ruby array into Java array with elements of type specified.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

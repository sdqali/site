<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Freebuilder on {code that works}</title>
    <link>https://sadique.io/tags/freebuilder/?utm_source=site&amp;utm_medium=feed</link>
    <description>Recent content in Freebuilder on {code that works}</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 05 May 2018 05:27:35 +0000</lastBuildDate>
    <atom:link href="https://sadique.io/tags/freebuilder/?utm_source=site&amp;utm_medium=feed" rel="self" type="application/rss+xml" />
    
    <item>
      <title>FreeBuilder plugin for IntelliJ</title>
      <link>https://sadique.io/blog/2018/05/05/freebuilder-plugin-for-intellij/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sat, 05 May 2018 05:27:35 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2018/05/05/freebuilder-plugin-for-intellij/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;My work uses &lt;a href=&#34;http://freebuilder.inferred.org/&#34;&gt;FreeBuilder&lt;/a&gt; extensively to generate the &lt;a href=&#34;https://en.wikipedia.org/wiki/Builder_pattern&#34;&gt;Builder&lt;/a&gt; pattern for Java classes. In addition to this, we use the generated Builder classes to deserialize the data calsses using Jackson. After a while it became tiresome to type &lt;code&gt;@FreeBuilder&lt;/code&gt; and &lt;code&gt;class Builder extends ...&lt;/code&gt; everywhere. So I decided to write and IntelliJ IDEA plugin that does it for me.&lt;/p&gt;
&lt;p&gt;These are the things I wanted the plugin to do for me:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Annotate the public class from the current file with &lt;code&gt;@FreeBuilder&lt;/code&gt; annotation.&lt;/li&gt;
&lt;li&gt;Create an inner class for the annotated class - this should be a &lt;code&gt;static&lt;/code&gt; class if the annotated class is an &lt;code&gt;abstract&lt;/code&gt; class and a child class if the annotated class is an &lt;code&gt;interface&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Ensure that the generated &lt;code&gt;Builder&lt;/code&gt; class is annotated with &lt;code&gt;@JsonIgnoreProperties(ignoreUnknown=true)&lt;/code&gt; because this is a convention we like to follow.&lt;/li&gt;
&lt;li&gt;Ensure that the parent class gets annotated with &lt;code&gt;@JsonDeserialize(builder=...)&lt;/code&gt; annotation.&lt;/li&gt;
&lt;li&gt;Rebuild the project so that the annotation processing for FreeBuilder runs.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After poking around the IntelliJ Plugin development documentation, I was able to write a simple enough plugin that does it. For whatever reason, trying to find how to achieve simple things like how to create a new class that you can add as a child to an existing class was painful.&lt;/p&gt;
&lt;p&gt;The plugin is available &lt;a href=&#34;https://plugins.jetbrains.com/plugin/10705-freebuilder-plugin&#34;&gt;here&lt;/a&gt; from the IntelliJ plugin repository and the source code is here on &lt;a href=&#34;https://github.com/sdqali/freebuilder-intellij-plugin&#34;&gt;GitHub&lt;/a&gt;. In addition to the above mentioned features, I wanted to make sure that the annotations gets added only if the annoattion classes were in the classpath of the current module. The plugin also displayes messages when it decides to skip a step because an annotation class was not in the classpath or because nnotations already exist on the class.&lt;/p&gt;
&lt;p&gt;A short demo of the plugin in action is shown below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sadique.io/images/freebuilder-plugin-demo.gif&#34; alt=&#34;&amp;ldquo;FreeBuilder Plugin Demo&amp;rdquo;&#34; title=&#34;FreeBuilder Plugin Demo&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A Jackson and FreeBuilder quirk</title>
      <link>https://sadique.io/blog/2018/03/23/a-jackson-and-freebuilder-quirk/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Fri, 23 Mar 2018 05:21:42 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2018/03/23/a-jackson-and-freebuilder-quirk/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;Jackson is a great tool to have in your tool set if you deal with JSON or XML. It facilitates easy serialization and de-serialization to and from Java classes with a convenient annotation based interface. With the same set of annotations, we can achieve both XML and JSON serialization and de-serialization. With Jackson&amp;rsquo;s &lt;code&gt;data-format-xml&lt;/code&gt; it is even possible to give the same Class a different JSON and XML representation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@JacksonXmlRootElement(localName = &amp;quot;user-account&amp;quot;)
@JsonRootName(&amp;quot;user&amp;quot;)
public class Account {
  private String name;
  private String emailAddress;

  @JsonProperty(&amp;quot;name&amp;quot;)
  @JacksonXmlProperty(localName = &amp;quot;name&amp;quot;)
  public String getName() {
    return name;
  }

  @JsonProperty(&amp;quot;email_address&amp;quot;)
  @JacksonXmlProperty(localName = &amp;quot;email-address&amp;quot;)
  public String getEmailAddress() {
    return emailAddress;
  }

  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When this gets used, it does the serialization and de-serializaion to and from XML and JSON in different forms:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;jsonMapper = new ObjectMapper();
jsonMapper.configure(WRAP_ROOT_VALUE, true);
jsonMapper.configure(UNWRAP_ROOT_VALUE, true);
xmlMapper = new XmlMapper();

// ...

Account account = new Account(&amp;quot;John Doe&amp;quot;, &amp;quot;john@example.com&amp;quot;);

String jsonString = jsonMapper.writeValueAsString(account);
System.out.println(jsonString);
Account deSerializedAccount = jsonMapper.readValue(jsonString, Account.class);
assertEquals(account, deSerializedAccount);

String xmlString = xmlMapper.writeValueAsString(account);
System.out.println(xmlString);
deSerializedAccount = xmlMapper.readValue(xmlString, Account.class);
assertEquals(account, deSerializedAccount);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;{&amp;quot;user&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,&amp;quot;email_address&amp;quot;:&amp;quot;john@example.com&amp;quot;}}
&amp;lt;user-account&amp;gt;&amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;&amp;lt;email-address&amp;gt;john@example.com&amp;lt;/email-address&amp;gt;&amp;lt;/user-account&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Things get really interesting when we introduce &lt;a href=&#34;http://freebuilder.inferred.org/&#34;&gt;FreeBuilder&lt;/a&gt;. FreeBuilder supports Jackson and we will be able to do serialization correctly. However, XML de-serialization does not work as expected.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;cksonXmlRootElement(localName = &amp;quot;user-account&amp;quot;)
@JsonRootName(&amp;quot;user&amp;quot;)
@FreeBuilder
@JsonDeserialize(builder = Account.Builder.class)
public interface Account {
  @JsonProperty(&amp;quot;name&amp;quot;)
  @JacksonXmlProperty(localName = &amp;quot;name&amp;quot;)
  String getName();

  @JsonProperty(&amp;quot;email_address&amp;quot;)
  @JacksonXmlProperty(localName = &amp;quot;email-address&amp;quot;)
  String getEmailAddress();

  class Builder extends Account_Builder {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Account account = new Account.Builder()
    .setEmailAddress(&amp;quot;john@example.com&amp;quot;)
    .setName(&amp;quot;John Doe&amp;quot;)
    .build();

String jsonString = jsonMapper.writeValueAsString(account);
System.out.println(jsonString);
Account deSerializedAccount = jsonMapper.readValue(jsonString, Account.class);
assertEquals(account, deSerializedAccount);

String xmlString = xmlMapper.writeValueAsString(account);
System.out.println(xmlString);
deSerializedAccount = xmlMapper.readValue(xmlString, Account.class);
assertEquals(account, deSerializedAccount);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will cause Jackson to throw an error while de-serializing XML, even though de-serializing to JSON works as expected.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;{&amp;quot;user&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,&amp;quot;email_address&amp;quot;:&amp;quot;john@example.com&amp;quot;}}
&amp;lt;user-account&amp;gt;&amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;&amp;lt;email-address&amp;gt;john@example.com&amp;lt;/email-address&amp;gt;&amp;lt;/user-account&amp;gt;

com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field &amp;quot;email-address&amp;quot; (class in.sdqali.json.Account$Builder), not marked as ignorable (3 known properties: &amp;quot;emailAddress&amp;quot;, &amp;quot;email_address&amp;quot;, &amp;quot;name&amp;quot;])
 at [Source: (StringReader); line: 1, column: 83] (through reference chain: in.sdqali.json.Account$Builder[&amp;quot;email-address&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After digging around, it turns out that FreeBuilder &lt;a href=&#34;https://github.com/inferred/FreeBuilder/blob/master/src/main/java/org/inferred/freebuilder/processor/JacksonSupport.java#L40&#34;&gt;keeps only&lt;/a&gt; the &lt;code&gt;@JsonProperty&lt;/code&gt; annotation on methods that it finds. This in turn causes the object created by the builder to have methods whose &lt;code&gt;@JacksonXmlProperty&lt;/code&gt; annotations are stripped of, which in turn causes Jackson to look for the camel-cased versions of the attribute names. I have opened a new &lt;a href=&#34;https://github.com/inferred/FreeBuilder/issues/294&#34;&gt;GitHub issue&lt;/a&gt; for this.&lt;/p&gt;
&lt;p&gt;Until this is resolved, if you use FreeBuilder and need to have different XML and JSON representation, you will have to write a custom Jackson &lt;a href=&#34;https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers&#34;&gt;Serializer&lt;/a&gt; and Deserializer.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>

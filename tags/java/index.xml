<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on {code that works}</title>
    <link>https://sadique.io/tags/java/?utm_source=site&amp;utm_medium=feed</link>
    <description>Recent content in Java on {code that works}</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 02 Aug 2019 18:19:32 -0700</lastBuildDate>
    <atom:link href="https://sadique.io/tags/java/?utm_source=site&amp;utm_medium=feed" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Flushing Metrics in Dropwizard Commands</title>
      <link>https://sadique.io/blog/2019/08/02/flushing-metrics-in-dropwizard-commands/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Fri, 02 Aug 2019 18:19:32 -0700</pubDate>
      
      <guid>https://sadique.io/blog/2019/08/02/flushing-metrics-in-dropwizard-commands/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;Users of Dropwizard Metrics will be familiar with &lt;code&gt;ScheduledReporter&lt;/code&gt;  - it is a nice pattern that allows metrics reporting to be off loaded to a different thread which periodically sends out the collected metrics instead of making a network call every time a metric is collected. In most use cases, this works great - especially if you are running a server.&lt;/p&gt;
&lt;p&gt;However, the implementation of &lt;code&gt;ScheduledReporter&lt;/code&gt; comes with an interesting quirk - it reports metrics only on the configured schedule, but does not flush the metrics it has collected after the last flush when the reporter is closed.&lt;/p&gt;
&lt;p&gt;Datadog Metrics wires up ScheduledReporters that you configure as Dropwizard Lifecycle managed entities, guaranteeing that when your application shuts down, the reporter is closed.&lt;/p&gt;
&lt;p&gt;This results in metrics collected immediately before an application is shutdown being discarded. This is especially problematic for Dropwizard commands that have varying run times depending on how much data processing it performs.&lt;/p&gt;
&lt;p&gt;Imagine a Dropwizard command that when run downloads a file and processes it. Suppose the usual run time is in minutes, so you have configured your metric reporter&amp;rsquo;s frequency to be &lt;code&gt;1 minute&lt;/code&gt;, which is reasonable for this command. However, consider the situation where the downloaded file contains no data - the command will finish in seconds, thereby discarding any metric it has collected, as it hasn&amp;rsquo;t ran for long enough for the scheduled reporter&amp;rsquo;s executor to kick in.&lt;/p&gt;
&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;
&lt;p&gt;If you have the ability to override the specific &lt;code&gt;ScheduledReporter&lt;/code&gt; you are using, you could inherit from it and override the &lt;code&gt;#close()&lt;/code&gt; method to call &lt;code&gt;#report&lt;/code&gt; before issuing &lt;code&gt;#stop&lt;/code&gt;. For example, if you were using the &lt;code&gt;ConsoleReporter&lt;/code&gt;, you could override the method and then use a &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html&#34;&gt;Service Provider Interface&lt;/a&gt; to provide your new reporter to Datadog Metrics.&lt;/p&gt;
&lt;p&gt;The SPI goes in the file &lt;code&gt;src/main/resources/META-INF/services/io.dropwizard.metrics.ReporterFactory&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;io.sadique.dropwizard.metrics.flush.CustomReporterFactory
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CustomReporterFactory extends BaseReporterFactory {
  @Override
  public ScheduledReporter build(MetricRegistry registry) {
    return FlushingReporter.forRegistry(registry)
      .build();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are using a reporter like &lt;code&gt;DataogReporter&lt;/code&gt;, it is hard to override it as the constructor is marked private. In such situations, we can create a wrapper that provides the overridden behavior:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FlushOnCloseReporter extends ScheduledReporter  {
  private final ScheduledReporter wrapped;

  public FlushOnCloseReporter(ScheduledReporter wrapped, MetricRegistry registry, String name,
                              MetricFilter filter, TimeUnit rateUnit, TimeUnit durationUnit) {
    super(registry, name, filter, rateUnit, durationUnit);
    this.wrapped = wrapped;
  }

  @Override
  public void report(SortedMap&amp;lt;String, Gauge&amp;gt; gauges, SortedMap&amp;lt;String, Counter&amp;gt; counters,
                     SortedMap&amp;lt;String, Histogram&amp;gt; histograms, SortedMap&amp;lt;String, Meter&amp;gt; meters,
                     SortedMap&amp;lt;String, Timer&amp;gt; timers) {
    wrapped.report(gauges, counters, histograms, meters, timers);
  }

  @Override
  public void start(long period, TimeUnit unit) {
    wrapped.start(period, unit);
  }

  @Override
  public void stop() {
    wrapped.report();
    wrapped.stop();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the reporter factory can be modified to wrap the &lt;code&gt;DatadogReporter&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CustomReporterFactory extends BaseReporterFactory {
  @Override
  public ScheduledReporter build(MetricRegistry registry) {
    DatadogReporter consoleReporter = DatadogReporter.forRegistry(registry)
      .filter(getFilter())
      .convertDurationsTo(getDurationUnit())
      .convertRatesTo(getRateUnit())
      .build();
    return new FlushOnCloseReporter(consoleReporter, registry, &amp;quot;flush-on-close(DatadogReporter)&amp;quot;,
      getFilter(), getRateUnit(), getDurationUnit());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will ensure that reports are always flushed before the reporter is shutdown by Dropwizard lifecycle.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Managing environment lifecycles for Dropwizard Commands</title>
      <link>https://sadique.io/blog/2019/07/28/managing-environment-lifecycles-for-dropwizard-commands/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sun, 28 Jul 2019 18:29:49 -0700</pubDate>
      
      <guid>https://sadique.io/blog/2019/07/28/managing-environment-lifecycles-for-dropwizard-commands/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;If you have built background workers or other non-server applications with Dropwizard, chances are that you used the Dropwizard Command pattern. In fact, even the sever you wrote with Dropwizard executes a command - specifically &lt;code&gt;io.dropwizard.cli.ServerCommand&lt;/code&gt;. While the server command is great, sometimes you want to build applications that have all the goodies that Dropwizard offers, but you dont want to start a server. Managing Lifecycles is one example of a Dropwizard feature that works great for server applications, but needs some tweaking to get working for non-server commands.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take the following example. We have the simplest Dropwizard command below. It doesn&amp;rsquo;t do much, except print some logs and sleep for a second in between.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WaitingCommand extends EnvironmentCommand&amp;lt;AppConfiguration&amp;gt; {

  public WaitingCommand(Application&amp;lt;AppConfiguration&amp;gt; application) {
    super(application, &amp;quot;wait&amp;quot;, &amp;quot;Wait for a second.&amp;quot;);
  }

  @Override
  protected void run(Environment environment, Namespace namespace, AppConfiguration configuration) throws Exception {
    Logger.getInstance(getClass()).info(&amp;quot;Starting command&amp;quot;);
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    Logger.getInstance(getClass()).info(&amp;quot;Finished running command&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can wire this to our application.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MetricsApplication extends Application&amp;lt;AppConfiguration&amp;gt; {
  public static void main(String[] args) throws Exception {
    new MetricsApplication().run(args);
  }

  @Override
  public void run(AppConfiguration configuration, Environment environment) throws Exception {

  }

  @Override
  public void initialize(Bootstrap&amp;lt;AppConfiguration&amp;gt; bootstrap) {
    bootstrap.addCommand(new WaitingCommand(this));

    bootstrap.setConfigurationSourceProvider(new ResourceConfigurationSourceProvider());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When our application runs with the &lt;code&gt;wait&lt;/code&gt; command (i.e. we invoke it as &lt;code&gt;java -jar app.jar wait config.yml&lt;/code&gt;), it does the little work we asked it to do.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INFO  [2019-07-29 01:42:43,703] org.eclipse.jetty.util.log: Logging initialized @2699ms to org.eclipse.jetty.util.log.Slf4jLog
INFO  [2019-07-29 01:42:43,952] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: /
INFO  [2019-07-29 01:42:43,957] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: /
INFO  [2019-07-29 01:42:43,960] io.sadique.dropwizard.WaitingCommand: Starting command
INFO  [2019-07-29 01:42:44,966] io.sadique.dropwizard.WaitingCommand: Finished running command
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;adding-a-lifecycle&#34;&gt;Adding a lifecycle&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s try adding an object whose lifecycle we intend to be managed by Dropwizard. Again, this entity in the example doesn&amp;rsquo;t do much - except log when it is started and stopped by Dropwizard.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import io.dropwizard.lifecycle.Managed;
import org.apache.log4j.Logger;

public class ManagedObject implements Managed {
  @Override
  public void start() throws Exception {
    Logger.getInstance(getClass()).info(&amp;quot;Starting managed object&amp;quot;);
  }

  @Override
  public void stop() throws Exception {
    Logger.getInstance(getClass()).info(&amp;quot;Stopping managed object&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will of course need to tell Dropwizard to manage this object:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
  @Override
  public void run(AppConfiguration configuration, Environment environment) throws Exception {
    environment.lifecycle().manage(new ManagedObject());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the application is run with the &lt;code&gt;wait&lt;/code&gt; command, the log looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INFO  [2019-07-29 01:50:28,510] org.eclipse.jetty.util.log: Logging initialized @1640ms to org.eclipse.jetty.util.log.Slf4jLog
INFO  [2019-07-29 01:50:28,640] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: /
INFO  [2019-07-29 01:50:28,642] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: /
INFO  [2019-07-29 01:50:28,647] io.sadique.dropwizard.WaitingCommand: Starting command
INFO  [2019-07-29 01:50:29,649] io.sadique.dropwizard.WaitingCommand: Finished running command
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looks like the object we expected Dropwizard to start and stop was ignored. What if we run the application with the &lt;code&gt;server&lt;/code&gt; command?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INFO  [2019-07-29 02:09:17,067] org.eclipse.jetty.setuid.SetUIDListener: Opened application@680a66dd{HTTP/1.1,[http/1.1]}{0.0.0.0:8080}
INFO  [2019-07-29 02:09:17,067] org.eclipse.jetty.setuid.SetUIDListener: Opened admin@2dd8239{HTTP/1.1,[http/1.1]}{0.0.0.0:8081}
INFO  [2019-07-29 02:09:17,126] org.eclipse.jetty.server.Server: jetty-9.4.z-SNAPSHOT
INFO  [2019-07-29 02:09:17,143] io.sadique.dropwizard.ManagedObject: Starting managed object
...
...
...
INFO  [2019-07-29 02:09:21,747] org.eclipse.jetty.server.AbstractConnector: Stopped admin@2dd8239{HTTP/1.1,[http/1.1]}{0.0.0.0:8081}
INFO  [2019-07-29 02:09:21,751] org.eclipse.jetty.server.handler.ContextHandler: Stopped i.d.j.MutableServletContextHandler@2ee83775{/,null,UNAVAILABLE}
INFO  [2019-07-29 02:09:21,756] org.eclipse.jetty.server.handler.ContextHandler: Stopped i.d.j.MutableServletContextHandler@19382338{/,null,UNAVAILABLE}
INFO  [2019-07-29 02:09:21,760] io.sadique.dropwizard.ManagedObject: Stopping managed object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The server seems to manage the lifecycle of the object as expected. Why is it the case that server command can manage the lifecycle, but our custom command can&amp;rsquo;t?&lt;/p&gt;
&lt;p&gt;It turns out, it is not enough to register an entity whose lifecycle needs to be managed, someone needs to attach a lifecycle container to the &lt;code&gt;LifecycleEnvironment&lt;/code&gt;. It is not an issue for the server command because it builds a server using &lt;code&gt;io.dropwizard.server.AbstractServerFactory#buildServer&lt;/code&gt;, which in turn &lt;a href=&#34;https://github.com/dropwizard/dropwizard/blob/master/dropwizard-core/src/main/java/io/dropwizard/server/AbstractServerFactory.java#L611&#34;&gt;attaches the container&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;building-a-lifecyclemanagedcommand&#34;&gt;Building a LifecycleManagedCommand&lt;/h2&gt;
&lt;p&gt;We can mimic the behavior of the server by constructing our own &lt;code&gt;ContainerLifecycle&lt;/code&gt; and starting it before our command performs it&amp;rsquo;s actions. This pattern can be generalized as a &lt;code&gt;LifecycleManagedCommand&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class LifecycleManagedCommand&amp;lt;T extends Configuration&amp;gt; extends EnvironmentCommand&amp;lt;T&amp;gt; {

  private final ContainerLifeCycle containerLifeCycle;

  public LifecycleManagedCommand(Application&amp;lt;T&amp;gt; application, String name, String description) {
    super(application, name, description);
    containerLifeCycle = new ContainerLifeCycle();
  }

  @Override
  protected void run(Environment environment, Namespace namespace, T configuration) throws Exception {
    environment.lifecycle().getManagedObjects().stream().forEach(mo -&amp;gt; containerLifeCycle.addBean(mo));
    ShutdownThread.register(containerLifeCycle);
    containerLifeCycle.start();

    runManaged(environment, namespace, configuration);

    containerLifeCycle.stop();
  }

  abstract void runManaged(Environment environment, Namespace namespace, T configuration);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command ensures that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A new &lt;code&gt;ContainerLifeCycle&lt;/code&gt; is built before running the command.&lt;/li&gt;
&lt;li&gt;Every managed object registered with the Lifecycle is added to the container.&lt;/li&gt;
&lt;li&gt;The container is started and registered with &lt;code&gt;ShutdownThread&lt;/code&gt;, which is Dropwizard&amp;rsquo;s shut down hook.&lt;/li&gt;
&lt;li&gt;The container is stopped after the command performs it&amp;rsquo;s action.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can now now modify &lt;code&gt;WaitCommand&lt;/code&gt; to use this pattern.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class WaitingCommand extends LifecycleManagedCommand&amp;lt;AppConfiguration&amp;gt; {

  public WaitingCommand(Application&amp;lt;AppConfiguration&amp;gt; application) {
    super(application, &amp;quot;wait&amp;quot;, &amp;quot;Wait for a second.&amp;quot;);
  }

  @Override
  protected void runManaged(Environment environment, Namespace namespace, AppConfiguration configuration) {
    Logger.getInstance(getClass()).info(&amp;quot;Starting command&amp;quot;);
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    Logger.getInstance(getClass()).info(&amp;quot;Finished running command&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this change, we can see that Dropwizard correctly handles the lifecycle when the &lt;code&gt;wait&lt;/code&gt; command is executed.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INFO  [2019-07-29 02:26:34,560] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: /
INFO  [2019-07-29 02:26:34,563] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: /
INFO  [2019-07-29 02:26:34,569] io.sadique.dropwizard.ManagedObject: Starting managed object
INFO  [2019-07-29 02:26:34,569] io.sadique.dropwizard.WaitingCommand: Starting command
INFO  [2019-07-29 02:26:35,575] io.sadique.dropwizard.WaitingCommand: Finished running command
INFO  [2019-07-29 02:26:35,575] io.sadique.dropwizard.ManagedObject: Stopping managed object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The server command will of course continue to work as expected.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Formatting Java Instant for resolutions</title>
      <link>https://sadique.io/blog/2018/06/09/formatting-java-instant-for-resolutions/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sat, 09 Jun 2018 18:55:23 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2018/06/09/formatting-java-instant-for-resolutions/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;I have had to look up how to format Java&amp;rsquo;s Instant with a given resolution - for example in microseconds or nanoseconds. After fiddling with various formatters, I was happy to finally get this right.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void shouldFormatWith7Decimals() {
  int resolution = 7;
  DateTimeFormatter dateTimeFormatter = new DateTimeFormatterBuilder()
    .appendInstant(resolution)
    .toFormatter();
  Instant instant = Instant.now();
  System.out.println(dateTimeFormatter.format(instant));
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>FreeBuilder plugin for IntelliJ</title>
      <link>https://sadique.io/blog/2018/05/05/freebuilder-plugin-for-intellij/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sat, 05 May 2018 05:27:35 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2018/05/05/freebuilder-plugin-for-intellij/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;My work uses &lt;a href=&#34;http://freebuilder.inferred.org/&#34;&gt;FreeBuilder&lt;/a&gt; extensively to generate the &lt;a href=&#34;https://en.wikipedia.org/wiki/Builder_pattern&#34;&gt;Builder&lt;/a&gt; pattern for Java classes. In addition to this, we use the generated Builder classes to deserialize the data calsses using Jackson. After a while it became tiresome to type &lt;code&gt;@FreeBuilder&lt;/code&gt; and &lt;code&gt;class Builder extends ...&lt;/code&gt; everywhere. So I decided to write and IntelliJ IDEA plugin that does it for me.&lt;/p&gt;
&lt;p&gt;These are the things I wanted the plugin to do for me:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Annotate the public class from the current file with &lt;code&gt;@FreeBuilder&lt;/code&gt; annotation.&lt;/li&gt;
&lt;li&gt;Create an inner class for the annotated class - this should be a &lt;code&gt;static&lt;/code&gt; class if the annotated class is an &lt;code&gt;abstract&lt;/code&gt; class and a child class if the annotated class is an &lt;code&gt;interface&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Ensure that the generated &lt;code&gt;Builder&lt;/code&gt; class is annotated with &lt;code&gt;@JsonIgnoreProperties(ignoreUnknown=true)&lt;/code&gt; because this is a convention we like to follow.&lt;/li&gt;
&lt;li&gt;Ensure that the parent class gets annotated with &lt;code&gt;@JsonDeserialize(builder=...)&lt;/code&gt; annotation.&lt;/li&gt;
&lt;li&gt;Rebuild the project so that the annotation processing for FreeBuilder runs.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After poking around the IntelliJ Plugin development documentation, I was able to write a simple enough plugin that does it. For whatever reason, trying to find how to achieve simple things like how to create a new class that you can add as a child to an existing class was painful.&lt;/p&gt;
&lt;p&gt;The plugin is available &lt;a href=&#34;https://plugins.jetbrains.com/plugin/10705-freebuilder-plugin&#34;&gt;here&lt;/a&gt; from the IntelliJ plugin repository and the source code is here on &lt;a href=&#34;https://github.com/sdqali/freebuilder-intellij-plugin&#34;&gt;GitHub&lt;/a&gt;. In addition to the above mentioned features, I wanted to make sure that the annotations gets added only if the annoattion classes were in the classpath of the current module. The plugin also displayes messages when it decides to skip a step because an annotation class was not in the classpath or because nnotations already exist on the class.&lt;/p&gt;
&lt;p&gt;A short demo of the plugin in action is shown below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sadique.io/images/freebuilder-plugin-demo.gif&#34; alt=&#34;&amp;ldquo;FreeBuilder Plugin Demo&amp;rdquo;&#34; title=&#34;FreeBuilder Plugin Demo&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A Jackson and FreeBuilder quirk</title>
      <link>https://sadique.io/blog/2018/03/23/a-jackson-and-freebuilder-quirk/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Fri, 23 Mar 2018 05:21:42 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2018/03/23/a-jackson-and-freebuilder-quirk/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;Jackson is a great tool to have in your tool set if you deal with JSON or XML. It facilitates easy serialization and de-serialization to and from Java classes with a convenient annotation based interface. With the same set of annotations, we can achieve both XML and JSON serialization and de-serialization. With Jackson&amp;rsquo;s &lt;code&gt;data-format-xml&lt;/code&gt; it is even possible to give the same Class a different JSON and XML representation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@JacksonXmlRootElement(localName = &amp;quot;user-account&amp;quot;)
@JsonRootName(&amp;quot;user&amp;quot;)
public class Account {
  private String name;
  private String emailAddress;

  @JsonProperty(&amp;quot;name&amp;quot;)
  @JacksonXmlProperty(localName = &amp;quot;name&amp;quot;)
  public String getName() {
    return name;
  }

  @JsonProperty(&amp;quot;email_address&amp;quot;)
  @JacksonXmlProperty(localName = &amp;quot;email-address&amp;quot;)
  public String getEmailAddress() {
    return emailAddress;
  }

  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When this gets used, it does the serialization and de-serializaion to and from XML and JSON in different forms:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;jsonMapper = new ObjectMapper();
jsonMapper.configure(WRAP_ROOT_VALUE, true);
jsonMapper.configure(UNWRAP_ROOT_VALUE, true);
xmlMapper = new XmlMapper();

// ...

Account account = new Account(&amp;quot;John Doe&amp;quot;, &amp;quot;john@example.com&amp;quot;);

String jsonString = jsonMapper.writeValueAsString(account);
System.out.println(jsonString);
Account deSerializedAccount = jsonMapper.readValue(jsonString, Account.class);
assertEquals(account, deSerializedAccount);

String xmlString = xmlMapper.writeValueAsString(account);
System.out.println(xmlString);
deSerializedAccount = xmlMapper.readValue(xmlString, Account.class);
assertEquals(account, deSerializedAccount);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;{&amp;quot;user&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,&amp;quot;email_address&amp;quot;:&amp;quot;john@example.com&amp;quot;}}
&amp;lt;user-account&amp;gt;&amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;&amp;lt;email-address&amp;gt;john@example.com&amp;lt;/email-address&amp;gt;&amp;lt;/user-account&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Things get really interesting when we introduce &lt;a href=&#34;http://freebuilder.inferred.org/&#34;&gt;FreeBuilder&lt;/a&gt;. FreeBuilder supports Jackson and we will be able to do serialization correctly. However, XML de-serialization does not work as expected.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;cksonXmlRootElement(localName = &amp;quot;user-account&amp;quot;)
@JsonRootName(&amp;quot;user&amp;quot;)
@FreeBuilder
@JsonDeserialize(builder = Account.Builder.class)
public interface Account {
  @JsonProperty(&amp;quot;name&amp;quot;)
  @JacksonXmlProperty(localName = &amp;quot;name&amp;quot;)
  String getName();

  @JsonProperty(&amp;quot;email_address&amp;quot;)
  @JacksonXmlProperty(localName = &amp;quot;email-address&amp;quot;)
  String getEmailAddress();

  class Builder extends Account_Builder {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Account account = new Account.Builder()
    .setEmailAddress(&amp;quot;john@example.com&amp;quot;)
    .setName(&amp;quot;John Doe&amp;quot;)
    .build();

String jsonString = jsonMapper.writeValueAsString(account);
System.out.println(jsonString);
Account deSerializedAccount = jsonMapper.readValue(jsonString, Account.class);
assertEquals(account, deSerializedAccount);

String xmlString = xmlMapper.writeValueAsString(account);
System.out.println(xmlString);
deSerializedAccount = xmlMapper.readValue(xmlString, Account.class);
assertEquals(account, deSerializedAccount);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will cause Jackson to throw an error while de-serializing XML, even though de-serializing to JSON works as expected.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;{&amp;quot;user&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,&amp;quot;email_address&amp;quot;:&amp;quot;john@example.com&amp;quot;}}
&amp;lt;user-account&amp;gt;&amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;&amp;lt;email-address&amp;gt;john@example.com&amp;lt;/email-address&amp;gt;&amp;lt;/user-account&amp;gt;

com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field &amp;quot;email-address&amp;quot; (class in.sdqali.json.Account$Builder), not marked as ignorable (3 known properties: &amp;quot;emailAddress&amp;quot;, &amp;quot;email_address&amp;quot;, &amp;quot;name&amp;quot;])
 at [Source: (StringReader); line: 1, column: 83] (through reference chain: in.sdqali.json.Account$Builder[&amp;quot;email-address&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After digging around, it turns out that FreeBuilder &lt;a href=&#34;https://github.com/inferred/FreeBuilder/blob/master/src/main/java/org/inferred/freebuilder/processor/JacksonSupport.java#L40&#34;&gt;keeps only&lt;/a&gt; the &lt;code&gt;@JsonProperty&lt;/code&gt; annotation on methods that it finds. This in turn causes the object created by the builder to have methods whose &lt;code&gt;@JacksonXmlProperty&lt;/code&gt; annotations are stripped of, which in turn causes Jackson to look for the camel-cased versions of the attribute names. I have opened a new &lt;a href=&#34;https://github.com/inferred/FreeBuilder/issues/294&#34;&gt;GitHub issue&lt;/a&gt; for this.&lt;/p&gt;
&lt;p&gt;Until this is resolved, if you use FreeBuilder and need to have different XML and JSON representation, you will have to write a custom Jackson &lt;a href=&#34;https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers&#34;&gt;Serializer&lt;/a&gt; and Deserializer.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Uploading a standalone artifact to Nexus 3</title>
      <link>https://sadique.io/blog/2017/08/18/uploading-a-standalone-artifact-to-nexus-3/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Fri, 18 Aug 2017 04:00:43 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2017/08/18/uploading-a-standalone-artifact-to-nexus-3/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;This is one of those &amp;ldquo;I had to figure out how to do this today, so the next time I google this, I have a place to look&amp;rdquo; blog posts.
Today, I had to upload a zip file as a build artifact to our Nexus 3 repository. The zip file had been generated by custom shell scripts that did not have a Maven, Ivy or Gradle projects to wrap them.&lt;/p&gt;
&lt;p&gt;The obvious way to do this seemed like using the Nexus 3 REST API, invoked like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -v -u &amp;lt;username&amp;gt;:&amp;lt;password&amp;gt; \
   --upload-file artifact.zip \
   https://&amp;lt;nexus-server&amp;gt;/repository/maven-releases/com/example/artifact/1.0.0/artifact-1.0.0.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works and the file is available in the repository. However, this method has the following shortcomings:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;There will not be a &lt;code&gt;POM&lt;/code&gt; file generated for this artifact.&lt;/li&gt;
&lt;li&gt;The maven metadata associated with this artifact will not be updated.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Using Maven Deploy Plugin&amp;rsquo;s &lt;a href=&#34;http://maven.apache.org/plugins/maven-deploy-plugin/deploy-file-mojo.html&#34;&gt;deploy file mojo&lt;/a&gt; in this situation will help us satisfy the above requirements. The mojo is capable of running in arbitrary directories without the need for a &lt;code&gt;pom.xml&lt;/code&gt; to be present. However, it does expect you to specify authentication parameters in a &lt;code&gt;settings.xml&lt;/code&gt; file. In my situation, I did not want to write credentials in a &lt;code&gt;settings.xml&lt;/code&gt;, so I had to improvise.&lt;/p&gt;
&lt;p&gt;This is what I ended up using and it works like a charm:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mvn deploy:deploy-file \
    -DgroupId=com.example \
    -DartifactId=artifact \
    -Dversion=1.0.0 \
    -Dpackaging=zip \
    -Dfile=artifact.zip \
    -DgeneratePom=true \
    -DupdateReleaseInfo=true \
    -Durl=&amp;quot;https://${NEXUS_USERNAME}:${NEXUS_PASSWORD}@&amp;lt;nexus-server&amp;gt;/repository/maven-releases/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Implementing feature toggles for a Spring Boot application - Part 4</title>
      <link>https://sadique.io/blog/2016/11/30/implementing-feature-toggles-for-a-spring-boot-application-part-4/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Wed, 30 Nov 2016 05:50:42 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/30/implementing-feature-toggles-for-a-spring-boot-application-part-4/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In the fourth part of this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt; about implementing &lt;a href=&#34;https://sadique.io/blog/2016/11/21/implementing-feature-toggles-for-a-spring-boot-application-part-1/&#34;&gt;feature toggles&lt;/a&gt; for a Spring Boot application, we will take a look at how our implementation so far introduced a dependency on the application being restarted for changes to take place.&lt;/p&gt;
&lt;p&gt;In &lt;a href=&#34;https://sadique.io/blog/2016/11/21/implementing-feature-toggles-for-a-spring-boot-application-part-1/&#34;&gt;part 1&lt;/a&gt;, we modified the &lt;code&gt;FeatureToggle&lt;/code&gt; annotation to support toggling beans and decided to use that for toggling features at the controller level. If we had a system capable of providing the feature toggle information to the application without restarts, the change in the state of the controller level toggles will have no effect because the controller is not going to be re-wired for request mapping, unless the application is restarted.&lt;/p&gt;
&lt;p&gt;This raises the interesting question - Are bean level switches really feature toggles, considering that they can never be altered without application restarts? A better approach would be to consider bean switches as purely configurations and use facades that route commands to either of the beans based on a feature flag. In the example configuration provided, is treating the choice between storing sessions in-memory / Redis an actual feature, considering it does not provide any value to the end-user?&lt;/p&gt;
&lt;p&gt;To ensure that we are not tying feature toggling to restarts, we will remove the meta-annotation we introduced to &lt;code&gt;FeatureToggle&lt;/code&gt; in &lt;a href=&#34;https://sadique.io/blog/2016/11/21/implementing-feature-toggles-for-a-spring-boot-application-part-1/&#34;&gt;part 1&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FeatureToggle {
  String feature();

  boolean expectedToBeOn() default true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this change, we no longer have the ability to toggle off an entire controller. Having to annotate all handler methods in a controller is going to be a painful, error-prone approach. In order to provide the ability to toggle entire controllers, we can modify the &lt;code&gt;FeatureInterceptor&lt;/code&gt; to look for annotations present on the controller class in addition to annotations present on the handler methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureInterceptor implements HandlerInterceptor {
  private final FeatureRepository featureRepository;

  public FeatureInterceptor(FeatureRepository featureRepository) {
    this.featureRepository = featureRepository;
  }

  @Override
  public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {
    HandlerMethod handlerMethod = (HandlerMethod) handler;
    if (handleMethodAnnotation(handlerMethod) &amp;amp;&amp;amp;
        handleTypeAnnotation(handlerMethod.getBeanType()))  {
      return true;
    }
    httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);
    return false;
  }

  private boolean handleTypeAnnotation(Class&amp;lt;?&amp;gt; controllerType) {
    FeatureToggle controllerTypeAnnotation = controllerType.getAnnotation(FeatureToggle.class);
    return checkFeatureState(controllerTypeAnnotation);
  }

  private boolean handleMethodAnnotation(HandlerMethod handlerMethod) {
    FeatureToggle methodAnnotation = handlerMethod.getMethodAnnotation(FeatureToggle.class);
    return checkFeatureState(methodAnnotation);
  }

  private boolean checkFeatureState(FeatureToggle methodAnnotation) {
    if (methodAnnotation == null) {
      return true;
    }

    if(featureRepository.isOn(methodAnnotation.feature()) == null) {
      return true;
    }

    if(methodAnnotation.expectedToBeOn() == featureRepository.isOn(methodAnnotation.feature())) {
      return true;
    }
    return false;
  }

  @Override
  public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {

  }

  @Override
  public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {

  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will correctly intercept requests routed to handler methods even if the annotation is at the controller level instead of the method level.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/foo&amp;quot;)
@FeatureToggle(feature = &amp;quot;feature.foo&amp;quot;)
public class FooController {
  @RequestMapping(&amp;quot;&amp;quot;)
  public Map hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello foo!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a feature toggling mechanism in place that no longer depends on application restarts, in the next part, we will look at providing this information to the application from a source that does not require restarts.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementing feature toggles for a Spring Boot application - Part 3</title>
      <link>https://sadique.io/blog/2016/11/29/implementing-feature-toggles-for-a-spring-boot-application-part-3/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Tue, 29 Nov 2016 05:50:39 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/29/implementing-feature-toggles-for-a-spring-boot-application-part-3/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In the third part of this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt; about implementing feature toggles for a Spring Boot application, we will take a look at exposing the state of feature flags as a Spring Boot management end point for monitoring and testing purposes.&lt;/p&gt;
&lt;p&gt;Spring Boot Actuator exposes a number of &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html&#34;&gt;end points&lt;/a&gt; to monitor and administer the application. The most commonly used of these in my experience are the &lt;code&gt;info&lt;/code&gt; and &lt;code&gt;health&lt;/code&gt; end points. These end points are used to communicate to load balancers that a particular instance is ready to accept traffic and to monitor the state of the application.&lt;/p&gt;
&lt;h2 id=&#34;features-management-end-point&#34;&gt;Features management end point&lt;/h2&gt;
&lt;p&gt;In our case, this end point will be used by administrators, QA engineers and sometimes business stake holders to see what features are available in a particular environment running the application. Of course, we could have re-used the end point we built in the &lt;a href=&#34;&#34;&gt;last blog post&lt;/a&gt; for this purpose, but creating an management end point allows us to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Control the HTTP end point together with other end points by using the &lt;code&gt;management.context-path&lt;/code&gt; property. This will allow us to provide certain nodes in our network access to only the management end points without having to expose application behavior to them.&lt;/li&gt;
&lt;li&gt;Make this information available in a more human readable form for it’s consumers. Even though the information exposed in the &lt;code&gt;/features&lt;/code&gt; end point is detailed, the format was designed for consumption by code.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Because this is for human consumption, the end point will display the feature state in the following format:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;available&amp;quot;: [
    &amp;quot;feature.hello&amp;quot;,
    &amp;quot;feature.bar&amp;quot;
    ...
  ],
  &amp;quot;enabled&amp;quot;: [
    &amp;quot;feature.hello&amp;quot;
    ...
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Management end points in Spring Boot are created by implementing the &lt;code&gt;EndPoint&lt;/code&gt; interface. In our case, the end point will depend on &lt;code&gt;FeatureRepository&lt;/code&gt; to do the heavy lifting.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureEndpoint implements Endpoint&amp;lt;HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt;&amp;gt; {

  public static final String ID = &amp;quot;features&amp;quot;;
  private final FeatureRepository featureRepository;

  public FeatureEndpoint(FeatureRepository featureRepository) {
    this.featureRepository = featureRepository;
  }

  @Override
  public String getId() {
    return ID;
  }

  @Override
  public boolean isEnabled() {
    return true;
  }

  @Override
  public boolean isSensitive() {
    return false;
  }

  @Override
  public HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; invoke() {
    HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    map.put(&amp;quot;enabled&amp;quot;, featureRepository.enabledKeys());
    map.put(&amp;quot;available&amp;quot;, featureRepository.featureKeys());
    return map;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to retrieve the keys for features that are toggled on, we will create an &lt;code&gt;enabledKeys&lt;/code&gt; method in the repository.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureRepository {
  // ...
  public Set&amp;lt;String&amp;gt; enabledKeys() {
    return featureKeys().stream()
        .filter(f -&amp;gt; isOn(f))
        .collect(Collectors.toSet());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this end point in place and the &lt;code&gt;management.context-path&lt;/code&gt; set to &lt;code&gt;management&lt;/code&gt; in our properties, this end point will produce the following output.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;gt; curl -s &amp;quot;http://localhost:8080/management/features&amp;quot; | jq .
{
  &amp;quot;available&amp;quot;: [
    &amp;quot;feature.foo&amp;quot;,
    &amp;quot;feature.hello&amp;quot;
  ],
  &amp;quot;enabled&amp;quot;: [
    &amp;quot;feature.hello&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to note that our end point has it’s sensitivity flag set to false by default. You should consider the &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#_security_with_healthindicators&#34;&gt;security implications&lt;/a&gt; of that before choosing to leave it false.&lt;/p&gt;
&lt;p&gt;In the next blog post in this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt;, we will explore how our feature toggle mechanism so far have introduced a dependency on the application being restarted and how to eliminate this dependency.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementing feature toggles for a Spring Boot application - Part 2</title>
      <link>https://sadique.io/blog/2016/11/27/implementing-feature-toggles-for-a-spring-boot-application-part-2/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sun, 27 Nov 2016 05:48:48 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/27/implementing-feature-toggles-for-a-spring-boot-application-part-2/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In the second part of this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt; about implementing feature toggles for a Spring Boot application, we will look at exposing the features to the Angular front-end so that features can be toggled in UI components.&lt;/p&gt;
&lt;h2 id=&#34;toggling-at-the-front-end&#34;&gt;Toggling at the front end&lt;/h2&gt;
&lt;p&gt;We decided to use the &lt;a href=&#34;https://github.com/mjt01/angular-feature-flags&#34;&gt;angular-feature-flags&lt;/a&gt; library to toggle features at the front end because it provided us the three features that we were looking for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The ability to load the state of feature flags &lt;a href=&#34;https://github.com/mjt01/angular-feature-flags#setting-flag-data&#34;&gt;from an HTTP end point&lt;/a&gt; instead of having to generate JS code through templates.&lt;/li&gt;
&lt;li&gt;The ability to toggle entire html components through the &lt;code&gt;feature-flag&lt;/code&gt; attribute directive.&lt;/li&gt;
&lt;li&gt;The ability to expose these features to services and components to make if-else decisions through &lt;code&gt;featureFlagsProvider&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;features-end-point&#34;&gt;Features end point&lt;/h2&gt;
&lt;p&gt;The library expects feature flags to be provided to &lt;code&gt;featureFlagsProvider&lt;/code&gt; in the following format:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    { &amp;quot;key&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;active&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;description&amp;quot;: &amp;quot;...&amp;quot; },
    ...
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;FeatureController&lt;/code&gt; will use the &lt;code&gt;FeatureRepository&lt;/code&gt; to expose this will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/features&amp;quot;)
public class FeatureController {
  @Autowired
  FeatureRepository featureRepository;

  @RequestMapping(&amp;quot;&amp;quot;)
  public List&amp;lt;Map&amp;gt; features() {
    return featureRepository.allFeatures()
        .entrySet()
        .stream()
        .map(entry -&amp;gt; new HashMap&amp;lt;String, Object&amp;gt;() {
          {
            put(&amp;quot;key&amp;quot;, entry.getKey());
            put(&amp;quot;active&amp;quot;, entry.getValue());
            put(&amp;quot;name&amp;quot;, entry.getKey());
            put(&amp;quot;description&amp;quot;, entry.getKey());
          }
        })
        .collect(Collectors.toList());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are using the double brace initialization technique to construct the map representing each feature. Initializing a map given a set of keys and values is still an exercise that requires a bunch of &lt;a href=&#34;https://minborgsjavapot.blogspot.com/2014/12/java-8-initializing-maps-in-smartest-way.html&#34;&gt;boiler plate&lt;/a&gt; code in Java. You can get around this by using the convenient ImmutableMap.of() provided by &lt;a href=&#34;https://mvnrepository.com/artifact/com.google.collections/google-collections/1.0&#34;&gt;Google Collections&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It is also important to change our &lt;code&gt;AppConfig&lt;/code&gt; to initialize the instance of &lt;code&gt;Featurerepository&lt;/code&gt; as a bean.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class AppConfig extends WebMvcConfigurerAdapter {
  @Autowired
  Environment env;

  // ...

  @Bean
  public FeatureRepository featureRepository() {
    return new FeatureRepository(env);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this configuration, we can get the feature state from the end point:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; curl -s &amp;quot;http://localhost:8080/features&amp;quot; | jq .
[
  {
    &amp;quot;name&amp;quot;: &amp;quot;feature.foo&amp;quot;,
    &amp;quot;active&amp;quot;: false,
    &amp;quot;description&amp;quot;: &amp;quot;feature.foo&amp;quot;,
    &amp;quot;key&amp;quot;: &amp;quot;feature.foo&amp;quot;
  },
  {
    &amp;quot;name&amp;quot;: &amp;quot;feature.hello&amp;quot;,
    &amp;quot;active&amp;quot;: true,
    &amp;quot;description&amp;quot;: &amp;quot;feature.hello&amp;quot;,
    &amp;quot;key&amp;quot;: &amp;quot;feature.hello&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For our use case, we were comfortable re-using the feature key as the name and description of the feature. You may want to capture these meta data in your application configuration and expose this using Spring Boot’s &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/1.1.7.RELEASE/api/org/springframework/boot/context/properties/ConfigurationProperties.html&#34;&gt;ConfigurationProperties&lt;/a&gt;. You can find an example of how use structured configurations in &lt;a href=&#34;https://github.com/sdqali/config-properties&#34;&gt;my example project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the next part of this &lt;a href=&#34;https://sadique.io/series/feature-toggles/&#34;&gt;series&lt;/a&gt;, we will take a look at how to expose the feature information as an &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html&#34;&gt;admin end point&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementing feature toggles for a Spring Boot application - Part 1</title>
      <link>https://sadique.io/blog/2016/11/22/implementing-feature-toggles-for-a-spring-boot-application-part-1/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Tue, 22 Nov 2016 01:03:03 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/22/implementing-feature-toggles-for-a-spring-boot-application-part-1/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In one of our recent projects at work, we implemented feature toggles for a Spring MVC / Angular JS code base and this &lt;a href=&#34;https://sadique.io/series/feature-toggles&#34;&gt;series of blog posts&lt;/a&gt; discusses our motivations and requirements, the approach we took and what we learned from it.&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Feature Toggles are a mechanism to change the behavior of software without having to re-deploy code. Pete Hogdson has a comprehensive &lt;a href=&#34;http://martinfowler.com/articles/feature-toggles.html&#34;&gt;blog post&lt;/a&gt; explaining the complexities of feature toggles.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sadique.io/images/feature-toggles.svg&#34; alt=&#34;Feature toggles&#34; title=&#34;Feature toggles&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;requirements&#34;&gt;Requirements&lt;/h2&gt;
&lt;p&gt;Our application is a Spring Boot web application that gets deployed in a Tomcat instance. The application is deployed via Chef and chef sets up the appropriate configuration parameters for the application as Tomcat &lt;a href=&#34;https://tomcat.apache.org/tomcat-8.0-doc/config/context.html#Environment_Entries&#34;&gt;Environment&lt;/a&gt; entries. Since feature toggles are ultimately application parameters &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, we started by setting them as Tomcat environment variables. Having considered this, we identified the following requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The ability to toggle dependency injection. For example, in some environments, we wanted to use Redis to store our sessions, while in some test environments, they were to be stored in memory.&lt;/li&gt;
&lt;li&gt;Ability to toggle entire Spring Controllers or individual controller methods.&lt;/li&gt;
&lt;li&gt;The ability to expose the state of feature toggles to our front end so that Angular JS components can use the feature toggles.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;our-initial-approach&#34;&gt;Our initial approach&lt;/h2&gt;
&lt;h3 id=&#34;toggling-dependency-injection&#34;&gt;Toggling dependency injection.&lt;/h3&gt;
&lt;p&gt;We started by using configuration parameters with the &lt;code&gt;feature&lt;/code&gt; prefix to toggle features. With this convention in place, we started using the &lt;code&gt;@ConditionalOnProperty&lt;/code&gt; annotation in our configuration classes to toggle the beans that got wired up. For example, to toggle between Redis and in-memory store for sessions, we ended up with the following configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class AppConfig {
  @Bean
  @ConditionalOnProperty(value = &amp;quot;feature.redis.session.store&amp;quot;, havingValue = &amp;quot;false&amp;quot;)
  public SessionRepository mapSessionRepository() {
    return new MapSessionRepository();
  }

  @Bean
  @ConditionalOnProperty(value = &amp;quot;feature.redis.session.store&amp;quot;, havingValue = &amp;quot;true&amp;quot;)
  public SessionRepository redisSessionRepository(RedisConnectionFactory factory) {
    return new RedisOperationsSessionRepository(factory);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;toggling-individual-controller-methods&#34;&gt;Toggling individual controller methods&lt;/h3&gt;
&lt;p&gt;In order to prevent end points defined by controllers and controller methods that are toggled off from being accessed, we decided to configure a &lt;code&gt;HandlerInterceptor&lt;/code&gt; &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; to intercept requests to these end points.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureInterceptor implements HandlerInterceptor {
  private final FeatureRepository featureRepository;

  public FeatureInterceptor(FeatureRepository featureRepository) {
    this.featureRepository = featureRepository;
  }

  @Override
  public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {
    HandlerMethod handlerMethod = (HandlerMethod) handler;
    FeatureToggle methodAnnotation = handlerMethod.getMethodAnnotation(FeatureToggle.class);
    if (methodAnnotation == null) {
      return true;
    }

    if(featureRepository.isOn(methodAnnotation.feature()) == null) {
      return true;
    }

    if(methodAnnotation.expectedToBeOn() == featureRepository.isOn(methodAnnotation.feature())) {
      return true;
    }

    httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);
    return false;
  }

  @Override
  public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {

  }

  @Override
  public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {

  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This feature interceptor uses the &lt;code&gt;FeatureToggle&lt;/code&gt; looks for the annotation, and the looks at a feature repository to see if the state of the feature flag is set to what the annotation expects and if it does not, returns a 404. The annotation has two attributes - &lt;code&gt;isOn&lt;/code&gt; and &lt;code&gt;feature&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FeatureToggle {
  String feature();

  boolean expectedToBeOn() default true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This annotation can be used on a controller method as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/hello&amp;quot;)
public class MessageController {
  @RequestMapping(&amp;quot;&amp;quot;)
  @FeatureToggle(feature = &amp;quot;feature.hello&amp;quot;)
  public Map hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello world!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;FeatureRepository&lt;/code&gt; has to look at all the properties that are available in the applications environment and filter out the ones that start with &lt;code&gt;feature.&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Collecting all the properties available in an environment is &lt;a href=&#34;https://stackoverflow.com/questions/23506471/spring-access-all-environment-properties-as-a-map-or-properties-object&#34;&gt;surprisingly complex&lt;/a&gt;, owing to the number of ways properties can be injected. Based on the approach discussed in that question, we can create a &lt;code&gt;FeatureRepository&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureRepository {
  private static final String FEATURE_PREFIX = &amp;quot;feature.&amp;quot;;
  private final Environment env;

  public FeatureRepository(Environment env) {
    this.env = env;
  }

  public Set&amp;lt;String&amp;gt; featureKeys() {
    Map&amp;lt;String, Object&amp;gt; map = new HashMap();
    for(Iterator it = ((AbstractEnvironment) env).getPropertySources().iterator(); it.hasNext(); ) {
      PropertySource propertySource = (PropertySource) it.next();
      if (propertySource instanceof MapPropertySource) {
        map.putAll(((MapPropertySource) propertySource).getSource());
      }
    }
    return map.keySet().stream()
        .filter(k -&amp;gt; k.startsWith(FEATURE_PREFIX))
        .collect(Collectors.toSet());
  }

  public Boolean isOn(String key) {
    return allFeatures().get(key);
  }

  public Map&amp;lt;String, Boolean&amp;gt; allFeatures() {
    return featureKeys().stream().collect(Collectors.toMap(k -&amp;gt; k, k -&amp;gt; Boolean.parseBoolean(env.getProperty(k))));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;toggling-entire-controllers&#34;&gt;Toggling entire controllers&lt;/h3&gt;
&lt;p&gt;Since Spring controllers are wired up as beans, the &lt;code&gt;ConditionalOnProperty&lt;/code&gt; annotation can be used to toggle on entire controllers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/foo&amp;quot;)
@ConditionalOnProperty(value = &amp;quot;feature.foo&amp;quot;, havingValue = &amp;quot;true&amp;quot;)
public class FooController {
  @RequestMapping(&amp;quot;&amp;quot;)
  public Map hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello foo!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, now we have two different mechanisms to toggle methods and controllers. It will be nice to consolidate them and doing so will allow us to use the same mechanism for toggling beans. This can be done by annotating &lt;code&gt;FeatureToggle&lt;/code&gt; with the &lt;a href=&#34;https://sadique.io/blog/2015/12/06/implementing-custom-annotations-for-spring-mvc/&#34;&gt;meta annotation&lt;/a&gt; &lt;code&gt;Conditional&lt;/code&gt; that looks up the state of feature toggles using the custom condition &lt;code&gt;FeatureCondition&lt;/code&gt;. This will change &lt;code&gt;FeatureToggle&lt;/code&gt; to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(FeatureCondition.class)
public @interface FeatureToggle {
  String feature();

  boolean expectedToBeOn() default true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;FeatureCondition&lt;/code&gt; uses the meta annotation attributes provided to it and the environment to decide the state to be returned:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeatureCondition implements Condition {
  @Override
  public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
    if(annotatedTypeMetadata.isAnnotated(FeatureToggle.class.getCanonicalName())) {
      Map&amp;lt;String, Object&amp;gt; annotationAttributes = annotatedTypeMetadata
          .getAnnotationAttributes(FeatureToggle.class.getCanonicalName());
      String feature = (String) annotationAttributes.get(&amp;quot;feature&amp;quot;);
      boolean expectedToBeOn = Boolean.parseBoolean(String.valueOf(annotationAttributes.get(&amp;quot;expectedToBeOn&amp;quot;)));
      boolean isOn = Boolean.parseBoolean(conditionContext.getEnvironment().getProperty(feature));
      return expectedToBeOn == isOn;
    }
    return true;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a unified mechanism to toggle controllers, beans and controller methods, we can use this annotation. The &lt;code&gt;FooController&lt;/code&gt; would now look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/foo&amp;quot;)
@FeatureToggle(feature = &amp;quot;feature.foo&amp;quot;)
public class FooController {
  @RequestMapping(&amp;quot;&amp;quot;)
  public Map hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello foo!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And our &lt;code&gt;AppConfig&lt;/code&gt; will be like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class AppConfig extends WebMvcConfigurerAdapter {
  @Autowired
  Environment env;

  @Bean
  @FeatureToggle(feature = &amp;quot;feature.redis.session.store&amp;quot;, expectedToBeOn = false)
  public SessionRepository mapSessionRepository() {
    return new MapSessionRepository();
  }

  @Bean
  @FeatureToggle(feature = &amp;quot;feature.redis.session.store&amp;quot;)
  public SessionRepository redisSessionRepository(RedisConnectionFactory factory) {
    return new RedisOperationsSessionRepository(factory);
  }

  @Override
  public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new FeatureInterceptor(new FeatureRepository(env)));
    super.addInterceptors(registry);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the second part of &lt;a href=&#34;https://sadique.io/series/feature-toggles&#34;&gt;this series&lt;/a&gt;, we will explore how the feature toggle can be exposed to the front end and how to consume this and use it for toggling features in the Angular components.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;While feature toggles are just like any other application parameter, treating them as such in our stack resulted in errors, which we address later in this series.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;HandlerInterceptor&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>A very basic introduction to deploying a Java application using Kubernetes</title>
      <link>https://sadique.io/blog/2016/11/05/a-very-basic-introduction-to-deploying-a-java-application-using-kubernetes/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sat, 05 Nov 2016 05:34:53 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/05/a-very-basic-introduction-to-deploying-a-java-application-using-kubernetes/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;I have been playing around with Kubernetes and Docker lately. To borrow the description of Kubernetes from their website,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;One of the first things I did was to try and see what it would take to go from an application to deploying it. I started with a simple Java application and had to set up the development environment. These are my notes from this process. This assumes that you have docker installed on your development environment.&lt;/p&gt;
&lt;h2 id=&#34;install-minikube&#34;&gt;Install minikube&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/minikube&#34;&gt;Minikube&lt;/a&gt; is a tool that makes it easy to run Kubernetes for local development. To run minikube, you need to have a virtualizer installed - in my case I already had VirtualBox installed. Instructions for installing minikube is available &lt;a href=&#34;https://github.com/kubernetes/minikube/releases&#34;&gt;here&lt;/a&gt;. In my case, this is what I did:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.12.2/minikube-darwin-amd64
&amp;gt; chmod +x minikube
&amp;gt; sudo mv minikube /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;install-kubectl&#34;&gt;Install kubectl&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/kubectl-overview/&#34;&gt;Kubectl&lt;/a&gt; is a command line application that executes commands against Kubernets clusters. Instructions for installing kubectl are available &lt;a href=&#34;http://kubernetes.io/docs/getting-started-guides/minikube/#install-kubectl&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; curl -Lo kubectl http://storage.googleapis.com/kubernetes-release/release/v1.3.0/bin/darwin/amd64/kubectl
&amp;gt; chmod +x kubectl
&amp;gt; sudo mv kubectl /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;set-up-a-docker-repository&#34;&gt;Set up a Docker repository&lt;/h2&gt;
&lt;p&gt;Kubernetes pulls container images from publicly available registries. But because we are building an application that we will not be publishing to public docker registries, we need to create a local registry. There is a great write up on how to set up a local docker registry at &lt;a href=&#34;http://thenewstack.io/tutorial-configuring-ultimate-development-environment-kubernetes/&#34;&gt;Newstack&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;start-minikube-with-the-registry&#34;&gt;Start minikube with the registry&lt;/h2&gt;
&lt;p&gt;Now that we have a local docker registry, we can go ahead and tell minikube to consume images from this registry. However, if you have started a minikube cluster previously, the registry override will not be available to it unless it is deleted.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; docker-machine ip registry
192.168.99.100
&amp;gt; minikube stop
&amp;gt; minikube delete
&amp;gt; minikube start --vm-driver=&amp;quot;virtualbox&amp;quot; --insecure-registry=192.168.99.100:80
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;create-a-container-image-for-the-application&#34;&gt;Create a container image for the application&lt;/h2&gt;
&lt;p&gt;The application in this case is a simple Spring Boot application that has exactly one controller.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class HelloController {
  @RequestMapping(&amp;quot;/hello&amp;quot;)
  public Map hello() {
    return singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to create a docker container from this application, we will use the &lt;a href=&#34;https://github.com/spotify/docker-maven-plugin&#34;&gt;Maven Docker Plugin&lt;/a&gt;. We will need to set a prefix for our docker image. This can be done with this maven property:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;docker.image.prefix&amp;gt;sadiqueio&amp;lt;/docker.image.prefix&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This plugin expects a &lt;code&gt;Dockerfile&lt;/code&gt; to be present in the &lt;code&gt;src/main/docker&lt;/code&gt; directory. Our &lt;code&gt;Dockerfile&lt;/code&gt; will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM frolvlad/alpine-oraclejdk8:slim
ADD hello-world-0.0.1-SNAPSHOT.jar app.jar
RUN sh -c &#39;touch /app.jar&#39;
ENTRYPOINT [&amp;quot;java&amp;quot;,&amp;quot;-jar&amp;quot;,&amp;quot;/app.jar&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this in place, we can generate a docker image. We need to ensure that we are looking at the dev docker host.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; eval $(docker-machine env dev)
&amp;gt; mvn package docker:build
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tag-and-push-the-image-to-local-registry&#34;&gt;Tag and push the image to local registry&lt;/h2&gt;
&lt;p&gt;The generated image &lt;code&gt;sadiqueio/hello-world&lt;/code&gt; need to be published to the local registry we created.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; docker tag sadiqueio/hello-world 192.168.99.100:80/hello-world
&amp;gt; docker push 192.168.99.100:80/hello-world
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;define-and-create-a-service&#34;&gt;Define and create a service&lt;/h2&gt;
&lt;p&gt;We will define a Kubernetes service object for this application &lt;code&gt;hello-world-service.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: hello-world
  labels:
    app: hello-world
    tier: backend
spec:
  type: NodePort
  ports:
    # the port that this service should serve on
  - port: 8080
  selector:
    app: hello-world
    tier: backend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The service can be created using:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; kubectl create -f hello-world-service.yaml
You have exposed your service on an external port on all nodes in your
cluster.  If you want to expose this service to the external internet, you may
need to set up firewall rules for the service port(s) (tcp:30194) to serve traffic.

See http://releases.k8s.io/release-1.3/docs/user-guide/services-firewalls.md for more details.
service &amp;quot;hello-world&amp;quot; created
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Make a note of the port assigned to this service. We will use this port later to access our application.&lt;/p&gt;
&lt;h2 id=&#34;define-and-create-a-deployment&#34;&gt;Define and create a deployment&lt;/h2&gt;
&lt;p&gt;The next step is to define and create a deployment for our application. This is where we specify the image we previously created and published to the registry.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: hello-world
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: hello-world
        tier: backend
    spec:
      containers:
      - name: hello-world
        image: 192.168.99.100:80/hello-world
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        env:
        - name: GET_HOSTS_FROM
          value: dns
        ports:
        - containerPort: 8080
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; kubectl create -f hello-world-deployment.yaml
deployment &amp;quot;hello-world&amp;quot; created
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ensure-that-the-deployment-is-successful&#34;&gt;Ensure that the deployment is successful&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; kubectl get services
NAME          CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
hello-world   10.0.0.252   &amp;lt;none&amp;gt;        8080/TCP   4m
&amp;gt; kubectl get deployments
NAME          DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
hello-world   1         1         1            1           4m
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;access-the-service&#34;&gt;Access the service&lt;/h2&gt;
&lt;p&gt;We already know the port assigned to our service. Because we specified &lt;code&gt;type: NodePort&lt;/code&gt;, the IP address we need to use is that of the Kubernetes cluster. This IP address can be found using the minikube command.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; minikube ip
192.168.99.102
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have both pieces of information, we can test that our application is up.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; curl  -s http://192.168.99.102:30194/hello | jq .
{
  &amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is it. We have deployed our hello world application using Kubernetes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Handling Deserialization errors in Spring Redis Sessions</title>
      <link>https://sadique.io/blog/2016/11/02/handling-deserialization-errors-in-spring-redis-sessions/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Wed, 02 Nov 2016 20:10:33 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/11/02/handling-deserialization-errors-in-spring-redis-sessions/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;One of the challenges of using storing spring sessions in Redis is that the objects that gets stored as part of a session often undergoes changes as the application evolves and these changes cause de-serialization exceptions to be thrown after a deployment when a session created before the deployment is presented to the application. This blog post discusses a method to work around this issue.&lt;/p&gt;
&lt;h2 id=&#34;the-issue&#34;&gt;The issue&lt;/h2&gt;
&lt;p&gt;Consider an application that uses a custom authentication service to validate credentials presented by a client. To achieve this, we will wire up a custom authentication provider which creates an object &lt;code&gt;Customer&lt;/code&gt; as the authenticated user in session.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Customer extends User {
  public Customer(String name) {
    super(name, &amp;quot;&amp;quot;, Collections.singletonList(new SimpleGrantedAuthority(&amp;quot;USER&amp;quot;)));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Things work great, but after a while the team decides to store the logged in user&amp;rsquo;s email address in the session. To achieve this, we change the &lt;code&gt;Customer&lt;/code&gt; type to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Customer extends User {
  private String email;

  public Customer(String name, String email) {
    super(name, &amp;quot;&amp;quot;, Collections.singletonList(new SimpleGrantedAuthority(&amp;quot;USER&amp;quot;)));
    this.email = email;
  }

  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When this code is deployed and a user tries to access a protected resource by presenting a session created before the deployment, an exception is thrown.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;org.springframework.data.redis.serializer.SerializationException: Cannot deserialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.InvalidClassException: in.sdqali.spring.vo.Customer; local class incompatible: stream classdesc serialVersionUID = 5161850915957547690, local class serialVersionUID = 1045726772100761661
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This happens because the serialized object in the session and the current structure of the session differ.&lt;/p&gt;
&lt;h2 id=&#34;solutions&#34;&gt;Solutions&lt;/h2&gt;
&lt;p&gt;This issue was raised on the Spring Session issue tracker &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; and there were a lot of work-arounds discussed. Of the work arounds, wrapping the session repository offers the least disruption to the end user.
This approach ensures that every time a de-serialization error is thrown while trying to read an object from the session, that object is deleted, preventing subsequent errors.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SafeDeserializationRepository&amp;lt;S extends ExpiringSession&amp;gt; implements SessionRepository&amp;lt;S&amp;gt; {
  private final SessionRepository&amp;lt;S&amp;gt; delegate;
  private final RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate;

  private static final String BOUNDED_HASH_KEY_PREFIX = &amp;quot;spring:session:sessions:&amp;quot;;
  private static final Logger logger = getLogger(SafeDeserializationRepository.class);

  public SafeDeserializationRepository(SessionRepository&amp;lt;S&amp;gt; delegate,
                                       RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate) {
    this.delegate = delegate;
    this.redisTemplate = redisTemplate;
  }

  @Override
  public S createSession() {
    return delegate.createSession();
  }

  @Override
  public void save(S session) {
    delegate.save(session);
  }

  @Override
  public S getSession(String id) {
    try {
      return delegate.getSession(id);
    } catch(SerializationException e) {
      logger.info(&amp;quot;Deleting non-deserializable session with key {}&amp;quot;, id);
      redisTemplate.delete(BOUNDED_HASH_KEY_PREFIX + id);
      return null;
    }
  }

  @Override
  public void delete(String id) {
    delegate.delete(id);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, it is not easy to wire up this repository in the configuration. Since Spring Redis Session is auto configured, the only way to override beans for Redis Session is to extend &lt;code&gt;RedisHttpSessionConfiguration&lt;/code&gt; and specify beans. Ideally, we want to override the method &lt;code&gt;RedisHttpSessionConfiguration#sessionRepository&lt;/code&gt;. This would mean that &lt;code&gt;SafeDeserializationRepository&lt;/code&gt; inherits from &lt;code&gt;RedisOperationsSessionRepository&lt;/code&gt;. That does not sound too complicated till you realize that &lt;code&gt;RedisOperationsSessionRepository#getSession(java.lang.String)&lt;/code&gt; returns &lt;code&gt;RedisSession&lt;/code&gt; which is a final class declared inside &lt;code&gt;RedisOperationsSessionRepository&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;On closer look, the repository is hooked in to &lt;code&gt;SessionRepositoryFilter&lt;/code&gt; and it is indeed possible to override the &lt;code&gt;SpringHttpSessionConfiguration#springSessionRepositoryFilter&lt;/code&gt; method to create a new filter that takes our &lt;code&gt;SafeDeserializationRepository&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class RedisSessionConfig extends RedisHttpSessionConfiguration {
  @Autowired
  RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate;

  @Bean
  @Override
  public &amp;lt;S extends ExpiringSession&amp;gt; SessionRepositoryFilter&amp;lt;? extends ExpiringSession&amp;gt; springSessionRepositoryFilter(SessionRepository&amp;lt;S&amp;gt; sessionRepository) {
    return super.springSessionRepositoryFilter(new SafeDeserializationRepository&amp;lt;&amp;gt;(sessionRepository, redisTemplate));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/spring-projects/spring-session/issues/280&#34;&gt;SerializationFailedException after re-deploying with changed session object #280&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Controlling Redis auto-configuration for Spring Boot Session</title>
      <link>https://sadique.io/blog/2016/07/16/controlling-redis-auto-configuration-for-spring-boot-session/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Sat, 16 Jul 2016 22:42:05 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/07/16/controlling-redis-auto-configuration-for-spring-boot-session/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;If you have been using Spring Boot, chances are that you are using the Spring Session library to handle sessions. Spring Session has the ability to persist the sessions to various data stores, including Redis. The default behaviors of Spring Boot when combined with Spring Session is to start using Redis as the session store the moment &lt;code&gt;spring-session-data-redis&lt;/code&gt; is detected in the class path, thereby making it hard to conditionally turn Redis support ON and OFF. This blog post explores why this is the default behavior and presents a solution to control this behavior.&lt;/p&gt;
&lt;h3 id=&#34;the-application&#34;&gt;The application&lt;/h3&gt;
&lt;p&gt;The application we will be using to demonstrate this behavior is a Spring Boot 1.3.6 application with a single controller.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/hello&amp;quot;)
public class HelloController {
  @RequestMapping(method = GET,
      path = &amp;quot;&amp;quot;,
      produces = APPLICATION_JSON_VALUE)
  public Map&amp;lt;String, String&amp;gt; hello() {
    return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The application also has Spring Security configured to allow authentication for a single user named &lt;code&gt;user&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
        .antMatchers(&amp;quot;/hello/**&amp;quot;).hasRole(&amp;quot;USER&amp;quot;)
        .and()
        .httpBasic();
  }

  @Autowired
  public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .inMemoryAuthentication()
        .withUser(&amp;quot;user&amp;quot;).password(&amp;quot;password&amp;quot;).roles(&amp;quot;USER&amp;quot;);
  }

  @Bean
  public HeaderHttpSessionStrategy sessionStrategy() {
    return new HeaderHttpSessionStrategy();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This forces clients to authenticate for access to resources under &lt;code&gt;/hello&lt;/code&gt; and configures an in memory user &lt;code&gt;user&lt;/code&gt; with password &lt;code&gt;password&lt;/code&gt;. In this example, we will also be using &lt;code&gt;HeaderHttpSessionStrategy&lt;/code&gt; &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; to pass the session value between client and server using the &lt;code&gt;x-auth-token&lt;/code&gt; header instead of a Cookie.&lt;/p&gt;
&lt;h3 id=&#34;the-issue&#34;&gt;The issue&lt;/h3&gt;
&lt;p&gt;This is an issue only when using Spring Boot 1.3 or greater. If we are to follow the instructions provided at the &lt;a href=&#34;http://docs.spring.io/spring-session/docs/1.2.1.RELEASE/reference/html5/guides/boot.html&#34;&gt;official documentation&lt;/a&gt; from Spring Session &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, we end up with the following configuration.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@EnableRedisHttpSession
public class RedisSessionConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this in place, authentication works as we expect. The application allows the user to obtain a session and authenticates correctly when presented with the session token.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -i -s -X GET &amp;quot;http://localhost:8080/hello&amp;quot; -uuser:password  | grep &amp;quot;x-auth-token&amp;quot;
x-auth-token: c0fbb47d-d19f-44b1-a8d7-44e4837f403d
$ curl -s -X GET &amp;quot;http://localhost:8080/hello&amp;quot; --header &amp;quot;x-auth-token: c0fbb47d-d19f-44b1-a8d7-44e4837f403d&amp;quot; | jq .
{
  &amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can monitor the interactions the application performs with Redis by running Redis monitor:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ redis-cli monitor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is great. Now, let&amp;rsquo;s attempt to modify our configuration to use Redis only in some environments and use the in-memory session store in others. We start by making &lt;code&gt;RedisSessionConfig&lt;/code&gt; conditional on the value of the property &lt;code&gt;use.redis.session.store&lt;/code&gt; being &lt;code&gt;true&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ConditionalOnProperty(name = &amp;quot;use.redis.session.store&amp;quot;, havingValue = &amp;quot;true&amp;quot;)
@EnableRedisHttpSession
public class RedisSessionConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will create a new configuration that sets up the in-memory session store if &lt;code&gt;use.redis.session.store&lt;/code&gt; is false or missing.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableSpringHttpSession
@ConditionalOnProperty(name = &amp;quot;use.redis.session.store&amp;quot;, havingValue = &amp;quot;false&amp;quot;, matchIfMissing = true)
public class MapSessionConfig {
  @Bean
  public SessionRepository sessionRepository() {
    return new MapSessionRepository();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s set the property to &lt;code&gt;false&lt;/code&gt; so that we do not have to depend on Redis in the local environment.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;use.redis.session.store=false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this in place, we expect that there are no interactions with Redis server. If we were to start the server, we will get the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
Caused by: java.net.ConnectException: Connection refused
    at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_45]
    at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:345) ~[na:1.8.0_45]
    at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_45]
    at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_45]
    at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_45]
    at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_45]
    at redis.clients.jedis.Connection.connect(Connection.java:158) ~[jedis-2.7.3.jar:na]
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It appears that the application is trying to make connections to Redis, even though we configured it not to. What is going on? It looks like some where along the chain, some configuration with the annotation &lt;code&gt;@EnableSpringHttpSession&lt;/code&gt; is being loaded. Why could that happen?&lt;/p&gt;
&lt;h3 id=&#34;spring-boot-autoconfig&#34;&gt;Spring Boot Autoconfig&lt;/h3&gt;
&lt;p&gt;Like a lot of Spring Boot applications, we are using the &lt;code&gt;@SpringBootApplication&lt;/code&gt; annotation in our application. This is a meta-annotation &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; that takes the following form:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Configuration
@EnableAutoConfiguration
@ComponentScan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; annotation is interesting because it wires up most of the default configuration that makes Spring Boot great for development. The annotation itself and the supporting mechanism that automatically loads configurations are present in the &lt;code&gt;org.springframework.boot:spring-boot-autoconfigure&lt;/code&gt; library. One of these configurations is &lt;code&gt;SessionAutoConfiguration&lt;/code&gt; which was introduced in Spring Boot &lt;code&gt;1.3.0&lt;/code&gt;. It has the following code in version &lt;code&gt;1.3.6&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ConditionalOnClass(Session.class)
@AutoConfigureAfter(RedisAutoConfiguration.class)
public class SessionAutoConfiguration {

    @EnableConfigurationProperties
    @ConditionalOnClass(RedisConnectionFactory.class)
    @ConditionalOnWebApplication
    @ConditionalOnMissingBean(RedisHttpSessionConfiguration.class)
    @EnableRedisHttpSession
    @Configuration
    public static class SessionRedisHttpConfiguration {

        @Autowired
        private ServerProperties serverProperties;

        @Autowired
        private RedisOperationsSessionRepository sessionRepository;

        @PostConstruct
        public void applyConfigurationProperties() {
            Integer timeout = this.serverProperties.getSession().getTimeout();
            if (timeout != null) {
                this.sessionRepository.setDefaultMaxInactiveInterval(timeout);
            }
        }

        @Configuration
        @ConditionalOnMissingBean(value = ServerProperties.class, search = SearchStrategy.CURRENT)
        // Just in case user switches off ServerPropertiesAutoConfiguration
        public static class ServerPropertiesConfiguration {

            @Bean
            // Use the same bean name as the default one for any old webapp
            public ServerProperties serverProperties() {
                return new ServerProperties();
            }

        }

    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And this is where things get interesting. We can clearly see that &lt;code&gt;SessionRedisHttpConfiguration&lt;/code&gt; is annotated with &lt;code&gt;@EnableRedisHttpSession&lt;/code&gt;. This class will be applied by Spring the moment it&amp;rsquo;s parent class &lt;code&gt;SessionAutoConfiguration&lt;/code&gt; is applied. The third annotation on the parent class &lt;code&gt;@AutoConfigureAfter(RedisAutoConfiguration.class)&lt;/code&gt; instructs Spring to apply this configuration after &lt;code&gt;RedisAutoConfiguration&lt;/code&gt;. This configuration has the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ConditionalOnClass({ JedisConnection.class, RedisOperations.class, Jedis.class })
@EnableConfigurationProperties
public class RedisAutoConfiguration {
// ...
// ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This configuration will be applied if and only if the classes &lt;code&gt;JedisConnection&lt;/code&gt;, &lt;code&gt;RedisOperations&lt;/code&gt; and &lt;code&gt;Jedis&lt;/code&gt; are present in the class path and by adding &lt;code&gt;spring-session-data-redis&lt;/code&gt; as a dependency, we are causing exactly that to happen.&lt;/p&gt;
&lt;h3 id=&#34;a-solution&#34;&gt;A solution&lt;/h3&gt;
&lt;p&gt;We can prevent this from occurring by configuring our application to not attempt to apply this auto configuration class. This can be done by specifying this class to be excluded from the application.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication(exclude = {SessionAutoConfiguration.class})
public class RedisSessionApplication {
    public static void main(String[] args) {
        SpringApplication.run(RedisSessionApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this is place, if we run the application, it will no longer encounter the connection error previously saw. Authentication works as before, except that it now uses the in-memory session store.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -i -s -X GET &amp;quot;http://localhost:8080/hello&amp;quot; -uuser:password  | grep &amp;quot;x-auth-token&amp;quot;
x-auth-token: d0962e39-6423-46b3-b815-8979950e063a
$ curl -s -X GET &amp;quot;http://localhost:8080/hello&amp;quot; --header &amp;quot;x-auth-token: d0962e39-6423-46b3-b815-8979950e063a&amp;quot; | jq .
{
  &amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;HeaderHttpSessionStrategy allows the use of a header to transmit the session between client and server. The default header is &lt;code&gt;x-auth-token&lt;/code&gt;, but this can be configured. See the documentation &lt;a href=&#34;http://docs.spring.io/spring-session/docs/current/api/org/springframework/session/web/http/HeaderHttpSessionStrategy.html&#34;&gt;here&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;This example uses the default configurations for Redis connection to localhost on port 6379.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;Meta annotations are annotations that can act up on other annotations by modifying and overriding their attributes. For a discussion on how to implement custom annotations using meta annotations, please refer to &lt;a href=&#34;https://sadique.io/blog/2015/12/06/implementing-custom-annotations-for-spring-mvc/&#34;&gt;this blog post&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>JWT authentication with Spring Web - Part 5</title>
      <link>https://sadique.io/blog/2016/07/14/jwt-authentication-with-spring-web-part-5/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Thu, 14 Jul 2016 06:05:53 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/07/14/jwt-authentication-with-spring-web-part-5/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In parts 1 through 4 of this series, we built a Spring API that can issue a JWT when a user successfully authenticates and verify the JWT presented by the client for subsequent requests. In this blog post - the last in the series, we will build a simple Angular JS application with authentication that uses this API as the backend.&lt;/p&gt;
&lt;p&gt;These are the blog posts in this series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/02/jwt-authentication-with-spring-web-part-1/&#34;&gt;Part 1&lt;/a&gt; - Discussion of JWT and implementation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/03/jwt-authentication-with-spring-web-part-2/&#34;&gt;Part 2&lt;/a&gt; - A Spring User Profiles API&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/05/jwt-authentication-with-spring-web-part-3/&#34;&gt;Part 3&lt;/a&gt; - Issuing a token from the server&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/07/jwt-authentication-with-spring-web-part-4/&#34;&gt;Part 4&lt;/a&gt; - Verifying the token sent back by the client&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/13/jwt-authentication-with-spring-web-part-5/&#34;&gt;Part 5&lt;/a&gt; - Securing the front end&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will use the following Angular plugins - &lt;code&gt;angular-resource&lt;/code&gt; for interacting with our APIs, &lt;code&gt;ngstorage&lt;/code&gt; to access the localStorage to store the JWT and &lt;code&gt;angular-ui-router&lt;/code&gt; to handle routing and managing UI views.&lt;/p&gt;
&lt;p&gt;For this example, our UI components are under the &lt;code&gt;src/main/resources/static&lt;/code&gt; directory. We will be loading our dependencies using bower by adding a &lt;code&gt;.bowerrc&lt;/code&gt; file at the root of our project.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;directory&amp;quot;: &amp;quot;src/main/resources/static/bower_components&amp;quot;,
  &amp;quot;json&amp;quot;: &amp;quot;bower.json&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will specify the dependencies we need in our &lt;code&gt;bower.json&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;jwt&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;angular&amp;quot;: &amp;quot;~1.3.0&amp;quot;,
    &amp;quot;angular-resource&amp;quot;: &amp;quot;~1.3.0&amp;quot;,
    &amp;quot;bootstrap-css-only&amp;quot;: &amp;quot;~3.2.0&amp;quot;,
    &amp;quot;ngstorage&amp;quot;: &amp;quot;0.3.10&amp;quot;,
    &amp;quot;angular-ui-router&amp;quot;: &amp;quot;1.0.0-beta.1&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The dependencies can be installed using &lt;code&gt;bower install&lt;/code&gt;. Once we have the dependencies, we can start by configuring Spring Security to allow access to the UI components:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        String[] patterns = new String[] {
            &amp;quot;/login&amp;quot;,
            &amp;quot;/bower_components/**/*&amp;quot;,
            &amp;quot;/app/**/*&amp;quot;,
            &amp;quot;/index.html&amp;quot;,
            &amp;quot;/home.html&amp;quot;,
            &amp;quot;/signin.html&amp;quot;
        };
        http.authorizeRequests()
                .antMatchers(patterns)
                .permitAll()
        // ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will start by creating our UI template &lt;code&gt;index.html&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;./bower_components/bootstrap-css-only/css/bootstrap.min.css&amp;quot; /&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body ng-app=&amp;quot;jwtDemo&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
      &amp;lt;ui-view&amp;gt;&amp;lt;/ui-view&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./bower_components/angular/angular.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./bower_components/angular-resource/angular-resource.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./bower_components/ngstorage/ngStorage.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./bower_components/angular-ui-router/release/angular-ui-router.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./app/app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./app/controllers.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./app/services.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For this example, we will have one Angular service in &lt;code&gt;app/services.js&lt;/code&gt; that performs login:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(angular) {
  var LoginFactory = function($resource) {
    return $resource(&#39;/login&#39;, {}, {
      login: {
        method: &#39;POST&#39;
      }
    });
  };

  LoginFactory.$inject = [&#39;$resource&#39;];
  angular.module(&#39;jwtDemo.services&#39;).factory(&#39;Login&#39;, LoginFactory);
}(angular));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will need two controllers in &lt;code&gt;app/controller.js&lt;/code&gt; - one for the login page to manage login and one for the profile page:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(angular) {
  var LoginController = function($scope, $localStorage, $http, $location, Login) {
    $scope.login = function(username, password) {
      new Login({username: username, password: password})
          .$login(function (profile, headers) {
            $localStorage.user = profile;
            $localStorage.token = headers().token;
            $http.defaults.headers.common.Authorization = &#39;Bearer &#39; + headers().token;
            $location.path(&amp;quot;/&amp;quot;);
          }, function (error) {
            console.log(error);
          });
    };

    $scope.logout = function () {
      delete $localStorage.user;
      delete $localStorage.token;
      $http.defaults.headers.common = {};
    }

    $scope.logout();
  };

  LoginController.$inject = [&#39;$scope&#39;, &#39;$localStorage&#39;, &#39;$http&#39;, &#39;$location&#39;,&#39;Login&#39;];
  angular.module(&amp;quot;jwtDemo.controllers&amp;quot;).controller(&amp;quot;LoginController&amp;quot;, LoginController);


  var ProfileController = function ($scope, $localStorage) {
    $scope.profile = $localStorage.user;
  };
  ProfileController.inject = [&#39;$scope&#39;, &#39;$localStorage&#39;];
  angular.module(&amp;quot;jwtDemo.controllers&amp;quot;).controller(&amp;quot;ProfileController&amp;quot;, ProfileController);
}(angular));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;LoginController&lt;/code&gt; has two methods - login and logout. The login method uses the &lt;code&gt;LoginService&lt;/code&gt; to make a request and saves the JWT and user profile returned up on successful login. It also sets the &lt;code&gt;Authorization&lt;/code&gt; header default to the JWT returned so that every subsequent request uses it to authenticate. The user is then navigated to the home page. Logout is performed by removing the JWT and profile from local storage and clearing the header defaults.&lt;/p&gt;
&lt;p&gt;The next step is to create &lt;code&gt;app/app.js&lt;/code&gt; to wire up the Angular application together:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(angular) {
  angular.module(&amp;quot;jwtDemo.controllers&amp;quot;, []);
  angular.module(&amp;quot;jwtDemo.services&amp;quot;, []);
  angular.module(&amp;quot;jwtDemo&amp;quot;, [&amp;quot;ui.router&amp;quot;, &amp;quot;ngResource&amp;quot;, &amp;quot;ngStorage&amp;quot;, &amp;quot;jwtDemo.controllers&amp;quot;, &amp;quot;jwtDemo.services&amp;quot;])
      .config(function ($stateProvider, $urlRouterProvider) {
        $urlRouterProvider.otherwise(&amp;quot;/&amp;quot;);

        $stateProvider
            .state(&#39;home&#39;, {
              url: &#39;/&#39;,
              templateUrl: &#39;home.html&#39;,
              controller: &#39;ProfileController&#39;
            })
            .state(&#39;signin&#39;, {
              url: &#39;/signin&#39;,
              templateUrl: &#39;signin.html&#39;,
              controller: &#39;LoginController&#39;
            })
            .state(&#39;signout&#39;, {
              url: &#39;/signout&#39;,
              templateUrl: &#39;signin.html&#39;,
              controller: &#39;LoginController&#39;
            });
      })
      .run(function ($localStorage, $http, $location, $rootScope) {
        if ($localStorage.user) {
          $http.defaults.headers.common.Authorization = &#39;Bearer &#39; + $localStorage.token;
        }

        $rootScope.$on(&#39;$locationChangeStart&#39;, function (event, next, current) {
          if ($location.path() !== &amp;quot;/signin&amp;quot; &amp;amp;&amp;amp; !$localStorage.user) {
            $location.path(&#39;/signin&#39;);
          } else if ($location.path() === &amp;quot;/signin&amp;quot; &amp;amp;&amp;amp; $localStorage.user) {
            $location.path(&#39;/&#39;);
          }
        });
      });
}(angular));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We start by wiring together our services and controllers to the main module. We use the state provider to map front end URLs to templates. The home page will use the &lt;code&gt;home.html&lt;/code&gt; template and the sign in and sign out URLs will use the &lt;code&gt;sigin.html&lt;/code&gt; template.&lt;/p&gt;
&lt;p&gt;It also configures a listener that observes for URL changes made by the user and redirects them to the sign in page, unless they are already authenticated. If there is already a token in local storage when the application loads, that signifies that the user has already logged in a different tab and the authorization header default is set.&lt;/p&gt;
&lt;p&gt;The two views we have are simple - &lt;code&gt;signin.html&lt;/code&gt; has a sign form:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&#39;col-md-3&#39;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-6&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;login-box well&amp;quot;&amp;gt;
      &amp;lt;form role=&amp;quot;form&amp;quot; ng-submit=&amp;quot;login(username, password)&amp;quot;&amp;gt;
        &amp;lt;legend&amp;gt;Sign In&amp;lt;/legend&amp;gt;
        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
          &amp;lt;label for=&amp;quot;username-email&amp;quot;&amp;gt;Username&amp;lt;/label&amp;gt;
          &amp;lt;input ng-model=&amp;quot;username&amp;quot; value=&#39;&#39; id=&amp;quot;username-email&amp;quot; placeholder=&amp;quot;Username&amp;quot; type=&amp;quot;text&amp;quot;
                 class=&amp;quot;form-control&amp;quot; /&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
          &amp;lt;label for=&amp;quot;password&amp;quot;&amp;gt;Password&amp;lt;/label&amp;gt;
          &amp;lt;input ng-model=&amp;quot;password&amp;quot; id=&amp;quot;password&amp;quot; value=&#39;&#39; placeholder=&amp;quot;Password&amp;quot; type=&amp;quot;password&amp;quot;
                 class=&amp;quot;form-control&amp;quot; /&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
          &amp;lt;input type=&amp;quot;submit&amp;quot; class=&amp;quot;btn btn-default btn-login-submit btn-block m-t-md&amp;quot; value=&amp;quot;Login&amp;quot; /&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&#39;col-md-3&#39;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The view for home page - &lt;code&gt;home.html&lt;/code&gt; renders a user profile:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;h1&amp;gt;Welcome, {{profile.name.first}}&amp;lt;/h1&amp;gt;
  &amp;lt;div class=&amp;quot;col-lg-3 col-sm-6&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;card hovercard&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;cardheader&amp;quot;&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;avatar&amp;quot;&amp;gt;
        &amp;lt;img alt=&amp;quot;&amp;quot; src=&amp;quot;{{profile.thumbnail}}&amp;quot;&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;info&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;title&amp;quot;&amp;gt;
          {{profile.username}}
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;desc&amp;quot;&amp;gt;{{profile.name.first}} {{profile.name.last}}&amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;a href=&amp;quot;/#/signout&amp;quot;&amp;gt;Sign Out&amp;lt;/a&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It also has a link for signing out. With this code in place, we can start our Spring application and sign in from the browser.&lt;/p&gt;
&lt;p&gt;This is the last of this series of blog posts on JWT and Spring. We built an API capable of authenticating with JWTs and a front end capable of authenticating against this API. The code for the complete example is available on &lt;a href=&#34;https://github.com/sdqali/jwt-demo&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JWT authentication with Spring Web - Part 4</title>
      <link>https://sadique.io/blog/2016/07/08/jwt-authentication-with-spring-web-part-4/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Fri, 08 Jul 2016 06:47:53 +0000</pubDate>
      
      <guid>https://sadique.io/blog/2016/07/08/jwt-authentication-with-spring-web-part-4/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;p&gt;In parts 1 through 3 of this series, we built a Spring API that can issue a JWT when a user successfully authenticates. In this blog post, we will add the capability to verify the JWT presented by the client for subsequent requests.&lt;/p&gt;
&lt;p&gt;These are the blog posts in this series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/02/jwt-authentication-with-spring-web-part-1/&#34;&gt;Part 1&lt;/a&gt; - Discussion of JWT and implementation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/03/jwt-authentication-with-spring-web-part-2/&#34;&gt;Part 2&lt;/a&gt; - A Spring User Profiles API&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/05/jwt-authentication-with-spring-web-part-3/&#34;&gt;Part 3&lt;/a&gt; - Issuing a token from the server&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/07/jwt-authentication-with-spring-web-part-4/&#34;&gt;Part 4&lt;/a&gt; - Verifying the token sent back by the client&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sadique.io/blog/2016/07/13/jwt-authentication-with-spring-web-part-5/&#34;&gt;Part 5&lt;/a&gt; - Securing the front end&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will start by configuring Spring security with a filter to capture the JWT passed by the client in the &lt;code&gt;Authorization&lt;/code&gt; header. We will wire up this filter to go before the &lt;code&gt;UsernamePasswordAuthenticationFilter&lt;/code&gt; provided by Spring security.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private JwtAuthFilter jwtAuthFilter;
    // ...

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();

        http.authorizeRequests()
                .antMatchers(&amp;quot;/login&amp;quot;)
                .permitAll()
                .antMatchers(&amp;quot;/**/*&amp;quot;)
                .hasAuthority(&amp;quot;ROLE_USER&amp;quot;)
                .and()
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                // ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The filter captures the &lt;code&gt;Authorization&lt;/code&gt; header and creates a &lt;code&gt;JwtAuthToken&lt;/code&gt; and sets that as the current authentication for the request.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class JwtAuthFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest servletRequest = (HttpServletRequest) request;
        String authorization = servletRequest.getHeader(&amp;quot;Authorization&amp;quot;);
        if (authorization != null) {
            JwtAuthToken token = new JwtAuthToken(authorization.replaceAll(&amp;quot;Bearer &amp;quot;, &amp;quot;&amp;quot;));
            SecurityContextHolder.getContext().setAuthentication(token);
        }
        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;JwtAuthToken&lt;/code&gt; is simply a conduit to carry the token and although it implements the &lt;code&gt;Authentication&lt;/code&gt; interface, it does not do much.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JwtAuthToken implements Authentication {
    private final String token;

    public JwtAuthToken(String token) {
        this.token = token;
    }

    @Override
    public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities() {
        return null;
    }

    @Override
    public Object getCredentials() {
        return token;
    }

    @Override
    public Object getDetails() {
        return null;
    }

    @Override
    public Object getPrincipal() {
        return null;
    }

    @Override
    public boolean isAuthenticated() {
        return false;
    }

    @Override
    public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException {

    }

    @Override
    public String getName() {
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point, we need to tell Spring Security how to verify the tokens. This can be done by providing a custom &lt;code&gt;AuthenticationProvider&lt;/code&gt;. This can be done by overriding the &lt;code&gt;configure&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private JwtAuthenticationProvider jwtAuthenticationProvider;

    // ...
    @Override
    public void configure(AuthenticationManagerBuilder auth)  throws Exception {
        auth.authenticationProvider(jwtAuthenticationProvider);
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;JwtAuthenticationProvider&lt;/code&gt; receives the &lt;code&gt;Authentication&lt;/code&gt; instance set on the &lt;code&gt;SecurityContext&lt;/code&gt;, which in our case is the &lt;code&gt;JwtAuthToken&lt;/code&gt; we set using the &lt;code&gt;JwtAuthFilter&lt;/code&gt;. This token is then verified using the &lt;code&gt;JwtService&lt;/code&gt;. If the token is valid, we return a &lt;code&gt;JwtAuthenticatedProfile&lt;/code&gt; or throw an exception if it is invalid.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class JwtAuthenticationProvider implements AuthenticationProvider {
    private final JwtService jwtService;

    @SuppressWarnings(&amp;quot;unused&amp;quot;)
    public JwtAuthenticationProvider() {
        this(null);
    }

    @Autowired
    public JwtAuthenticationProvider(JwtService jwtService) {
        this.jwtService = jwtService;
    }

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        try {
            Optional&amp;lt;MinimalProfile&amp;gt; possibleProfile = jwtService.verify((String) authentication.getCredentials());
            return new JwtAuthenticatedProfile(possibleProfile.get());
        } catch (Exception e) {
            throw new JwtAuthenticationException(&amp;quot;Failed to verify token&amp;quot;, e);
        }
    }

    @Override
    public boolean supports(Class&amp;lt;?&amp;gt; authentication) {
        return JwtAuthToken.class.equals(authentication);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;JwtAuthenticatedProfile&lt;/code&gt; is another implementation of &lt;code&gt;Authentication&lt;/code&gt; that wraps the user&amp;rsquo;s profile information:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JwtAuthenticatedProfile implements Authentication {

    private final MinimalProfile minimalProfile;

    public JwtAuthenticatedProfile(MinimalProfile minimalProfile) {
        this.minimalProfile = minimalProfile;
    }

    @Override
    public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority(&amp;quot;ROLE_USER&amp;quot;));
    }

    @Override
    public Object getCredentials() {
        return null;
    }

    @Override
    public Object getDetails() {
        return null;
    }

    @Override
    public Object getPrincipal() {
        return null;
    }

    @Override
    public boolean isAuthenticated() {
        return true;
    }

    @Override
    public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException {

    }

    @Override
    public String getName() {
        return minimalProfile.getUsername();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we implement the verify functionality in &lt;code&gt;JwtService&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public Optional&amp;lt;MinimalProfile&amp;gt; verify(String token) throws IOException, URISyntaxException {
        byte[] secretKey = secretKeyProvider.getKey();
        Jws&amp;lt;Claims&amp;gt; claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);
        return profileService.minimal(claims.getBody().getSubject().toString());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we generated the JWT, we had set the username as the JWT subject.&lt;/p&gt;
&lt;p&gt;The last thing to do is to ensure that we handle exceptions that occur during token verification gracefully. Since the token verification is happening outside controllers, we won&amp;rsquo;t be able to leverage &lt;code&gt;ControllerAdvice&lt;/code&gt; to handle exceptions. This is where Spring Security&amp;rsquo;s &lt;code&gt;AuthenticationEntryPoint&lt;/code&gt; comes in to play. We will configure a custom &lt;code&gt;AuthenticationEntryPoint&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        http.authorizeRequests()
                .antMatchers(&amp;quot;/login&amp;quot;, &amp;quot;/bower_components/**/*&amp;quot;, &amp;quot;/app/**/*&amp;quot;, &amp;quot;/index.html&amp;quot;)
                .permitAll()
                .antMatchers(&amp;quot;/**/*&amp;quot;)
                .hasAuthority(&amp;quot;ROLE_USER&amp;quot;)
                .and()
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling()
                .authenticationEntryPoint(jwtAuthEndPoint);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our entry point, sets the HTTP status to &lt;code&gt;403&lt;/code&gt;, and sets the response body to a JSON showing the error.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e)
            throws IOException, ServletException {
        httpServletResponse.setStatus(SC_FORBIDDEN);
        httpServletResponse.setContentType(MediaType.APPLICATION_JSON_VALUE);

        String message;
        if(e.getCause() != null) {
            message = e.getCause().getMessage();
        } else {
            message = e.getMessage();
        }
        byte[] body = new ObjectMapper()
                .writeValueAsBytes(Collections.singletonMap(&amp;quot;error&amp;quot;, message));
        httpServletResponse.getOutputStream().write(body);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this configuration in place, we can request a token and make a subsequent request with the received JWT.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl -i -X POST &amp;quot;http://localhost:8080/login&amp;quot; -d &#39;{&amp;quot;username&amp;quot;:&amp;quot;greenrabbit948&amp;quot;, &amp;quot;password&amp;quot;:&amp;quot;celeste&amp;quot;}&#39; --header &amp;quot;Content-Type: application/json&amp;quot;
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Frame-Options: DENY
Token: eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJncmVlbnJhYmJpdDk0OCIsImV4cCI6MTQ2ODE0MDg1MiwiaXNzIjoiaW4uc2RxYWxpLmp3dCJ9.t9pqrOmYfaVkzuAQgo4D4VbN2PibQuHPuPA6RKYU-keTzbFAX58l77hQTc4Cq28HpjFOeiDvNpNEgilNHFOfVA
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Sun, 10 Jul 2016 06:54:12 GMT

{&amp;quot;username&amp;quot;:&amp;quot;greenrabbit948&amp;quot;,&amp;quot;name&amp;quot;:{&amp;quot;title&amp;quot;:&amp;quot;miss&amp;quot;,&amp;quot;first&amp;quot;:&amp;quot;dionaura&amp;quot;,&amp;quot;last&amp;quot;:&amp;quot;rodrigues&amp;quot;},&amp;quot;thumbnail&amp;quot;:&amp;quot;https://randomuser.me/api/portraits/thumb/women/78.jpg&amp;quot;}

$ curl -s &amp;quot;http://localhost:8080/profile/details/yellowfrog347&amp;quot; --header &amp;quot;Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJncmVlbnJhYmJpdDk0OCIsImV4cCI6MTQ2ODE0MDg1MiwiaXNzIjoiaW4uc2RxYWxpLmp3dCJ9.t9pqrOmYfaVkzuAQgo4D4VbN2PibQuHPuPA6RKYU-keTzbFAX58l77hQTc4Cq28HpjFOeiDvNpNEgilNHFOfVA&amp;quot; | jq .
{
  &amp;quot;picture&amp;quot;: {
    &amp;quot;large&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/women/71.jpg&amp;quot;,
    &amp;quot;medium&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/med/women/71.jpg&amp;quot;,
    &amp;quot;thumbnail&amp;quot;: &amp;quot;https://randomuser.me/api/portraits/thumb/women/71.jpg&amp;quot;
  },
  &amp;quot;name&amp;quot;: {
    &amp;quot;title&amp;quot;: &amp;quot;ms&amp;quot;,
    &amp;quot;first&amp;quot;: &amp;quot;sofia&amp;quot;,
    &amp;quot;last&amp;quot;: &amp;quot;hansen&amp;quot;
  },
  &amp;quot;email&amp;quot;: &amp;quot;sofia.hansen@example.com&amp;quot;,
  &amp;quot;username&amp;quot;: &amp;quot;yellowfrog347&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we were to make a request with an invalid JWT, we will receive an error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl -s &amp;quot;http://localhost:8080/profile/details/yellowfrog347&amp;quot; --header &amp;quot;Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJncmVlbnJhYmJpdDk0OCIsImV4cCI6MTQ2ODE0MDg1MiwiaXNzIjoiaW4uc2RxYWxpLmp3dCJ9.t9pqrOmYfaVkzuAQgo4D4VbN2PibQuHPuPA6RKYU-keTzbFAX58l77hQTc4Cq28HpjFOeiDvNpNEgilNHFOfVAAAAAA&amp;quot; | jq .
{
  &amp;quot;error&amp;quot;: &amp;quot;JWT signature does not match locally computed signature. JWT validity cannot be asserted and should not be trusted.&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the next blog post, the fifth is this series, we will move on to building the front end with Angular JS and managing authentication from the front end. The source code for this example for the progress made from part 1 through part 4 is available on &lt;a href=&#34;https://github.com/sdqali/jwt-demo/tree/verify_tokens&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
